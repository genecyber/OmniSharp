/* Generated by JSIL v0.8.1 build 920. See http://jsil.org/ for more information. */ 
'use strict';
var $asm0B = JSIL.DeclareAssembly("nunit.framework, Version=2.6.4.14350, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77");

JSIL.DeclareNamespace("NUnit");
JSIL.DeclareNamespace("NUnit.Framework");
/* enum NUnit.Framework.ActionTargets */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.ActionTargets", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    Default: 0, 
    Test: 1, 
    Suite: 2, 
  }
);

/* delegate NUnit.Framework.TestDelegate */ 

JSIL.MakeDelegate("NUnit.Framework.TestDelegate", true, [], 
  JSIL.MethodSignature.Void);

/* class NUnit.Framework.Assert */ 

(function Assert$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Is)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.UInt32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.UInt64)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Decimal)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.Single)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0B.NUnit.Framework.TestDelegate)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.InstanceOfTypeConstraint)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionContainsConstraint)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ThrowsNothingConstraint)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0B.NUnit.Framework.AssertionException)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0A.System.IComparable)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0B.NUnit.Framework.IgnoreException)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0B.NUnit.Framework.InconclusiveException)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyStringConstraint)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyCollectionConstraint)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NullOrEmptyStringConstraint)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0B.NUnit.Framework.SuccessException)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0B.NUnit.Framework.TextMessageWriter)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T26 = function () {
    return ($T26 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExceptionTypeConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
        $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
        $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
        $asm0A.TypeRef("System.String")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [$asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.TestDelegate")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.AssertionException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.IgnoreException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.InconclusiveException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.SuccessException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.InvalidOperationException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.TextMessageWriter"), [$asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ], ["T"]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"])], ["T"]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ], ["T"]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$jsilcore.TypeRef("JSIL.Reference", ["!!0"])], ["T"]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Object"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $S10 = function () {
    return ($S10 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.AsyncInvocationRegion"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $S11 = function () {
    return ($S11 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
        $asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S12 = function () {
    return ($S12 = JSIL.Memoize(new JSIL.MethodSignature("!!0", [
        $asm0B.TypeRef("NUnit.Framework.TestDelegate"), $asm0A.TypeRef("System.String"), 
        $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ], ["T"]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function Assert__ctor () {
  };

  function Assert_AreEqual$00 (expected, actual, message, args) {
    $thisType.That(actual, $T03().EqualTo(expected), message, args);
  };

  function Assert_AreEqual$01 (expected, actual, message) {
    $thisType.That(actual, $T03().EqualTo(expected), message, null);
  };

  function Assert_AreEqual$02 (expected, actual) {
    $thisType.That(actual, $T03().EqualTo(expected), null, null);
  };

  function Assert_AreEqual$03 (expected, actual, message, args) {
    $thisType.That(
      actual, 
      $T03().EqualTo(expected), 
      message, 
      args
    );
  };

  function Assert_AreEqual$04 (expected, actual, message) {
    $thisType.That(
      actual, 
      $T03().EqualTo(expected), 
      message, 
      null
    );
  };

  function Assert_AreEqual$05 (expected, actual) {
    $thisType.That(
      actual, 
      $T03().EqualTo(expected), 
      null, 
      null
    );
  };

  function Assert_AreEqual$06 (expected, actual, message, args) {
    $thisType.That(actual, $T03().EqualTo(expected), message, args);
  };

  function Assert_AreEqual$07 (expected, actual, message) {
    $thisType.That(actual, $T03().EqualTo(expected), message, null);
  };

  function Assert_AreEqual$08 (expected, actual) {
    $thisType.That(actual, $T03().EqualTo(expected), null, null);
  };

  function Assert_AreEqual$09 (expected, actual, message, args) {
    $thisType.That(
      actual, 
      $T03().EqualTo(expected), 
      message, 
      args
    );
  };

  function Assert_AreEqual$0A (expected, actual, message) {
    $thisType.That(
      actual, 
      $T03().EqualTo(expected), 
      message, 
      null
    );
  };

  function Assert_AreEqual$0B (expected, actual) {
    $thisType.That(
      actual, 
      $T03().EqualTo(expected), 
      null, 
      null
    );
  };

  function Assert_AreEqual$0C (expected, actual, message, args) {
    $thisType.That(actual, $T03().EqualTo(expected), message, args);
  };

  function Assert_AreEqual$0D (expected, actual, message) {
    $thisType.That(actual, $T03().EqualTo(expected), message, null);
  };

  function Assert_AreEqual$0E (expected, actual) {
    $thisType.That(actual, $T03().EqualTo(expected), null, null);
  };

  function Assert_AreEqual$0F (expected, actual, delta, message, args) {
    $thisType.AssertDoublesAreEqual(
      expected, 
      actual, 
      delta, 
      message, 
      args
    );
  };

  function Assert_AreEqual$10 (expected, actual, delta, message) {
    $thisType.AssertDoublesAreEqual(
      expected, 
      actual, 
      delta, 
      message, 
      null
    );
  };

  function Assert_AreEqual$11 (expected, actual, delta) {
    $thisType.AssertDoublesAreEqual(
      expected, 
      actual, 
      delta, 
      null, 
      null
    );
  };

  function Assert_AreEqual$12 (expected, actual, delta, message, args) {
    $thisType.AssertDoublesAreEqual(
      expected, 
      JSIL.Nullable_Value(actual), 
      delta, 
      message, 
      args
    );
  };

  function Assert_AreEqual$13 (expected, actual, delta, message) {
    $thisType.AssertDoublesAreEqual(
      expected, 
      JSIL.Nullable_Value(actual), 
      delta, 
      message, 
      null
    );
  };

  function Assert_AreEqual$14 (expected, actual, delta) {
    $thisType.AssertDoublesAreEqual(
      expected, 
      JSIL.Nullable_Value(actual), 
      delta, 
      null, 
      null
    );
  };

  function Assert_AreEqual$15 (expected, actual, message, args) {
    $thisType.That(actual, $T03().EqualTo(expected), message, args);
  };

  function Assert_AreEqual$16 (expected, actual, message) {
    $thisType.That(actual, $T03().EqualTo(expected), message, null);
  };

  function Assert_AreEqual$17 (expected, actual) {
    $thisType.That(actual, $T03().EqualTo(expected), null, null);
  };

  function Assert_AreNotEqual$18 (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, args);
  };

  function Assert_AreNotEqual$19 (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, null);
  };

  function Assert_AreNotEqual$1A (expected, actual) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), null, null);
  };

  function Assert_AreNotEqual$1B (expected, actual, message, args) {
    $thisType.That(
      actual, 
      $T03().get_Not().EqualTo(expected), 
      message, 
      args
    );
  };

  function Assert_AreNotEqual$1C (expected, actual, message) {
    $thisType.That(
      actual, 
      $T03().get_Not().EqualTo(expected), 
      message, 
      null
    );
  };

  function Assert_AreNotEqual$1D (expected, actual) {
    $thisType.That(
      actual, 
      $T03().get_Not().EqualTo(expected), 
      null, 
      null
    );
  };

  function Assert_AreNotEqual$1E (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, args);
  };

  function Assert_AreNotEqual$1F (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, null);
  };

  function Assert_AreNotEqual$20 (expected, actual) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), null, null);
  };

  function Assert_AreNotEqual$21 (expected, actual, message, args) {
    $thisType.That(
      actual, 
      $T03().get_Not().EqualTo(expected), 
      message, 
      args
    );
  };

  function Assert_AreNotEqual$22 (expected, actual, message) {
    $thisType.That(
      actual, 
      $T03().get_Not().EqualTo(expected), 
      message, 
      null
    );
  };

  function Assert_AreNotEqual$23 (expected, actual) {
    $thisType.That(
      actual, 
      $T03().get_Not().EqualTo(expected), 
      null, 
      null
    );
  };

  function Assert_AreNotEqual$24 (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, args);
  };

  function Assert_AreNotEqual$25 (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, null);
  };

  function Assert_AreNotEqual$26 (expected, actual) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), null, null);
  };

  function Assert_AreNotEqual$27 (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, args);
  };

  function Assert_AreNotEqual$28 (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, null);
  };

  function Assert_AreNotEqual$29 (expected, actual) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), null, null);
  };

  function Assert_AreNotEqual$2A (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, args);
  };

  function Assert_AreNotEqual$2B (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, null);
  };

  function Assert_AreNotEqual$2C (expected, actual) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), null, null);
  };

  function Assert_AreNotEqual$2D (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, args);
  };

  function Assert_AreNotEqual$2E (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), message, null);
  };

  function Assert_AreNotEqual$2F (expected, actual) {
    $thisType.That(actual, $T03().get_Not().EqualTo(expected), null, null);
  };

  function Assert_AreNotSame$30 (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().SameAs(expected), message, args);
  };

  function Assert_AreNotSame$31 (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().SameAs(expected), message, null);
  };

  function Assert_AreNotSame$32 (expected, actual) {
    $thisType.That(actual, $T03().get_Not().SameAs(expected), null, null);
  };

  function Assert_AreSame$33 (expected, actual, message, args) {
    $thisType.That(actual, $T03().SameAs(expected), message, args);
  };

  function Assert_AreSame$34 (expected, actual, message) {
    $thisType.That(actual, $T03().SameAs(expected), message, null);
  };

  function Assert_AreSame$35 (expected, actual) {
    $thisType.That(actual, $T03().SameAs(expected), null, null);
  };

  function Assert_AssertDoublesAreEqual (expected, actual, delta, message, args) {
    if (!(!(isNaN(expected)) && !$T08().IsInfinity(expected))) {
      $thisType.That(actual, $T03().EqualTo(expected), message, args);
    } else {
      $thisType.That(actual, ($T03().EqualTo(expected)).Within(delta), message, args);
    }
  };

  function Assert_ByVal$36 (actual, expression) {
    $thisType.That(actual, expression, null, null);
  };

  function Assert_ByVal$37 (actual, expression, message) {
    $thisType.That(actual, expression, message, null);
  };

  function Assert_ByVal$38 (actual, expression, message, args) {
    $thisType.That(actual, expression, message, args);
  };

  function Assert_Catch$39 (code, message, args) {
    return $S00().CallStatic($thisType, "Throws", null, new ($T0F())($T10().__Type__), code, message, args);
  };

  function Assert_Catch$3A (code, message) {
    return $S01().CallStatic($thisType, "Throws", null, new ($T0F())($T10().__Type__), code, message);
  };

  function Assert_Catch$3B (code) {
    return $S02().CallStatic($thisType, "Throws", null, new ($T0F())($T10().__Type__), code);
  };

  function Assert_Catch$3C (expectedExceptionType, code, message, args) {
    return $S00().CallStatic($thisType, "Throws", null, new ($T0F())(expectedExceptionType), code, message, args);
  };

  function Assert_Catch$3D (expectedExceptionType, code, message) {
    return $S01().CallStatic($thisType, "Throws", null, new ($T0F())(expectedExceptionType), code, message);
  };

  function Assert_Catch$3E (expectedExceptionType, code) {
    return $S02().CallStatic($thisType, "Throws", null, new ($T0F())(expectedExceptionType), code);
  };

  function Assert_Catch$b1$3F (T, code, message, args) {
    return T.$Cast($S00().CallStatic($thisType, "Throws", null, new ($T0F())(T), code, message, args));
  };

  function Assert_Catch$b1$40 (T, code, message) {
    return T.$Cast($S01().CallStatic($thisType, "Throws", null, new ($T0F())(T), code, message));
  };

  function Assert_Catch$b1$41 (T, code) {
    return T.$Cast($S02().CallStatic($thisType, "Throws", null, new ($T0F())(T), code));
  };

  function Assert_Contains$42 (expected, actual, message, args) {
    $thisType.That(actual, new ($T13())(expected), message, args);
  };

  function Assert_Contains$43 (expected, actual, message) {
    $thisType.That(actual, new ($T13())(expected), message, null);
  };

  function Assert_Contains$44 (expected, actual) {
    $thisType.That(actual, new ($T13())(expected), null, null);
  };

  function Assert_DoesNotThrow$45 (code, message, args) {
    $thisType.That(code, new ($T14())(), message, args);
  };

  function Assert_DoesNotThrow$46 (code, message) {
    $thisType.DoesNotThrow(code, message, null);
  };

  function Assert_DoesNotThrow$47 (code) {
    $thisType.DoesNotThrow(code, $T01().Empty, null);
  };

  function Assert_Fail$48 (message, args) {
    if (message === null) {
      message = $T01().Empty;
    } else if (!((args === null) || ((args.length | 0) <= 0))) {
      message = $T01().Format(message, args);
    }
    throw $S03().Construct(message);
  };

  function Assert_Fail$49 (message) {
    $thisType.Fail(message, null);
  };

  function Assert_Fail$4A () {
    $thisType.Fail($T01().Empty, null);
  };

  function Assert_False$4B (condition, message, args) {
    $thisType.That(condition, $T03().get_False(), message, args);
  };

  function Assert_False$4C (condition, message) {
    $thisType.That(condition, $T03().get_False(), message, null);
  };

  function Assert_False$4D (condition) {
    $thisType.That(condition, $T03().get_False(), null, null);
  };

  function Assert_get_Counter () {
    var result = ($thisType.counter | 0);
    $thisType.counter = 0;
    return result;
  };

  function Assert_Greater$4E (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, args);
  };

  function Assert_Greater$4F (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, null);
  };

  function Assert_Greater$50 (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), null, null);
  };

  function Assert_Greater$51 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, args);
  };

  function Assert_Greater$52 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, null);
  };

  function Assert_Greater$53 (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), null, null);
  };

  function Assert_Greater$54 (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().GreaterThan(arg2), 
      message, 
      args
    );
  };

  function Assert_Greater$55 (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().GreaterThan(arg2), 
      message, 
      null
    );
  };

  function Assert_Greater$56 (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().GreaterThan(arg2), 
      null, 
      null
    );
  };

  function Assert_Greater$57 (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().GreaterThan(arg2), 
      message, 
      args
    );
  };

  function Assert_Greater$58 (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().GreaterThan(arg2), 
      message, 
      null
    );
  };

  function Assert_Greater$59 (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().GreaterThan(arg2), 
      null, 
      null
    );
  };

  function Assert_Greater$5A (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, args);
  };

  function Assert_Greater$5B (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, null);
  };

  function Assert_Greater$5C (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), null, null);
  };

  function Assert_Greater$5D (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, args);
  };

  function Assert_Greater$5E (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, null);
  };

  function Assert_Greater$5F (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), null, null);
  };

  function Assert_Greater$60 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, args);
  };

  function Assert_Greater$61 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, null);
  };

  function Assert_Greater$62 (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), null, null);
  };

  function Assert_Greater$63 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, args);
  };

  function Assert_Greater$64 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), message, null);
  };

  function Assert_Greater$65 (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThan(arg2), null, null);
  };

  function Assert_GreaterOrEqual$66 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, args);
  };

  function Assert_GreaterOrEqual$67 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, null);
  };

  function Assert_GreaterOrEqual$68 (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), null, null);
  };

  function Assert_GreaterOrEqual$69 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, args);
  };

  function Assert_GreaterOrEqual$6A (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, null);
  };

  function Assert_GreaterOrEqual$6B (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), null, null);
  };

  function Assert_GreaterOrEqual$6C (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().GreaterThanOrEqualTo(arg2), 
      message, 
      args
    );
  };

  function Assert_GreaterOrEqual$6D (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().GreaterThanOrEqualTo(arg2), 
      message, 
      null
    );
  };

  function Assert_GreaterOrEqual$6E (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().GreaterThanOrEqualTo(arg2), 
      null, 
      null
    );
  };

  function Assert_GreaterOrEqual$6F (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().GreaterThanOrEqualTo(arg2), 
      message, 
      args
    );
  };

  function Assert_GreaterOrEqual$70 (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().GreaterThanOrEqualTo(arg2), 
      message, 
      null
    );
  };

  function Assert_GreaterOrEqual$71 (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().GreaterThanOrEqualTo(arg2), 
      null, 
      null
    );
  };

  function Assert_GreaterOrEqual$72 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, args);
  };

  function Assert_GreaterOrEqual$73 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, null);
  };

  function Assert_GreaterOrEqual$74 (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), null, null);
  };

  function Assert_GreaterOrEqual$75 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, args);
  };

  function Assert_GreaterOrEqual$76 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, null);
  };

  function Assert_GreaterOrEqual$77 (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), null, null);
  };

  function Assert_GreaterOrEqual$78 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, args);
  };

  function Assert_GreaterOrEqual$79 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, null);
  };

  function Assert_GreaterOrEqual$7A (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), null, null);
  };

  function Assert_GreaterOrEqual$7B (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, args);
  };

  function Assert_GreaterOrEqual$7C (arg1, arg2, message) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), message, null);
  };

  function Assert_GreaterOrEqual$7D (arg1, arg2) {
    $thisType.That(arg1, $T03().GreaterThanOrEqualTo(arg2), null, null);
  };

  function Assert_Ignore$7E (message, args) {
    if (message === null) {
      message = $T01().Empty;
    } else if (!((args === null) || ((args.length | 0) <= 0))) {
      message = $T01().Format(message, args);
    }
    throw $S04().Construct(message);
  };

  function Assert_Ignore$7F (message) {
    $thisType.Ignore(message, null);
  };

  function Assert_Ignore$80 () {
    $thisType.Ignore($T01().Empty, null);
  };

  function Assert_Inconclusive$81 (message, args) {
    if (message === null) {
      message = $T01().Empty;
    } else if (!((args === null) || ((args.length | 0) <= 0))) {
      message = $T01().Format(message, args);
    }
    throw $S05().Construct(message);
  };

  function Assert_Inconclusive$82 (message) {
    $thisType.Inconclusive(message, null);
  };

  function Assert_Inconclusive$83 () {
    $thisType.Inconclusive($T01().Empty, null);
  };

  function Assert_IncrementAssertCount () {
    $thisType.counter = ((($thisType.counter | 0) + 1) | 0);
  };

  function Assert_IsAssignableFrom$84 (expected, actual, message, args) {
    $thisType.That(actual, $T03().AssignableFrom(expected), message, args);
  };

  function Assert_IsAssignableFrom$85 (expected, actual, message) {
    $thisType.That(actual, $T03().AssignableFrom(expected), message, null);
  };

  function Assert_IsAssignableFrom$86 (expected, actual) {
    $thisType.That(actual, $T03().AssignableFrom(expected), null, null);
  };

  function Assert_IsAssignableFrom$b1$87 (T, actual, message, args) {
    $thisType.That(actual, $T03().AssignableFrom(T), message, args);
  };

  function Assert_IsAssignableFrom$b1$88 (T, actual, message) {
    $thisType.That(actual, $T03().AssignableFrom(T), message, null);
  };

  function Assert_IsAssignableFrom$b1$89 (T, actual) {
    $thisType.That(actual, $T03().AssignableFrom(T), null, null);
  };

  function Assert_IsEmpty$8A (aString, message, args) {
    $thisType.That(aString, new ($T1A())(), message, args);
  };

  function Assert_IsEmpty$8B (aString, message) {
    $thisType.That(aString, new ($T1A())(), message, null);
  };

  function Assert_IsEmpty$8C (aString) {
    $thisType.That(aString, new ($T1A())(), null, null);
  };

  function Assert_IsEmpty$8D (collection, message, args) {
    $thisType.That(collection, new ($T1C())(), message, args);
  };

  function Assert_IsEmpty$8E (collection, message) {
    $thisType.That(collection, new ($T1C())(), message, null);
  };

  function Assert_IsEmpty$8F (collection) {
    $thisType.That(collection, new ($T1C())(), null, null);
  };

  function Assert_IsFalse$90 (condition, message, args) {
    $thisType.That(condition, $T03().get_False(), message, args);
  };

  function Assert_IsFalse$91 (condition, message) {
    $thisType.That(condition, $T03().get_False(), message, null);
  };

  function Assert_IsFalse$92 (condition) {
    $thisType.That(condition, $T03().get_False(), null, null);
  };

  function Assert_IsInstanceOf$93 (expected, actual, message, args) {
    $thisType.That(actual, $T03().InstanceOf(expected), message, args);
  };

  function Assert_IsInstanceOf$94 (expected, actual, message) {
    $thisType.That(actual, $T03().InstanceOf(expected), message, null);
  };

  function Assert_IsInstanceOf$95 (expected, actual) {
    $thisType.That(actual, $T03().InstanceOf(expected), null, null);
  };

  function Assert_IsInstanceOf$b1$96 (T, actual, message, args) {
    $thisType.That(actual, $T03().InstanceOf(T), message, args);
  };

  function Assert_IsInstanceOf$b1$97 (T, actual, message) {
    $thisType.That(actual, $T03().InstanceOf(T), message, null);
  };

  function Assert_IsInstanceOf$b1$98 (T, actual) {
    $thisType.That(actual, $T03().InstanceOf(T), null, null);
  };

  function Assert_IsInstanceOfType$99 (expected, actual, message, args) {
    $thisType.That(actual, $T03().InstanceOf(expected), message, args);
  };

  function Assert_IsInstanceOfType$9A (expected, actual, message) {
    $thisType.That(actual, $T03().InstanceOf(expected), message, null);
  };

  function Assert_IsInstanceOfType$9B (expected, actual) {
    $thisType.That(actual, $T03().InstanceOf(expected), null, null);
  };

  function Assert_IsNaN$9C (aDouble, message, args) {
    $thisType.That(aDouble, $T03().get_NaN(), message, args);
  };

  function Assert_IsNaN$9D (aDouble, message) {
    $thisType.That(aDouble, $T03().get_NaN(), message, null);
  };

  function Assert_IsNaN$9E (aDouble) {
    $thisType.That(aDouble, $T03().get_NaN(), null, null);
  };

  function Assert_IsNaN$9F (aDouble, message, args) {
    $thisType.That(aDouble, $T03().get_NaN(), message, args);
  };

  function Assert_IsNaN$A0 (aDouble, message) {
    $thisType.That(aDouble, $T03().get_NaN(), message, null);
  };

  function Assert_IsNaN$A1 (aDouble) {
    $thisType.That(aDouble, $T03().get_NaN(), null, null);
  };

  function Assert_IsNotAssignableFrom$A2 (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().AssignableFrom(expected), message, args);
  };

  function Assert_IsNotAssignableFrom$A3 (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().AssignableFrom(expected), message, null);
  };

  function Assert_IsNotAssignableFrom$A4 (expected, actual) {
    $thisType.That(actual, $T03().get_Not().AssignableFrom(expected), null, null);
  };

  function Assert_IsNotAssignableFrom$b1$A5 (T, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().AssignableFrom(T), message, args);
  };

  function Assert_IsNotAssignableFrom$b1$A6 (T, actual, message) {
    $thisType.That(actual, $T03().get_Not().AssignableFrom(T), message, null);
  };

  function Assert_IsNotAssignableFrom$b1$A7 (T, actual) {
    $thisType.That(actual, $T03().get_Not().AssignableFrom(T), null, null);
  };

  function Assert_IsNotEmpty$A8 (aString, message, args) {
    $thisType.That(aString, $T03().get_Not().get_Empty(), message, args);
  };

  function Assert_IsNotEmpty$A9 (aString, message) {
    $thisType.That(aString, $T03().get_Not().get_Empty(), message, null);
  };

  function Assert_IsNotEmpty$AA (aString) {
    $thisType.That(aString, $T03().get_Not().get_Empty(), null, null);
  };

  function Assert_IsNotEmpty$AB (collection, message, args) {
    $thisType.That(collection, $T03().get_Not().get_Empty(), message, args);
  };

  function Assert_IsNotEmpty$AC (collection, message) {
    $thisType.That(collection, $T03().get_Not().get_Empty(), message, null);
  };

  function Assert_IsNotEmpty$AD (collection) {
    $thisType.That(collection, $T03().get_Not().get_Empty(), null, null);
  };

  function Assert_IsNotInstanceOf$AE (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(expected), message, args);
  };

  function Assert_IsNotInstanceOf$AF (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(expected), message, null);
  };

  function Assert_IsNotInstanceOf$B0 (expected, actual) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(expected), null, null);
  };

  function Assert_IsNotInstanceOf$b1$B1 (T, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(T), message, args);
  };

  function Assert_IsNotInstanceOf$b1$B2 (T, actual, message) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(T), message, null);
  };

  function Assert_IsNotInstanceOf$b1$B3 (T, actual) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(T), null, null);
  };

  function Assert_IsNotInstanceOfType$B4 (expected, actual, message, args) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(expected), message, args);
  };

  function Assert_IsNotInstanceOfType$B5 (expected, actual, message) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(expected), message, null);
  };

  function Assert_IsNotInstanceOfType$B6 (expected, actual) {
    $thisType.That(actual, $T03().get_Not().InstanceOf(expected), null, null);
  };

  function Assert_IsNotNull$B7 (anObject, message, args) {
    $thisType.That(anObject, $T03().get_Not().get_Null(), message, args);
  };

  function Assert_IsNotNull$B8 (anObject, message) {
    $thisType.That(anObject, $T03().get_Not().get_Null(), message, null);
  };

  function Assert_IsNotNull$B9 (anObject) {
    $thisType.That(anObject, $T03().get_Not().get_Null(), null, null);
  };

  function Assert_IsNotNullOrEmpty$BA (aString, message, args) {
    $thisType.That(aString, new ($T1D())(new ($T1E())()), message, args);
  };

  function Assert_IsNotNullOrEmpty$BB (aString, message) {
    $thisType.That(aString, new ($T1D())(new ($T1E())()), message, null);
  };

  function Assert_IsNotNullOrEmpty$BC (aString) {
    $thisType.That(aString, new ($T1D())(new ($T1E())()), null, null);
  };

  function Assert_IsNull$BD (anObject, message, args) {
    $thisType.That(anObject, $T03().get_Null(), message, args);
  };

  function Assert_IsNull$BE (anObject, message) {
    $thisType.That(anObject, $T03().get_Null(), message, null);
  };

  function Assert_IsNull$BF (anObject) {
    $thisType.That(anObject, $T03().get_Null(), null, null);
  };

  function Assert_IsNullOrEmpty$C0 (aString, message, args) {
    $thisType.That(aString, new ($T1E())(), message, args);
  };

  function Assert_IsNullOrEmpty$C1 (aString, message) {
    $thisType.That(aString, new ($T1E())(), message, null);
  };

  function Assert_IsNullOrEmpty$C2 (aString) {
    $thisType.That(aString, new ($T1E())(), null, null);
  };

  function Assert_IsTrue$C3 (condition, message, args) {
    $thisType.That(condition, $T03().get_True(), message, args);
  };

  function Assert_IsTrue$C4 (condition, message) {
    $thisType.That(condition, $T03().get_True(), message, null);
  };

  function Assert_IsTrue$C5 (condition) {
    $thisType.That(condition, $T03().get_True(), null, null);
  };

  function Assert_Less$C6 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, args);
  };

  function Assert_Less$C7 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, null);
  };

  function Assert_Less$C8 (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThan(arg2), null, null);
  };

  function Assert_Less$C9 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, args);
  };

  function Assert_Less$CA (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, null);
  };

  function Assert_Less$CB (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThan(arg2), null, null);
  };

  function Assert_Less$CC (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().LessThan(arg2), 
      message, 
      args
    );
  };

  function Assert_Less$CD (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().LessThan(arg2), 
      message, 
      null
    );
  };

  function Assert_Less$CE (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().LessThan(arg2), 
      null, 
      null
    );
  };

  function Assert_Less$CF (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().LessThan(arg2), 
      message, 
      args
    );
  };

  function Assert_Less$D0 (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().LessThan(arg2), 
      message, 
      null
    );
  };

  function Assert_Less$D1 (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().LessThan(arg2), 
      null, 
      null
    );
  };

  function Assert_Less$D2 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, args);
  };

  function Assert_Less$D3 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, null);
  };

  function Assert_Less$D4 (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThan(arg2), null, null);
  };

  function Assert_Less$D5 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, args);
  };

  function Assert_Less$D6 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, null);
  };

  function Assert_Less$D7 (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThan(arg2), null, null);
  };

  function Assert_Less$D8 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, args);
  };

  function Assert_Less$D9 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, null);
  };

  function Assert_Less$DA (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThan(arg2), null, null);
  };

  function Assert_Less$DB (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, args);
  };

  function Assert_Less$DC (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThan(arg2), message, null);
  };

  function Assert_Less$DD (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThan(arg2), null, null);
  };

  function Assert_LessOrEqual$DE (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, args);
  };

  function Assert_LessOrEqual$DF (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, null);
  };

  function Assert_LessOrEqual$E0 (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), null, null);
  };

  function Assert_LessOrEqual$E1 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, args);
  };

  function Assert_LessOrEqual$E2 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, null);
  };

  function Assert_LessOrEqual$E3 (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), null, null);
  };

  function Assert_LessOrEqual$E4 (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().LessThanOrEqualTo(arg2), 
      message, 
      args
    );
  };

  function Assert_LessOrEqual$E5 (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().LessThanOrEqualTo(arg2), 
      message, 
      null
    );
  };

  function Assert_LessOrEqual$E6 (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().LessThanOrEqualTo(arg2), 
      null, 
      null
    );
  };

  function Assert_LessOrEqual$E7 (arg1, arg2, message, args) {
    $thisType.That(
      arg1, 
      $T03().LessThanOrEqualTo(arg2), 
      message, 
      args
    );
  };

  function Assert_LessOrEqual$E8 (arg1, arg2, message) {
    $thisType.That(
      arg1, 
      $T03().LessThanOrEqualTo(arg2), 
      message, 
      null
    );
  };

  function Assert_LessOrEqual$E9 (arg1, arg2) {
    $thisType.That(
      arg1, 
      $T03().LessThanOrEqualTo(arg2), 
      null, 
      null
    );
  };

  function Assert_LessOrEqual$EA (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, args);
  };

  function Assert_LessOrEqual$EB (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, null);
  };

  function Assert_LessOrEqual$EC (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), null, null);
  };

  function Assert_LessOrEqual$ED (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, args);
  };

  function Assert_LessOrEqual$EE (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, null);
  };

  function Assert_LessOrEqual$EF (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), null, null);
  };

  function Assert_LessOrEqual$F0 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, args);
  };

  function Assert_LessOrEqual$F1 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, null);
  };

  function Assert_LessOrEqual$F2 (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), null, null);
  };

  function Assert_LessOrEqual$F3 (arg1, arg2, message, args) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, args);
  };

  function Assert_LessOrEqual$F4 (arg1, arg2, message) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), message, null);
  };

  function Assert_LessOrEqual$F5 (arg1, arg2) {
    $thisType.That(arg1, $T03().LessThanOrEqualTo(arg2), null, null);
  };

  function Assert_NotNull$F6 (anObject, message, args) {
    $thisType.That(anObject, $T03().get_Not().get_Null(), message, args);
  };

  function Assert_NotNull$F7 (anObject, message) {
    $thisType.That(anObject, $T03().get_Not().get_Null(), message, null);
  };

  function Assert_NotNull$F8 (anObject) {
    $thisType.That(anObject, $T03().get_Not().get_Null(), null, null);
  };

  function Assert_Null$F9 (anObject, message, args) {
    $thisType.That(anObject, $T03().get_Null(), message, args);
  };

  function Assert_Null$FA (anObject, message) {
    $thisType.That(anObject, $T03().get_Null(), message, null);
  };

  function Assert_Null$FB (anObject) {
    $thisType.That(anObject, $T03().get_Null(), null, null);
  };

  function Assert_Pass$FC (message, args) {
    if (message === null) {
      message = $T01().Empty;
    } else if (!((args === null) || ((args.length | 0) <= 0))) {
      message = $T01().Format(message, args);
    }
    throw $S06().Construct(message);
  };

  function Assert_Pass$FD (message) {
    $thisType.Pass(message, null);
  };

  function Assert_Pass$FE () {
    $thisType.Pass($T01().Empty, null);
  };

  function Assert_ReferenceEquals$FF (a, b) {
    throw $S07().Construct("Assert.ReferenceEquals should not be used for Assertions");
  };

  function Assert_That$100 (actual, expression) {
    $thisType.That(actual, expression, null, null);
  };

  function Assert_That$101 (actual, expression, message) {
    $thisType.That(actual, expression, message, null);
  };

  function Assert_That$102 (actual, expression, message, args) {
    var constraint = $IM00().Call(expression, null);
    $thisType.IncrementAssertCount();
    if (!$S08().CallVirtual("Matches", null, constraint, actual)) {
      var messageWriter = $S09().Construct(message, args);
      constraint.WriteMessageTo(messageWriter);
      throw $S03().Construct(messageWriter.toString());
    }
  };

  function Assert_That$103 (condition, message, args) {
    $thisType.That(condition, $T03().get_True(), message, args);
  };

  function Assert_That$104 (condition, message) {
    $thisType.That(condition, $T03().get_True(), message, null);
  };

  function Assert_That$105 (condition) {
    $thisType.That(condition, $T03().get_True(), null, null);
  };

  function Assert_That$b1$106 (T, del, expr) {
    $S0A().CallStatic($thisType, "That$b1", [T], del, $IM00().Call(expr, null), null, null);
  };

  function Assert_That$b1$107 (T, del, expr, message) {
    $S0A().CallStatic($thisType, "That$b1", [T], del, $IM00().Call(expr, null), message, null);
  };

  function Assert_That$b1$108 (T, del, expr, message, args) {
    var constraint = $IM00().Call(expr, null);
    $thisType.IncrementAssertCount();
    if (!$S0B().CallVirtual("Matches$b1", [T], constraint, del)) {
      var messageWriter = $S09().Construct(message, args);
      constraint.WriteMessageTo(messageWriter);
      throw $S03().Construct(messageWriter.toString());
    }
  };

  function Assert_That$b1$109 (T, /* ref */ actual, expression) {
    $S0C().CallStatic($thisType, "That$b1", [T], /* ref */ actual, expression, null, null);
  };

  function Assert_That$b1$10A (T, /* ref */ actual, expression, message) {
    $S0C().CallStatic($thisType, "That$b1", [T], /* ref */ actual, expression, message, null);
  };

  function Assert_That$b1$10B (T, /* ref */ actual, expression, message, args) {
    var constraint = $IM00().Call(expression, null);
    $thisType.IncrementAssertCount();
    if (!$S0D().CallVirtual("Matches$b1", [T], constraint, /* ref */ actual)) {
      var messageWriter = $S09().Construct(message, args);
      constraint.WriteMessageTo(messageWriter);
      throw $S03().Construct(messageWriter.toString());
    }
  };

  function Assert_That$10C (code, constraint) {
    $S0E().CallStatic($thisType, "That", null, code, constraint);
  };

  function Assert_Throws$10D (expression, code, message, args, $exception) {
    var ex = null;
    if ($S0F().CallStatic($T24(), "IsAsyncOperation", null, code)) {
      var asyncInvocationRegion = $S10().CallStatic($T24(), "Create", null, code);
      try {
        code();
        try {
          asyncInvocationRegion.WaitForPendingOperationsToComplete(null);
        } catch ($exception) {
          ex = $exception;
        }
      } finally {
        if (asyncInvocationRegion !== null) {
          $IM01().Call(asyncInvocationRegion, null);
        }
      }
    } else {
      try {
        code();
      } catch ($exception) {
        ex = $exception;
      }
    }
    $thisType.That(ex, expression, message, args);
    return ex;
  };

  function Assert_Throws$10E (expression, code, message) {
    return $S00().CallStatic($thisType, "Throws", null, expression, code, message, null);
  };

  function Assert_Throws$10F (expression, code) {
    return $S00().CallStatic($thisType, "Throws", null, expression, code, $T01().Empty, null);
  };

  function Assert_Throws$110 (expectedExceptionType, code, message, args) {
    return $S00().CallStatic($thisType, "Throws", null, new ($T26())(expectedExceptionType), code, message, args);
  };

  function Assert_Throws$111 (expectedExceptionType, code, message) {
    return $S00().CallStatic($thisType, "Throws", null, new ($T26())(expectedExceptionType), code, message, null);
  };

  function Assert_Throws$112 (expectedExceptionType, code) {
    return $S00().CallStatic($thisType, "Throws", null, new ($T26())(expectedExceptionType), code, $T01().Empty, null);
  };

  function Assert_Throws$b1$113 (T, code, message, args) {
    return T.$Cast($S11().CallStatic($thisType, "Throws", null, T, code, message, args));
  };

  function Assert_Throws$b1$114 (T, code, message) {
    return $S12().CallStatic($thisType, "Throws$b1", [T], code, message, null);
  };

  function Assert_Throws$b1$115 (T, code) {
    return $S12().CallStatic($thisType, "Throws$b1", [T], code, $T01().Empty, null);
  };

  function Assert_True$116 (condition, message, args) {
    $thisType.That(condition, $T03().get_True(), message, args);
  };

  function Assert_True$117 (condition, message) {
    $thisType.That(condition, $T03().get_True(), message, null);
  };

  function Assert_True$118 (condition) {
    $thisType.That(condition, $T03().get_True(), null, null);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Assert", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      Assert__ctor
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$00
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String
        ]), 
      Assert_AreEqual$01
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      Assert_AreEqual$02
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$03
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String
        ]), 
      Assert_AreEqual$04
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$.Int64, $.Int64]), 
      Assert_AreEqual$05
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$06
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String
        ]), 
      Assert_AreEqual$07
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$.UInt32, $.UInt32]), 
      Assert_AreEqual$08
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$09
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String
        ]), 
      Assert_AreEqual$0A
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$.UInt64, $.UInt64]), 
      Assert_AreEqual$0B
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$0C
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String
        ]), 
      Assert_AreEqual$0D
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal")]), 
      Assert_AreEqual$0E
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$0F
    )
      .Parameter(4, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.String
        ]), 
      Assert_AreEqual$10
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ]), 
      Assert_AreEqual$11
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $asm0A.TypeRef("System.Nullable`1", [$.Double]), 
          $.Double, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$12
    )
      .Parameter(4, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $asm0A.TypeRef("System.Nullable`1", [$.Double]), 
          $.Double, $.String
        ]), 
      Assert_AreEqual$13
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $asm0A.TypeRef("System.Nullable`1", [$.Double]), 
          $.Double
        ]), 
      Assert_AreEqual$14
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreEqual$15
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String
        ]), 
      Assert_AreEqual$16
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      Assert_AreEqual$17
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$18
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String
        ]), 
      Assert_AreNotEqual$19
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      Assert_AreNotEqual$1A
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$1B
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String
        ]), 
      Assert_AreNotEqual$1C
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.Int64, $.Int64]), 
      Assert_AreNotEqual$1D
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$1E
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String
        ]), 
      Assert_AreNotEqual$1F
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.UInt32, $.UInt32]), 
      Assert_AreNotEqual$20
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$21
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String
        ]), 
      Assert_AreNotEqual$22
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.UInt64, $.UInt64]), 
      Assert_AreNotEqual$23
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$24
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String
        ]), 
      Assert_AreNotEqual$25
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal")]), 
      Assert_AreNotEqual$26
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$27
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String
        ]), 
      Assert_AreNotEqual$28
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      Assert_AreNotEqual$29
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$2A
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String
        ]), 
      Assert_AreNotEqual$2B
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      Assert_AreNotEqual$2C
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotEqual$2D
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String
        ]), 
      Assert_AreNotEqual$2E
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      Assert_AreNotEqual$2F
    );

    $.Method({Static:true , Public:true }, "AreNotSame", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreNotSame$30
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotSame", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String
        ]), 
      Assert_AreNotSame$31
    );

    $.Method({Static:true , Public:true }, "AreNotSame", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      Assert_AreNotSame$32
    );

    $.Method({Static:true , Public:true }, "AreSame", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AreSame$33
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreSame", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.String
        ]), 
      Assert_AreSame$34
    );

    $.Method({Static:true , Public:true }, "AreSame", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      Assert_AreSame$35
    );

    $.Method({Static:true , Public:false}, "AssertDoublesAreEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_AssertDoublesAreEqual
    );

    $.Method({Static:true , Public:true }, "ByVal", 
      new JSIL.MethodSignature(null, [$.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      Assert_ByVal$36
    );

    $.Method({Static:true , Public:true }, "ByVal", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ]), 
      Assert_ByVal$37
    );

    $.Method({Static:true , Public:true }, "ByVal", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_ByVal$38
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
          $asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Catch$39
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [$asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String]), 
      Assert_Catch$3A
    );

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [$asm0B.TypeRef("NUnit.Framework.TestDelegate")]), 
      Assert_Catch$3B
    );

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
          $asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Catch$3C
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
          $asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
          $.String
        ]), 
      Assert_Catch$3D
    );

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [$asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.TestDelegate")]), 
      Assert_Catch$3E
    );

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature("!!0", [
          $asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_Catch$b1$3F
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature("!!0", [$asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String], ["T"]), 
      Assert_Catch$b1$40
    );

    $.Method({Static:true , Public:true }, "Catch", 
      new JSIL.MethodSignature("!!0", [$asm0B.TypeRef("NUnit.Framework.TestDelegate")], ["T"]), 
      Assert_Catch$b1$41
    );

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0A.TypeRef("System.Collections.ICollection"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Contains$42
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0A.TypeRef("System.Collections.ICollection"), 
          $.String
        ]), 
      Assert_Contains$43
    );

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [$.Object, $asm0A.TypeRef("System.Collections.ICollection")]), 
      Assert_Contains$44
    );

    $.Method({Static:true , Public:true }, "DoesNotThrow", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_DoesNotThrow$45
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "DoesNotThrow", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String]), 
      Assert_DoesNotThrow$46
    );

    $.Method({Static:true , Public:true }, "DoesNotThrow", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.TestDelegate")), 
      Assert_DoesNotThrow$47
    );

    $.Method({Static:true , Public:true }, "Fail", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("System.Array", [$.Object])]), 
      Assert_Fail$48
    )
      .Parameter(1, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Fail", 
      JSIL.MethodSignature.Action($.String), 
      Assert_Fail$49
    );

    $.Method({Static:true , Public:true }, "Fail", 
      JSIL.MethodSignature.Void, 
      Assert_Fail$4A
    );

    $.Method({Static:true , Public:true }, "False", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_False$4B
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "False", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String]), 
      Assert_False$4C
    );

    $.Method({Static:true , Public:true }, "False", 
      JSIL.MethodSignature.Action($.Boolean), 
      Assert_False$4D
    );

    $.Method({Static:true , Public:true }, "get_Counter", 
      JSIL.MethodSignature.Return($.Int32), 
      Assert_get_Counter
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$4E
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String
        ]), 
      Assert_Greater$4F
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      Assert_Greater$50
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$51
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String
        ]), 
      Assert_Greater$52
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$.UInt32, $.UInt32]), 
      Assert_Greater$53
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$54
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String
        ]), 
      Assert_Greater$55
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$.Int64, $.Int64]), 
      Assert_Greater$56
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$57
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String
        ]), 
      Assert_Greater$58
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$.UInt64, $.UInt64]), 
      Assert_Greater$59
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$5A
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String
        ]), 
      Assert_Greater$5B
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal")]), 
      Assert_Greater$5C
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$5D
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String
        ]), 
      Assert_Greater$5E
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      Assert_Greater$5F
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$60
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String
        ]), 
      Assert_Greater$61
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      Assert_Greater$62
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Greater$63
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String
        ]), 
      Assert_Greater$64
    );

    $.Method({Static:true , Public:true }, "Greater", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable")]), 
      Assert_Greater$65
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$66
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String
        ]), 
      Assert_GreaterOrEqual$67
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      Assert_GreaterOrEqual$68
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$69
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String
        ]), 
      Assert_GreaterOrEqual$6A
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$.UInt32, $.UInt32]), 
      Assert_GreaterOrEqual$6B
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$6C
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String
        ]), 
      Assert_GreaterOrEqual$6D
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$.Int64, $.Int64]), 
      Assert_GreaterOrEqual$6E
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$6F
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String
        ]), 
      Assert_GreaterOrEqual$70
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$.UInt64, $.UInt64]), 
      Assert_GreaterOrEqual$71
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$72
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String
        ]), 
      Assert_GreaterOrEqual$73
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal")]), 
      Assert_GreaterOrEqual$74
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$75
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String
        ]), 
      Assert_GreaterOrEqual$76
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      Assert_GreaterOrEqual$77
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$78
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String
        ]), 
      Assert_GreaterOrEqual$79
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      Assert_GreaterOrEqual$7A
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_GreaterOrEqual$7B
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String
        ]), 
      Assert_GreaterOrEqual$7C
    );

    $.Method({Static:true , Public:true }, "GreaterOrEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable")]), 
      Assert_GreaterOrEqual$7D
    );

    $.Method({Static:true , Public:true }, "Ignore", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("System.Array", [$.Object])]), 
      Assert_Ignore$7E
    )
      .Parameter(1, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Ignore", 
      JSIL.MethodSignature.Action($.String), 
      Assert_Ignore$7F
    );

    $.Method({Static:true , Public:true }, "Ignore", 
      JSIL.MethodSignature.Void, 
      Assert_Ignore$80
    );

    $.Method({Static:true , Public:true }, "Inconclusive", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("System.Array", [$.Object])]), 
      Assert_Inconclusive$81
    )
      .Parameter(1, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Inconclusive", 
      JSIL.MethodSignature.Action($.String), 
      Assert_Inconclusive$82
    );

    $.Method({Static:true , Public:true }, "Inconclusive", 
      JSIL.MethodSignature.Void, 
      Assert_Inconclusive$83
    );

    $.Method({Static:true , Public:false}, "IncrementAssertCount", 
      JSIL.MethodSignature.Void, 
      Assert_IncrementAssertCount
    );

    $.Method({Static:true , Public:true }, "IsAssignableFrom", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsAssignableFrom$84
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsAssignableFrom", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String
        ]), 
      Assert_IsAssignableFrom$85
    );

    $.Method({Static:true , Public:true }, "IsAssignableFrom", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.Object]), 
      Assert_IsAssignableFrom$86
    );

    $.Method({Static:true , Public:true }, "IsAssignableFrom", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_IsAssignableFrom$b1$87
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsAssignableFrom", 
      new JSIL.MethodSignature(null, [$.Object, $.String], ["T"]), 
      Assert_IsAssignableFrom$b1$88
    );

    $.Method({Static:true , Public:true }, "IsAssignableFrom", 
      new JSIL.MethodSignature(null, [$.Object], ["T"]), 
      Assert_IsAssignableFrom$b1$89
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsEmpty$8A
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      Assert_IsEmpty$8B
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      JSIL.MethodSignature.Action($.String), 
      Assert_IsEmpty$8C
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsEmpty$8D
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.String]), 
      Assert_IsEmpty$8E
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      Assert_IsEmpty$8F
    );

    $.Method({Static:true , Public:true }, "IsFalse", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsFalse$90
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsFalse", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String]), 
      Assert_IsFalse$91
    );

    $.Method({Static:true , Public:true }, "IsFalse", 
      JSIL.MethodSignature.Action($.Boolean), 
      Assert_IsFalse$92
    );

    $.Method({Static:true , Public:true }, "IsInstanceOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsInstanceOf$93
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsInstanceOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String
        ]), 
      Assert_IsInstanceOf$94
    );

    $.Method({Static:true , Public:true }, "IsInstanceOf", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.Object]), 
      Assert_IsInstanceOf$95
    );

    $.Method({Static:true , Public:true }, "IsInstanceOf", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_IsInstanceOf$b1$96
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsInstanceOf", 
      new JSIL.MethodSignature(null, [$.Object, $.String], ["T"]), 
      Assert_IsInstanceOf$b1$97
    );

    $.Method({Static:true , Public:true }, "IsInstanceOf", 
      new JSIL.MethodSignature(null, [$.Object], ["T"]), 
      Assert_IsInstanceOf$b1$98
    );

    $.Method({Static:true , Public:true }, "IsInstanceOfType", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsInstanceOfType$99
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"))
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsInstanceOfType", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String
        ]), 
      Assert_IsInstanceOfType$9A
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:true , Public:true }, "IsInstanceOfType", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.Object]), 
      Assert_IsInstanceOfType$9B
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:true , Public:true }, "IsNaN", 
      new JSIL.MethodSignature(null, [
          $.Double, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNaN$9C
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNaN", 
      new JSIL.MethodSignature(null, [$.Double, $.String]), 
      Assert_IsNaN$9D
    );

    $.Method({Static:true , Public:true }, "IsNaN", 
      JSIL.MethodSignature.Action($.Double), 
      Assert_IsNaN$9E
    );

    $.Method({Static:true , Public:true }, "IsNaN", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Nullable`1", [$.Double]), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNaN$9F
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNaN", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Nullable`1", [$.Double]), $.String]), 
      Assert_IsNaN$A0
    );

    $.Method({Static:true , Public:true }, "IsNaN", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Nullable`1", [$.Double])), 
      Assert_IsNaN$A1
    );

    $.Method({Static:true , Public:true }, "IsNotAssignableFrom", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNotAssignableFrom$A2
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotAssignableFrom", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String
        ]), 
      Assert_IsNotAssignableFrom$A3
    );

    $.Method({Static:true , Public:true }, "IsNotAssignableFrom", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.Object]), 
      Assert_IsNotAssignableFrom$A4
    );

    $.Method({Static:true , Public:true }, "IsNotAssignableFrom", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_IsNotAssignableFrom$b1$A5
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotAssignableFrom", 
      new JSIL.MethodSignature(null, [$.Object, $.String], ["T"]), 
      Assert_IsNotAssignableFrom$b1$A6
    );

    $.Method({Static:true , Public:true }, "IsNotAssignableFrom", 
      new JSIL.MethodSignature(null, [$.Object], ["T"]), 
      Assert_IsNotAssignableFrom$b1$A7
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNotEmpty$A8
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      Assert_IsNotEmpty$A9
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      JSIL.MethodSignature.Action($.String), 
      Assert_IsNotEmpty$AA
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNotEmpty$AB
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.String]), 
      Assert_IsNotEmpty$AC
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      Assert_IsNotEmpty$AD
    );

    $.Method({Static:true , Public:true }, "IsNotInstanceOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNotInstanceOf$AE
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotInstanceOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String
        ]), 
      Assert_IsNotInstanceOf$AF
    );

    $.Method({Static:true , Public:true }, "IsNotInstanceOf", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.Object]), 
      Assert_IsNotInstanceOf$B0
    );

    $.Method({Static:true , Public:true }, "IsNotInstanceOf", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_IsNotInstanceOf$b1$B1
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotInstanceOf", 
      new JSIL.MethodSignature(null, [$.Object, $.String], ["T"]), 
      Assert_IsNotInstanceOf$b1$B2
    );

    $.Method({Static:true , Public:true }, "IsNotInstanceOf", 
      new JSIL.MethodSignature(null, [$.Object], ["T"]), 
      Assert_IsNotInstanceOf$b1$B3
    );

    $.Method({Static:true , Public:true }, "IsNotInstanceOfType", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNotInstanceOfType$B4
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"))
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotInstanceOfType", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Type"), $.Object, 
          $.String
        ]), 
      Assert_IsNotInstanceOfType$B5
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:true , Public:true }, "IsNotInstanceOfType", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.Object]), 
      Assert_IsNotInstanceOfType$B6
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:true , Public:true }, "IsNotNull", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNotNull$B7
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotNull", 
      new JSIL.MethodSignature(null, [$.Object, $.String]), 
      Assert_IsNotNull$B8
    );

    $.Method({Static:true , Public:true }, "IsNotNull", 
      JSIL.MethodSignature.Action($.Object), 
      Assert_IsNotNull$B9
    );

    $.Method({Static:true , Public:true }, "IsNotNullOrEmpty", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNotNullOrEmpty$BA
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotNullOrEmpty", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      Assert_IsNotNullOrEmpty$BB
    );

    $.Method({Static:true , Public:true }, "IsNotNullOrEmpty", 
      JSIL.MethodSignature.Action($.String), 
      Assert_IsNotNullOrEmpty$BC
    );

    $.Method({Static:true , Public:true }, "IsNull", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNull$BD
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNull", 
      new JSIL.MethodSignature(null, [$.Object, $.String]), 
      Assert_IsNull$BE
    );

    $.Method({Static:true , Public:true }, "IsNull", 
      JSIL.MethodSignature.Action($.Object), 
      Assert_IsNull$BF
    );

    $.Method({Static:true , Public:true }, "IsNullOrEmpty", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsNullOrEmpty$C0
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNullOrEmpty", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      Assert_IsNullOrEmpty$C1
    );

    $.Method({Static:true , Public:true }, "IsNullOrEmpty", 
      JSIL.MethodSignature.Action($.String), 
      Assert_IsNullOrEmpty$C2
    );

    $.Method({Static:true , Public:true }, "IsTrue", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_IsTrue$C3
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsTrue", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String]), 
      Assert_IsTrue$C4
    );

    $.Method({Static:true , Public:true }, "IsTrue", 
      JSIL.MethodSignature.Action($.Boolean), 
      Assert_IsTrue$C5
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$C6
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String
        ]), 
      Assert_Less$C7
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      Assert_Less$C8
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$C9
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String
        ]), 
      Assert_Less$CA
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$.UInt32, $.UInt32]), 
      Assert_Less$CB
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$CC
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String
        ]), 
      Assert_Less$CD
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$.Int64, $.Int64]), 
      Assert_Less$CE
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$CF
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String
        ]), 
      Assert_Less$D0
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$.UInt64, $.UInt64]), 
      Assert_Less$D1
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$D2
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String
        ]), 
      Assert_Less$D3
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal")]), 
      Assert_Less$D4
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$D5
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String
        ]), 
      Assert_Less$D6
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      Assert_Less$D7
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$D8
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String
        ]), 
      Assert_Less$D9
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      Assert_Less$DA
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Less$DB
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String
        ]), 
      Assert_Less$DC
    );

    $.Method({Static:true , Public:true }, "Less", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable")]), 
      Assert_Less$DD
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$DE
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.String
        ]), 
      Assert_LessOrEqual$DF
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      Assert_LessOrEqual$E0
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$E1
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $.String
        ]), 
      Assert_LessOrEqual$E2
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$.UInt32, $.UInt32]), 
      Assert_LessOrEqual$E3
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$E4
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.String
        ]), 
      Assert_LessOrEqual$E5
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$.Int64, $.Int64]), 
      Assert_LessOrEqual$E6
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$E7
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; })
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.UInt64, $.UInt64, 
          $.String
        ]), 
      Assert_LessOrEqual$E8
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$.UInt64, $.UInt64]), 
      Assert_LessOrEqual$E9
    )
      .Attribute($asm0A.TypeRef("System.CLSCompliantAttribute"), function () { return [false]; });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$EA
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $.String
        ]), 
      Assert_LessOrEqual$EB
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal")]), 
      Assert_LessOrEqual$EC
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$ED
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.String
        ]), 
      Assert_LessOrEqual$EE
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      Assert_LessOrEqual$EF
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$F0
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.String
        ]), 
      Assert_LessOrEqual$F1
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      Assert_LessOrEqual$F2
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_LessOrEqual$F3
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable"), 
          $.String
        ]), 
      Assert_LessOrEqual$F4
    );

    $.Method({Static:true , Public:true }, "LessOrEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IComparable"), $asm0A.TypeRef("System.IComparable")]), 
      Assert_LessOrEqual$F5
    );

    $.Method({Static:true , Public:true }, "NotNull", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_NotNull$F6
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "NotNull", 
      new JSIL.MethodSignature(null, [$.Object, $.String]), 
      Assert_NotNull$F7
    );

    $.Method({Static:true , Public:true }, "NotNull", 
      JSIL.MethodSignature.Action($.Object), 
      Assert_NotNull$F8
    );

    $.Method({Static:true , Public:true }, "Null", 
      new JSIL.MethodSignature(null, [
          $.Object, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Null$F9
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Null", 
      new JSIL.MethodSignature(null, [$.Object, $.String]), 
      Assert_Null$FA
    );

    $.Method({Static:true , Public:true }, "Null", 
      JSIL.MethodSignature.Action($.Object), 
      Assert_Null$FB
    );

    $.Method({Static:true , Public:true }, "Pass", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("System.Array", [$.Object])]), 
      Assert_Pass$FC
    )
      .Parameter(1, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Pass", 
      JSIL.MethodSignature.Action($.String), 
      Assert_Pass$FD
    );

    $.Method({Static:true , Public:true }, "Pass", 
      JSIL.MethodSignature.Void, 
      Assert_Pass$FE
    );

    $.Method({Static:true , Public:true }, "ReferenceEquals", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      Assert_ReferenceEquals$FF
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      Assert_That$100
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ]), 
      Assert_That$101
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_That$102
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_That$103
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String]), 
      Assert_That$104
    );

    $.Method({Static:true , Public:true }, "That", 
      JSIL.MethodSignature.Action($.Boolean), 
      Assert_That$105
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")], ["T"]), 
      Assert_That$b1$106
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ], ["T"]), 
      Assert_That$b1$107
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_That$b1$108
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")], ["T"]), 
      Assert_That$b1$109
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ], ["T"]), 
      Assert_That$b1$10A
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_That$b1$10B
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.TestDelegate"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      Assert_That$10C
    );

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
          $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Throws$10D
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
          $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
          $.String
        ]), 
      Assert_Throws$10E
    );

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [$asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.TestDelegate")]), 
      Assert_Throws$10F
    );

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
          $asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_Throws$110
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [
          $asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.TestDelegate"), 
          $.String
        ]), 
      Assert_Throws$111
    );

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [$asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.TestDelegate")]), 
      Assert_Throws$112
    );

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature("!!0", [
          $asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assert_Throws$b1$113
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature("!!0", [$asm0B.TypeRef("NUnit.Framework.TestDelegate"), $.String], ["T"]), 
      Assert_Throws$b1$114
    );

    $.Method({Static:true , Public:true }, "Throws", 
      new JSIL.MethodSignature("!!0", [$asm0B.TypeRef("NUnit.Framework.TestDelegate")], ["T"]), 
      Assert_Throws$b1$115
    );

    $.Method({Static:true , Public:true }, "True", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assert_True$116
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "True", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String]), 
      Assert_True$117
    );

    $.Method({Static:true , Public:true }, "True", 
      JSIL.MethodSignature.Action($.Boolean), 
      Assert_True$118
    );

    $.Field({Static:true , Public:false}, "counter", $.Int32, 0); 
    function Assert__cctor () {
      $thisType.counter = 0;
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Assert__cctor
    );

    $.Property({Static:true , Public:true }, "Counter", $.Int32);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("NUnit.Framework.Constraints");
/* class NUnit.Framework.Constraints.ConstraintFactory */ 

(function ConstraintFactory$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AssignableFromConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AssignableToConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.GreaterThanOrEqualConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.LessThanOrEqualConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Has)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionContainsConstraint)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ContainsConstraint)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubstringConstraint)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EndsWithConstraint)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionEquivalentConstraint)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0B.NUnit.Framework.Is)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinarySerializableConstraint)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyConstraint)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FalseConstraint)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NaNConstraint)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.LessThanConstraint)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NullConstraint)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOrderedConstraint)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.GreaterThanConstraint)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TrueConstraint)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.UniqueItemsConstraint)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.XmlSerializableConstraint)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.InstanceOfTypeConstraint)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.RegexConstraint)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SameAsConstraint)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SamePathConstraint)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SamePathOrUnderConstraint)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StartsWithConstraint)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubPathConstraint)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionSubsetConstraint)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExactTypeConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function ConstraintFactory__ctor () {
  };

  function ConstraintFactory_AssignableFrom (expectedType) {
    return new ($T01())(expectedType);
  };

  function ConstraintFactory_AssignableFrom$b1 (T) {
    return new ($T01())(T);
  };

  function ConstraintFactory_AssignableTo (expectedType) {
    return new ($T02())(expectedType);
  };

  function ConstraintFactory_AssignableTo$b1 (T) {
    return new ($T02())(T);
  };

  function ConstraintFactory_AtLeast (expected) {
    return new ($T04())(expected);
  };

  function ConstraintFactory_AtMost (expected) {
    return new ($T05())(expected);
  };

  function ConstraintFactory_Attribute (expectedType) {
    return $T06().Attribute(expectedType);
  };

  function ConstraintFactory_Attribute$b1 (T) {
    return this.Attribute(T);
  };

  function ConstraintFactory_Contains$00 (expected) {
    return new ($T07())(expected);
  };

  function ConstraintFactory_Contains$01 (expected) {
    return new ($T09())(expected);
  };

  function ConstraintFactory_ContainsSubstring (expected) {
    return new ($T0A())(expected);
  };

  function ConstraintFactory_DoesNotContain (expected) {
    return $S00().Construct().get_Not().ContainsSubstring(expected);
  };

  function ConstraintFactory_DoesNotEndWith (expected) {
    return $S00().Construct().get_Not().EndsWith(expected);
  };

  function ConstraintFactory_DoesNotMatch (pattern) {
    return $S01().CallVirtual("Matches", null, $S00().Construct().get_Not(), pattern);
  };

  function ConstraintFactory_DoesNotStartWith (expected) {
    return $S00().Construct().get_Not().StartsWith(expected);
  };

  function ConstraintFactory_EndsWith (expected) {
    return new ($T0C())(expected);
  };

  function ConstraintFactory_EqualTo (expected) {
    return new ($T0D())(expected);
  };

  function ConstraintFactory_EquivalentTo (expected) {
    return new ($T0F())(expected);
  };

  function ConstraintFactory_Exactly (expectedCount) {
    return $T06().Exactly(expectedCount);
  };

  function ConstraintFactory_get_All () {
    return $T11().get_All();
  };

  function ConstraintFactory_get_BinarySerializable () {
    return new ($T12())();
  };

  function ConstraintFactory_get_Count () {
    return $T06().get_Count();
  };

  function ConstraintFactory_get_Empty () {
    return new ($T13())();
  };

  function ConstraintFactory_get_False () {
    return new ($T14())();
  };

  function ConstraintFactory_get_InnerException () {
    return $T06().get_InnerException();
  };

  function ConstraintFactory_get_Length () {
    return $T06().get_Length();
  };

  function ConstraintFactory_get_Message () {
    return $T06().get_Message();
  };

  function ConstraintFactory_get_NaN () {
    return new ($T15())();
  };

  function ConstraintFactory_get_Negative () {
    return new ($T16())(0);
  };

  function ConstraintFactory_get_No () {
    return $T06().get_No();
  };

  function ConstraintFactory_get_None () {
    return $T06().get_None();
  };

  function ConstraintFactory_get_Not () {
    return $T11().get_Not();
  };

  function ConstraintFactory_get_Null () {
    return new ($T17())();
  };

  function ConstraintFactory_get_Ordered () {
    return new ($T18())();
  };

  function ConstraintFactory_get_Positive () {
    return new ($T19())(0);
  };

  function ConstraintFactory_get_Some () {
    return $T06().get_Some();
  };

  function ConstraintFactory_get_True () {
    return new ($T1A())();
  };

  function ConstraintFactory_get_Unique () {
    return new ($T1B())();
  };

  function ConstraintFactory_get_XmlSerializable () {
    return new ($T1C())();
  };

  function ConstraintFactory_GreaterThan (expected) {
    return new ($T19())(expected);
  };

  function ConstraintFactory_GreaterThanOrEqualTo (expected) {
    return new ($T04())(expected);
  };

  function ConstraintFactory_InRange$b1 (T, from, to) {
    return new ($asm0B.NUnit.Framework.Constraints.RangeConstraint$b1.Of(T)) (JSIL.CloneParameter(T, from), JSIL.CloneParameter(T, to));
  };

  function ConstraintFactory_InstanceOf (expectedType) {
    return new ($T1D())(expectedType);
  };

  function ConstraintFactory_InstanceOf$b1 (T) {
    return new ($T1D())(T);
  };

  function ConstraintFactory_InstanceOfType (expectedType) {
    return new ($T1D())(expectedType);
  };

  function ConstraintFactory_InstanceOfType$b1 (T) {
    return new ($T1D())(T);
  };

  function ConstraintFactory_LessThan (expected) {
    return new ($T16())(expected);
  };

  function ConstraintFactory_LessThanOrEqualTo (expected) {
    return new ($T05())(expected);
  };

  function ConstraintFactory_Matches (pattern) {
    return new ($T1E())(pattern);
  };

  function ConstraintFactory_Member (expected) {
    return new ($T07())(expected);
  };

  function ConstraintFactory_Property (name) {
    return $T06().Property(name);
  };

  function ConstraintFactory_SameAs (expected) {
    return new ($T1F())(expected);
  };

  function ConstraintFactory_SamePath (expected) {
    return new ($T20())(expected);
  };

  function ConstraintFactory_SamePathOrUnder (expected) {
    return new ($T21())(expected);
  };

  function ConstraintFactory_StartsWith (expected) {
    return new ($T22())(expected);
  };

  function ConstraintFactory_StringContaining (expected) {
    return new ($T0A())(expected);
  };

  function ConstraintFactory_StringEnding (expected) {
    return new ($T0C())(expected);
  };

  function ConstraintFactory_StringMatching (pattern) {
    return new ($T1E())(pattern);
  };

  function ConstraintFactory_StringStarting (expected) {
    return new ($T22())(expected);
  };

  function ConstraintFactory_SubPath (expected) {
    return new ($T23())(expected);
  };

  function ConstraintFactory_SubsetOf (expected) {
    return new ($T24())(expected);
  };

  function ConstraintFactory_TypeOf (expectedType) {
    return new ($T25())(expectedType);
  };

  function ConstraintFactory_TypeOf$b1 (T) {
    return new ($T25())(T);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ConstraintFactory", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConstraintFactory__ctor
    );

    $.Method({Static:false, Public:true }, "AssignableFrom", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableFromConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintFactory_AssignableFrom
    );

    $.Method({Static:false, Public:true }, "AssignableFrom", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableFromConstraint"), null, ["T"]), 
      ConstraintFactory_AssignableFrom$b1
    );

    $.Method({Static:false, Public:true }, "AssignableTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableToConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintFactory_AssignableTo
    );

    $.Method({Static:false, Public:true }, "AssignableTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableToConstraint"), null, ["T"]), 
      ConstraintFactory_AssignableTo$b1
    );

    $.Method({Static:false, Public:true }, "AtLeast", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanOrEqualConstraint"), [$.Object]), 
      ConstraintFactory_AtLeast
    );

    $.Method({Static:false, Public:true }, "AtMost", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanOrEqualConstraint"), [$.Object]), 
      ConstraintFactory_AtMost
    );

    $.Method({Static:false, Public:true }, "Attribute", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintFactory_Attribute
    );

    $.Method({Static:false, Public:true }, "Attribute", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), null, ["T"]), 
      ConstraintFactory_Attribute$b1
    );

    $.Method({Static:false, Public:true }, "Contains", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionContainsConstraint"), [$.Object]), 
      ConstraintFactory_Contains$00
    );

    $.Method({Static:false, Public:true }, "Contains", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ContainsConstraint"), [$.String]), 
      ConstraintFactory_Contains$01
    );

    $.Method({Static:false, Public:true }, "ContainsSubstring", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      ConstraintFactory_ContainsSubstring
    );

    $.Method({Static:false, Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      ConstraintFactory_DoesNotContain
    );

    $.Method({Static:false, Public:true }, "DoesNotEndWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      ConstraintFactory_DoesNotEndWith
    );

    $.Method({Static:false, Public:true }, "DoesNotMatch", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      ConstraintFactory_DoesNotMatch
    );

    $.Method({Static:false, Public:true }, "DoesNotStartWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      ConstraintFactory_DoesNotStartWith
    );

    $.Method({Static:false, Public:true }, "EndsWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      ConstraintFactory_EndsWith
    );

    $.Method({Static:false, Public:true }, "EqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualConstraint"), [$.Object]), 
      ConstraintFactory_EqualTo
    );

    $.Method({Static:false, Public:true }, "EquivalentTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionEquivalentConstraint"), [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      ConstraintFactory_EquivalentTo
    );

    $.Method({Static:true , Public:true }, "Exactly", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), [$.Int32]), 
      ConstraintFactory_Exactly
    );

    $.Method({Static:false, Public:true }, "get_All", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      ConstraintFactory_get_All
    );

    $.Method({Static:false, Public:true }, "get_BinarySerializable", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.BinarySerializableConstraint")), 
      ConstraintFactory_get_BinarySerializable
    );

    $.Method({Static:false, Public:true }, "get_Count", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintFactory_get_Count
    );

    $.Method({Static:false, Public:true }, "get_Empty", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.EmptyConstraint")), 
      ConstraintFactory_get_Empty
    );

    $.Method({Static:false, Public:true }, "get_False", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.FalseConstraint")), 
      ConstraintFactory_get_False
    );

    $.Method({Static:false, Public:true }, "get_InnerException", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintFactory_get_InnerException
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintFactory_get_Length
    );

    $.Method({Static:false, Public:true }, "get_Message", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintFactory_get_Message
    );

    $.Method({Static:false, Public:true }, "get_NaN", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.NaNConstraint")), 
      ConstraintFactory_get_NaN
    );

    $.Method({Static:false, Public:true }, "get_Negative", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint")), 
      ConstraintFactory_get_Negative
    );

    $.Method({Static:false, Public:true }, "get_No", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      ConstraintFactory_get_No
    );

    $.Method({Static:false, Public:true }, "get_None", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      ConstraintFactory_get_None
    );

    $.Method({Static:false, Public:true }, "get_Not", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      ConstraintFactory_get_Not
    );

    $.Method({Static:false, Public:true }, "get_Null", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.NullConstraint")), 
      ConstraintFactory_get_Null
    );

    $.Method({Static:false, Public:true }, "get_Ordered", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOrderedConstraint")), 
      ConstraintFactory_get_Ordered
    );

    $.Method({Static:false, Public:true }, "get_Positive", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint")), 
      ConstraintFactory_get_Positive
    );

    $.Method({Static:false, Public:true }, "get_Some", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      ConstraintFactory_get_Some
    );

    $.Method({Static:false, Public:true }, "get_True", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.TrueConstraint")), 
      ConstraintFactory_get_True
    );

    $.Method({Static:false, Public:true }, "get_Unique", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.UniqueItemsConstraint")), 
      ConstraintFactory_get_Unique
    );

    $.Method({Static:false, Public:true }, "get_XmlSerializable", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.XmlSerializableConstraint")), 
      ConstraintFactory_get_XmlSerializable
    );

    $.Method({Static:false, Public:true }, "GreaterThan", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint"), [$.Object]), 
      ConstraintFactory_GreaterThan
    );

    $.Method({Static:false, Public:true }, "GreaterThanOrEqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanOrEqualConstraint"), [$.Object]), 
      ConstraintFactory_GreaterThanOrEqualTo
    );

    $.Method({Static:false, Public:true }, "InRange", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RangeConstraint`1", ["!!0"]), ["!!0", "!!0"], ["T"]), 
      ConstraintFactory_InRange$b1
    );

    $.Method({Static:false, Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintFactory_InstanceOf
    );

    $.Method({Static:false, Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), null, ["T"]), 
      ConstraintFactory_InstanceOf$b1
    );

    $.Method({Static:false, Public:true }, "InstanceOfType", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintFactory_InstanceOfType
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use InstanceOf(expectedType)"]; });

    $.Method({Static:false, Public:true }, "InstanceOfType", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), null, ["T"]), 
      ConstraintFactory_InstanceOfType$b1
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use InstanceOf<T>()"]; });

    $.Method({Static:false, Public:true }, "LessThan", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint"), [$.Object]), 
      ConstraintFactory_LessThan
    );

    $.Method({Static:false, Public:true }, "LessThanOrEqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanOrEqualConstraint"), [$.Object]), 
      ConstraintFactory_LessThanOrEqualTo
    );

    $.Method({Static:false, Public:true }, "Matches", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      ConstraintFactory_Matches
    );

    $.Method({Static:false, Public:true }, "Member", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionContainsConstraint"), [$.Object]), 
      ConstraintFactory_Member
    );

    $.Method({Static:false, Public:true }, "Property", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$.String]), 
      ConstraintFactory_Property
    );

    $.Method({Static:false, Public:true }, "SameAs", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SameAsConstraint"), [$.Object]), 
      ConstraintFactory_SameAs
    );

    $.Method({Static:false, Public:true }, "SamePath", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SamePathConstraint"), [$.String]), 
      ConstraintFactory_SamePath
    );

    $.Method({Static:false, Public:true }, "SamePathOrUnder", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SamePathOrUnderConstraint"), [$.String]), 
      ConstraintFactory_SamePathOrUnder
    );

    $.Method({Static:false, Public:true }, "StartsWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      ConstraintFactory_StartsWith
    );

    $.Method({Static:false, Public:true }, "StringContaining", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      ConstraintFactory_StringContaining
    );

    $.Method({Static:false, Public:true }, "StringEnding", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      ConstraintFactory_StringEnding
    );

    $.Method({Static:false, Public:true }, "StringMatching", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      ConstraintFactory_StringMatching
    );

    $.Method({Static:false, Public:true }, "StringStarting", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      ConstraintFactory_StringStarting
    );

    $.Method({Static:false, Public:true }, "SubPath", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubPathConstraint"), [$.String]), 
      ConstraintFactory_SubPath
    );

    $.Method({Static:false, Public:true }, "SubsetOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionSubsetConstraint"), [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      ConstraintFactory_SubsetOf
    );

    $.Method({Static:false, Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintFactory_TypeOf
    );

    $.Method({Static:false, Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), null, ["T"]), 
      ConstraintFactory_TypeOf$b1
    );

    $.Property({Static:false, Public:true }, "Not", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "No", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "All", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "Some", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "None", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "Length", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "Count", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "Message", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "InnerException", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "Null", $asm0B.TypeRef("NUnit.Framework.Constraints.NullConstraint"));

    $.Property({Static:false, Public:true }, "True", $asm0B.TypeRef("NUnit.Framework.Constraints.TrueConstraint"));

    $.Property({Static:false, Public:true }, "False", $asm0B.TypeRef("NUnit.Framework.Constraints.FalseConstraint"));

    $.Property({Static:false, Public:true }, "Positive", $asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint"));

    $.Property({Static:false, Public:true }, "Negative", $asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint"));

    $.Property({Static:false, Public:true }, "NaN", $asm0B.TypeRef("NUnit.Framework.Constraints.NaNConstraint"));

    $.Property({Static:false, Public:true }, "Empty", $asm0B.TypeRef("NUnit.Framework.Constraints.EmptyConstraint"));

    $.Property({Static:false, Public:true }, "Unique", $asm0B.TypeRef("NUnit.Framework.Constraints.UniqueItemsConstraint"));

    $.Property({Static:false, Public:true }, "BinarySerializable", $asm0B.TypeRef("NUnit.Framework.Constraints.BinarySerializableConstraint"));

    $.Property({Static:false, Public:true }, "XmlSerializable", $asm0B.TypeRef("NUnit.Framework.Constraints.XmlSerializableConstraint"));

    $.Property({Static:false, Public:true }, "Ordered", $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOrderedConstraint"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AssertionHelper */ 

(function AssertionHelper$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintFactory)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Assert)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Is)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.TestDelegate)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.ListMapper)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ], ["T"]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ], ["T"]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Object"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };

  function AssertionHelper__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function AssertionHelper_Expect$00 (actual, expression) {
    $T03().That(actual, expression, null, null);
  };

  function AssertionHelper_Expect$01 (actual, expression, message) {
    $T03().That(actual, expression, message, null);
  };

  function AssertionHelper_Expect$02 (actual, expression, message, args) {
    $T03().That(actual, expression, message, args);
  };

  function AssertionHelper_Expect$03 (condition, message, args) {
    $T03().That(condition, $T07().get_True(), message, args);
  };

  function AssertionHelper_Expect$04 (condition, message) {
    $T03().That(condition, $T07().get_True(), message, null);
  };

  function AssertionHelper_Expect$05 (condition) {
    $T03().That(condition, $T07().get_True(), null, null);
  };

  function AssertionHelper_Expect$b1$06 (T, del, expr) {
    $S00().CallStatic($T03(), "That$b1", [T], del, $IM00().Call(expr, null), null, null);
  };

  function AssertionHelper_Expect$b1$07 (T, del, expr, message) {
    $S00().CallStatic($T03(), "That$b1", [T], del, $IM00().Call(expr, null), message, null);
  };

  function AssertionHelper_Expect$b1$08 (T, del, expr, message, args) {
    $S00().CallStatic($T03(), "That$b1", [T], del, expr, message, args);
  };

  function AssertionHelper_Expect$b1$09 (T, /* ref */ actual, expression) {
    $S01().CallStatic($T03(), "That$b1", [T], /* ref */ actual, expression, null, null);
  };

  function AssertionHelper_Expect$b1$0A (T, /* ref */ actual, expression, message) {
    $S01().CallStatic($T03(), "That$b1", [T], /* ref */ actual, expression, message, null);
  };

  function AssertionHelper_Expect$b1$0B (T, /* ref */ actual, expression, message, args) {
    $S01().CallStatic($T03(), "That$b1", [T], /* ref */ actual, expression, message, args);
  };

  function AssertionHelper_Expect$0C (code, constraint) {
    $S02().CallStatic($T03(), "That", null, code, constraint);
  };

  function AssertionHelper_Map (original) {
    return new ($T0B())(original);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintFactory"), 
      Name: "NUnit.Framework.AssertionHelper", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AssertionHelper__ctor
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [$.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      AssertionHelper_Expect$00
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ]), 
      AssertionHelper_Expect$01
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      AssertionHelper_Expect$02
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      AssertionHelper_Expect$03
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String]), 
      AssertionHelper_Expect$04
    );

    $.Method({Static:false, Public:true }, "Expect", 
      JSIL.MethodSignature.Action($.Boolean), 
      AssertionHelper_Expect$05
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")], ["T"]), 
      AssertionHelper_Expect$b1$06
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ], ["T"]), 
      AssertionHelper_Expect$b1$07
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      AssertionHelper_Expect$b1$08
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")], ["T"]), 
      AssertionHelper_Expect$b1$09
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ], ["T"]), 
      AssertionHelper_Expect$b1$0A
    );

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      AssertionHelper_Expect$b1$0B
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true }, "Expect", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.TestDelegate"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      AssertionHelper_Expect$0C
    );

    $.Method({Static:false, Public:true }, "Map", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.ListMapper"), [$asm0A.TypeRef("System.Collections.ICollection")]), 
      AssertionHelper_Map
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Assume */ 

(function Assume$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.AssertionException)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.TextMessageWriter)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.InconclusiveException)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Is)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.TestDelegate)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.AssertionException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.TextMessageWriter"), [$asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.InconclusiveException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ], ["T"]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"])], ["T"]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ], ["T"]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$jsilcore.TypeRef("JSIL.Reference", ["!!0"])], ["T"]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Object"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };

  function Assume__ctor () {
  };

  function Assume_ReferenceEquals$00 (a, b) {
    throw $S00().Construct("Assert.ReferenceEquals should not be used for Assertions");
  };

  function Assume_That$01 (actual, expression) {
    $thisType.That(actual, expression, null, null);
  };

  function Assume_That$02 (actual, expression, message) {
    $thisType.That(actual, expression, message, null);
  };

  function Assume_That$03 (actual, expression, message, args) {
    var constraint = $IM00().Call(expression, null);
    if (!$S01().CallVirtual("Matches", null, constraint, actual)) {
      var messageWriter = $S02().Construct(message, args);
      constraint.WriteMessageTo(messageWriter);
      throw $S03().Construct(messageWriter.toString());
    }
  };

  function Assume_That$04 (condition, message, args) {
    $thisType.That(condition, $T0A().get_True(), message, args);
  };

  function Assume_That$05 (condition, message) {
    $thisType.That(condition, $T0A().get_True(), message, null);
  };

  function Assume_That$06 (condition) {
    $thisType.That(condition, $T0A().get_True(), null, null);
  };

  function Assume_That$b1$07 (T, del, expr) {
    $S04().CallStatic($thisType, "That$b1", [T], del, $IM00().Call(expr, null), null, null);
  };

  function Assume_That$b1$08 (T, del, expr, message) {
    $S04().CallStatic($thisType, "That$b1", [T], del, $IM00().Call(expr, null), message, null);
  };

  function Assume_That$b1$09 (T, del, expr, message, args) {
    var constraint = $IM00().Call(expr, null);
    if (!$S05().CallVirtual("Matches$b1", [T], constraint, del)) {
      var messageWriter = $S02().Construct(message, args);
      constraint.WriteMessageTo(messageWriter);
      throw $S03().Construct(messageWriter.toString());
    }
  };

  function Assume_That$b1$0A (T, /* ref */ actual, expression) {
    $S06().CallStatic($thisType, "That$b1", [T], /* ref */ actual, $IM00().Call(expression, null), null, null);
  };

  function Assume_That$b1$0B (T, /* ref */ actual, expression, message) {
    $S06().CallStatic($thisType, "That$b1", [T], /* ref */ actual, $IM00().Call(expression, null), message, null);
  };

  function Assume_That$b1$0C (T, /* ref */ actual, expression, message, args) {
    var constraint = $IM00().Call(expression, null);
    if (!$S07().CallVirtual("Matches$b1", [T], constraint, /* ref */ actual)) {
      var messageWriter = $S02().Construct(message, args);
      constraint.WriteMessageTo(messageWriter);
      throw $S03().Construct(messageWriter.toString());
    }
  };

  function Assume_That$0D (code, constraint) {
    $S08().CallStatic($thisType, "That", null, code, constraint);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Assume", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Assume__ctor
    );

    $.Method({Static:true , Public:true }, "ReferenceEquals", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      Assume_ReferenceEquals$00
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      Assume_That$01
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ]), 
      Assume_That$02
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assume_That$03
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      Assume_That$04
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String]), 
      Assume_That$05
    );

    $.Method({Static:true , Public:true }, "That", 
      JSIL.MethodSignature.Action($.Boolean), 
      Assume_That$06
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")], ["T"]), 
      Assume_That$b1$07
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ], ["T"]), 
      Assume_That$b1$08
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assume_That$b1$09
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")], ["T"]), 
      Assume_That$b1$0A
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String
        ], ["T"]), 
      Assume_That$b1$0B
    );

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", ["!!0"]), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ], ["T"]), 
      Assume_That$b1$0C
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "That", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.TestDelegate"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      Assume_That$0D
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AsyncInvocationRegion */ 

(function AsyncInvocationRegion$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Reflection.BindingFlags)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Delegate)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Reflection.MethodInfo)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Void)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion_AsyncVoidInvocationRegion)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion_AsyncTaskInvocationRegion)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.System.Action$b1.Of($asm0A.System.Exception))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Reflection.MethodInfo"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Reflection.BindingFlags")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.AsyncInvocationRegion"), [$asm0A.TypeRef("System.Reflection.MethodInfo")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Reflection.MethodInfo")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.InvalidOperationException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function AsyncInvocationRegion__ctor () {
  };

  function AsyncInvocationRegion_Create$00 (delegate) {
    return $S01().CallStatic($thisType, "Create", null, delegate.get_Method());
  };

  function AsyncInvocationRegion_Create$01 (method) {
    if (!$S02().CallStatic($thisType, "IsAsyncOperation", null, method)) {
      throw $S03().Construct("Either asynchronous support is not available or an attempt \r\nat wrapping a non-async method invocation in an async region was done");
    }
    if (method.get_ReturnType() === $T06().__Type__) {
      var result = new ($T07())();
    } else {
      result = new ($T08())();
    }
    return result;
  };

  function AsyncInvocationRegion_Dispose () {
  };

  function AsyncInvocationRegion_IsAsyncOperation$02 (method) {
    var customAttributes = method.GetCustomAttributes(false);

    for (var i = 0; i < (customAttributes.length | 0); i = ((i + 1) | 0)) {
      var obj = customAttributes[i];
      if ("System.Runtime.CompilerServices.AsyncStateMachineAttribute" == (JSIL.GetType(obj)).get_FullName()) {
        var result = true;
        return result;
      }
    }
    result = false;
    return result;
  };

  function AsyncInvocationRegion_IsAsyncOperation$03 (delegate) {
    return $S02().CallStatic($thisType, "IsAsyncOperation", null, delegate.get_Method());
  };

  function AsyncInvocationRegion_PreserveStackTrace (ex) {
    if ($thisType.PreserveStackTraceMethod !== null) {
      if ($thisType.preserveStackTraceDelegate === null) {
        $thisType.preserveStackTraceDelegate = $T03().CreateDelegate($T0F().__Type__, $thisType.PreserveStackTraceMethod);
      }
      $thisType.preserveStackTraceDelegate(ex);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.AsyncInvocationRegion", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      AsyncInvocationRegion__ctor
    );

    $.Method({Static:true , Public:true }, "Create", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Delegate")]), 
      AsyncInvocationRegion_Create$00
    );

    $.Method({Static:true , Public:true }, "Create", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Reflection.MethodInfo")]), 
      AsyncInvocationRegion_Create$01
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void, 
      AsyncInvocationRegion_Dispose
    );

    $.Method({Static:true , Public:true }, "IsAsyncOperation", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Reflection.MethodInfo")]), 
      AsyncInvocationRegion_IsAsyncOperation$02
    );

    $.Method({Static:true , Public:true }, "IsAsyncOperation", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Delegate")]), 
      AsyncInvocationRegion_IsAsyncOperation$03
    );

    $.Method({Static:true , Public:false}, "PreserveStackTrace", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Exception")), 
      AsyncInvocationRegion_PreserveStackTrace
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "PreserveStackTraceMethod", $asm0A.TypeRef("System.Reflection.MethodInfo")); 
    $.Field({Static:true , Public:false}, "preserveStackTraceDelegate", $asm0A.TypeRef("System.Action`1", [$asm0A.TypeRef("System.Exception")])); 
    function AsyncInvocationRegion__cctor () {
      $thisType.PreserveStackTraceMethod = $S00().CallVirtual("GetMethod", null, $T01().__Type__, "InternalPreserveStackTrace", $T02().$Flags("Instance", "NonPublic"));
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      AsyncInvocationRegion__cctor
    );

    $.ImplementInterfaces(
      /* 0 */ $asm0A.TypeRef("System.IDisposable")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AsyncInvocationRegion+AsyncVoidInvocationRegion */ 

(function AsyncVoidInvocationRegion$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Threading.SynchronizationContext)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncSynchronizationContext)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Exception)) ();
  };

  function AsyncVoidInvocationRegion__ctor () {
    $T00().prototype._ctor.call(this);
    this._previousContext = $T01().get_Current();
    this._currentContext = new ($T02())();
    $T01().SetSynchronizationContext(this._currentContext);
  };

  function AsyncVoidInvocationRegion_Dispose () {
    $T01().SetSynchronizationContext(this._previousContext);
  };

  function AsyncVoidInvocationRegion_WaitForPendingOperationsToComplete (invocationResult, $exception) {
    try {
      (this._currentContext).WaitForPendingOperationsToComplete();
    } catch ($exception) {
      $T00().PreserveStackTrace($exception);
      throw $exception;
    }
    return invocationResult;
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.AsyncInvocationRegion"), 
      Name: "NUnit.Framework.AsyncInvocationRegion+AsyncVoidInvocationRegion", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AsyncVoidInvocationRegion__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void, 
      AsyncVoidInvocationRegion_Dispose
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WaitForPendingOperationsToComplete", 
      new JSIL.MethodSignature($.Object, [$.Object]), 
      AsyncVoidInvocationRegion_WaitForPendingOperationsToComplete
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_previousContext", $asm0A.TypeRef("System.Threading.SynchronizationContext")); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "_currentContext", $asm0B.TypeRef("NUnit.Framework.AsyncSynchronizationContext")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AsyncInvocationRegion+AsyncTaskInvocationRegion */ 

(function AsyncTaskInvocationRegion$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.Generic.IList$b1.Of($asm0A.System.Exception))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Reflection.PropertyInfo)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Reflection.MethodBase)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Reflection.TargetInvocationException)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Reflection.BindingFlags)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Reflection.MethodInfo"), [$asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Type")])]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Reflection.PropertyInfo"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Reflection.BindingFlags")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.Generic.IList$b1.Of($asm0A.System.Exception).get_Item)) ();
  };

  function AsyncTaskInvocationRegion__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function AsyncTaskInvocationRegion_GetAllExceptions (exception) {
    if ("System.AggregateException" == (exception.GetType()).get_FullName()) {
      var result = $T04().$Cast(((exception.GetType()).GetProperty("InnerExceptions")).GetValue(exception, null));
    } else {
      result = $T04().$Cast(JSIL.Array.New($T01(), [exception]));
    }
    return result;
  };

  function AsyncTaskInvocationRegion_WaitForPendingOperationsToComplete (invocationResult, $exception) {
    try {
      ($S00().CallVirtual("GetMethod", null, JSIL.GetType(invocationResult), "Wait", JSIL.Array.New($T03(), 0))).Invoke(invocationResult, null);
    } catch ($exception) {
      if ($T08().$Is($exception)) {
        var allExceptions = $thisType.GetAllExceptions(($exception).get_InnerException());
        $T00().PreserveStackTrace($IM00().Call(allExceptions, null, 0));
        throw $IM00().Call(allExceptions, null, 0);
      } else {
        throw $exception;
      }
    }
    var property = $S01().CallVirtual("GetProperty", null, JSIL.GetType(invocationResult), "Result", $T09().$Flags("GetProperty", "Instance", "Public"));
    return (
      (property !== null)
         ? property.GetValue(invocationResult, null)
         : invocationResult)
    ;
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.AsyncInvocationRegion"), 
      Name: "NUnit.Framework.AsyncInvocationRegion+AsyncTaskInvocationRegion", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AsyncTaskInvocationRegion__ctor
    );

    $.Method({Static:true , Public:false}, "GetAllExceptions", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Collections.Generic.IList`1", [$asm0A.TypeRef("System.Exception")]), [$asm0A.TypeRef("System.Exception")]), 
      AsyncTaskInvocationRegion_GetAllExceptions
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WaitForPendingOperationsToComplete", 
      new JSIL.MethodSignature($.Object, [$.Object]), 
      AsyncTaskInvocationRegion_WaitForPendingOperationsToComplete
    );

    $.Constant({Static:true , Public:false}, "TaskWaitMethod", "Wait"); 
    $.Constant({Static:true , Public:false}, "TaskResultProperty", "Result"); 
    $.Constant({Static:true , Public:false}, "SystemAggregateException", "System.AggregateException"); 
    $.Constant({Static:true , Public:false}, "InnerExceptionsProperty", "InnerExceptions"); 
    $.Constant({Static:true , Public:false}, "TaskResultPropertyBindingFlags", 4116); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AsyncSynchronizationContext */ 

(function AsyncSynchronizationContext$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncSynchronizationContext_AsyncOperationQueue)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Threading.SynchronizationContext)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Threading.Interlocked)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Threading.SendOrPostCallback)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncSynchronizationContext_AsyncOperation)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [$jsilcore.TypeRef("JSIL.Reference", [$asm0A.TypeRef("System.Int32")])]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [$jsilcore.TypeRef("JSIL.Reference", [$asm0A.TypeRef("System.Int32")])]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.InvalidOperationException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function AsyncSynchronizationContext__ctor () {
    this._operations = new ($T00())();
    $T01().prototype._ctor.call(this);
  };

  function AsyncSynchronizationContext_OperationCompleted () {
    if (($S00().CallStatic($T02(), "Decrement", null, /* ref */ new JSIL.MemberReference(this, "_operationCount")) | 0) === 0) {
      (this._operations).MarkAsComplete();
    }
    $T01().prototype.OperationCompleted.call(this);
  };

  function AsyncSynchronizationContext_OperationStarted () {
    $S01().CallStatic($T02(), "Increment", null, /* ref */ new JSIL.MemberReference(this, "_operationCount"));
    $T01().prototype.OperationStarted.call(this);
  };

  function AsyncSynchronizationContext_Post (d, state) {
    (this._operations).Enqueue(new ($T05())(d, state));
  };

  function AsyncSynchronizationContext_Send (d, state) {
    throw $S02().Construct("Sending to this synchronization context is not supported");
  };

  function AsyncSynchronizationContext_WaitForPendingOperationsToComplete () {
    (this._operations).InvokeAll();
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Threading.SynchronizationContext"), 
      Name: "NUnit.Framework.AsyncSynchronizationContext", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AsyncSynchronizationContext__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "OperationCompleted", 
      JSIL.MethodSignature.Void, 
      AsyncSynchronizationContext_OperationCompleted
    );

    $.Method({Static:false, Public:true , Virtual:true }, "OperationStarted", 
      JSIL.MethodSignature.Void, 
      AsyncSynchronizationContext_OperationStarted
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Post", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Threading.SendOrPostCallback"), $.Object]), 
      AsyncSynchronizationContext_Post
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Send", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Threading.SendOrPostCallback"), $.Object]), 
      AsyncSynchronizationContext_Send
    );

    $.Method({Static:false, Public:true }, "WaitForPendingOperationsToComplete", 
      JSIL.MethodSignature.Void, 
      AsyncSynchronizationContext_WaitForPendingOperationsToComplete
    );

    $.Field({Static:false, Public:false}, "_operationCount", $.Int32); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "_operations", $asm0B.TypeRef("NUnit.Framework.AsyncSynchronizationContext+AsyncOperationQueue")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AsyncSynchronizationContext+AsyncOperationQueue */ 

(function AsyncOperationQueue$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.Queue)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Threading.AutoResetEvent)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncSynchronizationContext_AsyncOperation)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Threading.EventWaitHandle)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Threading.WaitHandle)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.Queue"), null))) ();
  };

  function AsyncOperationQueue__ctor () {
    this._run = true;
    this._operations = $T00().Synchronized($S00().Construct());
    this._operationsAvailable = new ($T01())(false);
  };

  function AsyncOperationQueue_Enqueue (asyncOperation) {
    (this._operations).Enqueue(asyncOperation);
    (this._operationsAvailable).Set();
  };

  function AsyncOperationQueue_InvokeAll () {

    while (this._run) {
      this.InvokePendingOperations();
      (this._operationsAvailable).WaitOne();
    }
    this.InvokePendingOperations();
  };

  function AsyncOperationQueue_InvokePendingOperations () {

    while (((this._operations).get_Count() | 0) > 0) {
      var asyncOperation = $T02().$Cast((this._operations).Dequeue());
      asyncOperation.Invoke();
    }
  };

  function AsyncOperationQueue_MarkAsComplete () {
    this._run = false;
    (this._operationsAvailable).Set();
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.AsyncSynchronizationContext+AsyncOperationQueue", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AsyncOperationQueue__ctor
    );

    $.Method({Static:false, Public:true }, "Enqueue", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.AsyncSynchronizationContext+AsyncOperation")), 
      AsyncOperationQueue_Enqueue
    );

    $.Method({Static:false, Public:true }, "InvokeAll", 
      JSIL.MethodSignature.Void, 
      AsyncOperationQueue_InvokeAll
    );

    $.Method({Static:false, Public:false}, "InvokePendingOperations", 
      JSIL.MethodSignature.Void, 
      AsyncOperationQueue_InvokePendingOperations
    );

    $.Method({Static:false, Public:true }, "MarkAsComplete", 
      JSIL.MethodSignature.Void, 
      AsyncOperationQueue_MarkAsComplete
    );

    $.Field({Static:false, Public:false}, "_run", $.Boolean); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "_operations", $asm0A.TypeRef("System.Collections.Queue")); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "_operationsAvailable", $asm0A.TypeRef("System.Threading.AutoResetEvent")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AsyncSynchronizationContext+AsyncOperation */ 

(function AsyncOperation$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Threading.SendOrPostCallback)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };

  function AsyncOperation__ctor (action, state) {
    this._action = action;
    this._state = state;
  };

  function AsyncOperation_Invoke () {
    this._action(this._state);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.AsyncSynchronizationContext+AsyncOperation", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Threading.SendOrPostCallback"), $.Object]), 
      AsyncOperation__ctor
    );

    $.Method({Static:false, Public:true }, "Invoke", 
      JSIL.MethodSignature.Void, 
      AsyncOperation_Invoke
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_action", $asm0A.TypeRef("System.Threading.SendOrPostCallback")); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "_state", $.Object); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.CollectionAssert */ 

(function CollectionAssert$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Assert)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AllItemsConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.InstanceOfTypeConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.UniqueItemsConstraint)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionEquivalentConstraint)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionContainsConstraint)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyConstraint)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionSubsetConstraint)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOrderedConstraint)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0B.NUnit.Framework.AssertionException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Object"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.Object"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), 
        $asm0A.TypeRef("System.String")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualConstraint"), [$asm0A.TypeRef("System.Collections.IComparer")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.String"), 
        $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.AssertionException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function CollectionAssert__ctor () {
  };

  function CollectionAssert_AllItemsAreInstancesOfType$00 (collection, expectedType) {
    $thisType.AllItemsAreInstancesOfType(collection, expectedType, $T02().Empty, null);
  };

  function CollectionAssert_AllItemsAreInstancesOfType$01 (collection, expectedType, message) {
    $thisType.AllItemsAreInstancesOfType(collection, expectedType, message, null);
  };

  function CollectionAssert_AllItemsAreInstancesOfType$02 (collection, expectedType, message, args) {
    $T04().That(collection, new ($T05())(new ($T06())(expectedType)), message, args);
  };

  function CollectionAssert_AllItemsAreNotNull$03 (collection) {
    $thisType.AllItemsAreNotNull(collection, $T02().Empty, null);
  };

  function CollectionAssert_AllItemsAreNotNull$04 (collection, message) {
    $thisType.AllItemsAreNotNull(collection, message, null);
  };

  function CollectionAssert_AllItemsAreNotNull$05 (collection, message, args) {
    $T04().That(collection, new ($T05())(new ($T07())(new ($T08())(null))), message, args);
  };

  function CollectionAssert_AllItemsAreUnique$06 (collection) {
    $thisType.AllItemsAreUnique(collection, $T02().Empty, null);
  };

  function CollectionAssert_AllItemsAreUnique$07 (collection, message) {
    $thisType.AllItemsAreUnique(collection, message, null);
  };

  function CollectionAssert_AllItemsAreUnique$08 (collection, message, args) {
    $T04().That(collection, new ($T09())(), message, args);
  };

  function CollectionAssert_AreEqual$09 (expected, actual) {
    $S00().CallStatic($T04(), "That", null, actual, new ($T08())(expected));
  };

  function CollectionAssert_AreEqual$0A (expected, actual, comparer) {
    $thisType.AreEqual(
      expected, 
      actual, 
      comparer, 
      $T02().Empty, 
      null
    );
  };

  function CollectionAssert_AreEqual$0B (expected, actual, message) {
    $S01().CallStatic($T04(), "That", null, actual, new ($T08())(expected), message);
  };

  function CollectionAssert_AreEqual$0C (expected, actual, comparer, message) {
    $thisType.AreEqual(
      expected, 
      actual, 
      comparer, 
      message, 
      null
    );
  };

  function CollectionAssert_AreEqual$0D (expected, actual, message, args) {
    $T04().That(actual, new ($T08())(expected), message, args);
  };

  function CollectionAssert_AreEqual$0E (expected, actual, comparer, message, args) {
    $T04().That(actual, $S02().CallVirtual("Using", null, (new ($T08())(expected)), comparer), message, args);
  };

  function CollectionAssert_AreEquivalent$0F (expected, actual) {
    $thisType.AreEquivalent(expected, actual, $T02().Empty, null);
  };

  function CollectionAssert_AreEquivalent$10 (expected, actual, message) {
    $thisType.AreEquivalent(expected, actual, message, null);
  };

  function CollectionAssert_AreEquivalent$11 (expected, actual, message, args) {
    $T04().That(actual, new ($T0B())(expected), message, args);
  };

  function CollectionAssert_AreNotEqual$12 (expected, actual) {
    $S00().CallStatic($T04(), "That", null, actual, new ($T07())(new ($T08())(expected)));
  };

  function CollectionAssert_AreNotEqual$13 (expected, actual, comparer) {
    $thisType.AreNotEqual(
      expected, 
      actual, 
      comparer, 
      $T02().Empty, 
      null
    );
  };

  function CollectionAssert_AreNotEqual$14 (expected, actual, message) {
    $S01().CallStatic($T04(), "That", null, actual, new ($T07())(new ($T08())(expected)), message);
  };

  function CollectionAssert_AreNotEqual$15 (expected, actual, comparer, message) {
    $thisType.AreNotEqual(
      expected, 
      actual, 
      comparer, 
      message, 
      null
    );
  };

  function CollectionAssert_AreNotEqual$16 (expected, actual, message, args) {
    $T04().That(actual, new ($T07())(new ($T08())(expected)), message, args);
  };

  function CollectionAssert_AreNotEqual$17 (expected, actual, comparer, message, args) {
    $T04().That(actual, new ($T07())($S02().CallVirtual("Using", null, (new ($T08())(expected)), comparer)), message, args);
  };

  function CollectionAssert_AreNotEquivalent$18 (expected, actual) {
    $thisType.AreNotEquivalent(expected, actual, $T02().Empty, null);
  };

  function CollectionAssert_AreNotEquivalent$19 (expected, actual, message) {
    $thisType.AreNotEquivalent(expected, actual, message, null);
  };

  function CollectionAssert_AreNotEquivalent$1A (expected, actual, message, args) {
    $T04().That(actual, new ($T07())(new ($T0B())(expected)), message, args);
  };

  function CollectionAssert_Contains$1B (collection, actual) {
    $thisType.Contains(collection, actual, $T02().Empty, null);
  };

  function CollectionAssert_Contains$1C (collection, actual, message) {
    $thisType.Contains(collection, actual, message, null);
  };

  function CollectionAssert_Contains$1D (collection, actual, message, args) {
    $T04().That(collection, new ($T0D())(actual), message, args);
  };

  function CollectionAssert_DoesNotContain$1E (collection, actual) {
    $thisType.DoesNotContain(collection, actual, $T02().Empty, null);
  };

  function CollectionAssert_DoesNotContain$1F (collection, actual, message) {
    $thisType.DoesNotContain(collection, actual, message, null);
  };

  function CollectionAssert_DoesNotContain$20 (collection, actual, message, args) {
    $T04().That(collection, new ($T07())(new ($T0D())(actual)), message, args);
  };

  function CollectionAssert_IsEmpty$21 (collection, message, args) {
    $T04().That(collection, new ($T0E())(), message, args);
  };

  function CollectionAssert_IsEmpty$22 (collection, message) {
    $thisType.IsEmpty(collection, message, null);
  };

  function CollectionAssert_IsEmpty$23 (collection) {
    $thisType.IsEmpty(collection, $T02().Empty, null);
  };

  function CollectionAssert_IsNotEmpty$24 (collection, message, args) {
    $T04().That(collection, new ($T07())(new ($T0E())()), message, args);
  };

  function CollectionAssert_IsNotEmpty$25 (collection, message) {
    $thisType.IsNotEmpty(collection, message, null);
  };

  function CollectionAssert_IsNotEmpty$26 (collection) {
    $thisType.IsNotEmpty(collection, $T02().Empty, null);
  };

  function CollectionAssert_IsNotSubsetOf$27 (subset, superset) {
    $thisType.IsNotSubsetOf(subset, superset, $T02().Empty, null);
  };

  function CollectionAssert_IsNotSubsetOf$28 (subset, superset, message) {
    $thisType.IsNotSubsetOf(subset, superset, message, null);
  };

  function CollectionAssert_IsNotSubsetOf$29 (subset, superset, message, args) {
    $T04().That(subset, new ($T07())(new ($T0F())(superset)), message, args);
  };

  function CollectionAssert_IsOrdered$2A (collection, message, args) {
    $T04().That(collection, new ($T10())(), message, args);
  };

  function CollectionAssert_IsOrdered$2B (collection, message) {
    $S03().CallStatic($thisType, "IsOrdered", null, collection, message, null);
  };

  function CollectionAssert_IsOrdered$2C (collection) {
    $S03().CallStatic($thisType, "IsOrdered", null, collection, $T02().Empty, null);
  };

  function CollectionAssert_IsOrdered$2D (collection, comparer, message, args) {
    $T04().That(collection, (new ($T10())()).Using(comparer), message, args);
  };

  function CollectionAssert_IsOrdered$2E (collection, comparer, message) {
    $thisType.IsOrdered(collection, comparer, message, null);
  };

  function CollectionAssert_IsOrdered$2F (collection, comparer) {
    $thisType.IsOrdered(collection, comparer, $T02().Empty, null);
  };

  function CollectionAssert_IsSubsetOf$30 (subset, superset) {
    $thisType.IsSubsetOf(subset, superset, $T02().Empty, null);
  };

  function CollectionAssert_IsSubsetOf$31 (subset, superset, message) {
    $thisType.IsSubsetOf(subset, superset, message, null);
  };

  function CollectionAssert_IsSubsetOf$32 (subset, superset, message, args) {
    $T04().That(subset, new ($T0F())(superset), message, args);
  };

  function CollectionAssert_ReferenceEquals$33 (a, b) {
    throw $S04().Construct("Assert.ReferenceEquals should not be used for Assertions");
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.CollectionAssert", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CollectionAssert__ctor
    );

    $.Method({Static:true , Public:true }, "AllItemsAreInstancesOfType", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Type")]), 
      CollectionAssert_AllItemsAreInstancesOfType$00
    );

    $.Method({Static:true , Public:true }, "AllItemsAreInstancesOfType", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Type"), 
          $.String
        ]), 
      CollectionAssert_AllItemsAreInstancesOfType$01
    );

    $.Method({Static:true , Public:true }, "AllItemsAreInstancesOfType", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Type"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AllItemsAreInstancesOfType$02
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AllItemsAreNotNull", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      CollectionAssert_AllItemsAreNotNull$03
    );

    $.Method({Static:true , Public:true }, "AllItemsAreNotNull", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.String]), 
      CollectionAssert_AllItemsAreNotNull$04
    );

    $.Method({Static:true , Public:true }, "AllItemsAreNotNull", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AllItemsAreNotNull$05
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AllItemsAreUnique", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      CollectionAssert_AllItemsAreUnique$06
    );

    $.Method({Static:true , Public:true }, "AllItemsAreUnique", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.String]), 
      CollectionAssert_AllItemsAreUnique$07
    );

    $.Method({Static:true , Public:true }, "AllItemsAreUnique", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AllItemsAreUnique$08
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionAssert_AreEqual$09
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IComparer")
        ]), 
      CollectionAssert_AreEqual$0A
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String
        ]), 
      CollectionAssert_AreEqual$0B
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IComparer"), $.String
        ]), 
      CollectionAssert_AreEqual$0C
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AreEqual$0D
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IComparer"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AreEqual$0E
    )
      .Parameter(4, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEquivalent", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionAssert_AreEquivalent$0F
    );

    $.Method({Static:true , Public:true }, "AreEquivalent", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String
        ]), 
      CollectionAssert_AreEquivalent$10
    );

    $.Method({Static:true , Public:true }, "AreEquivalent", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AreEquivalent$11
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionAssert_AreNotEqual$12
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IComparer")
        ]), 
      CollectionAssert_AreNotEqual$13
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String
        ]), 
      CollectionAssert_AreNotEqual$14
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IComparer"), $.String
        ]), 
      CollectionAssert_AreNotEqual$15
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AreNotEqual$16
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IComparer"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AreNotEqual$17
    )
      .Parameter(4, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEquivalent", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionAssert_AreNotEquivalent$18
    );

    $.Method({Static:true , Public:true }, "AreNotEquivalent", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String
        ]), 
      CollectionAssert_AreNotEquivalent$19
    );

    $.Method({Static:true , Public:true }, "AreNotEquivalent", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_AreNotEquivalent$1A
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.Object]), 
      CollectionAssert_Contains$1B
    );

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.Object, 
          $.String
        ]), 
      CollectionAssert_Contains$1C
    );

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_Contains$1D
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.Object]), 
      CollectionAssert_DoesNotContain$1E
    );

    $.Method({Static:true , Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.Object, 
          $.String
        ]), 
      CollectionAssert_DoesNotContain$1F
    );

    $.Method({Static:true , Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_DoesNotContain$20
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_IsEmpty$21
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.String]), 
      CollectionAssert_IsEmpty$22
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      CollectionAssert_IsEmpty$23
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_IsNotEmpty$24
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.String]), 
      CollectionAssert_IsNotEmpty$25
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      CollectionAssert_IsNotEmpty$26
    );

    $.Method({Static:true , Public:true }, "IsNotSubsetOf", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionAssert_IsNotSubsetOf$27
    );

    $.Method({Static:true , Public:true }, "IsNotSubsetOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String
        ]), 
      CollectionAssert_IsNotSubsetOf$28
    );

    $.Method({Static:true , Public:true }, "IsNotSubsetOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_IsNotSubsetOf$29
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsOrdered", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_IsOrdered$2A
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsOrdered", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $.String]), 
      CollectionAssert_IsOrdered$2B
    );

    $.Method({Static:true , Public:true }, "IsOrdered", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      CollectionAssert_IsOrdered$2C
    );

    $.Method({Static:true , Public:true }, "IsOrdered", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IComparer"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_IsOrdered$2D
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsOrdered", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IComparer"), 
          $.String
        ]), 
      CollectionAssert_IsOrdered$2E
    );

    $.Method({Static:true , Public:true }, "IsOrdered", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IComparer")]), 
      CollectionAssert_IsOrdered$2F
    );

    $.Method({Static:true , Public:true }, "IsSubsetOf", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionAssert_IsSubsetOf$30
    );

    $.Method({Static:true , Public:true }, "IsSubsetOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String
        ]), 
      CollectionAssert_IsSubsetOf$31
    );

    $.Method({Static:true , Public:true }, "IsSubsetOf", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      CollectionAssert_IsSubsetOf$32
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "ReferenceEquals", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      CollectionAssert_ReferenceEquals$33
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Contains */ 

(function Contains$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionContainsConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubstringConstraint)) ();
  };

  function Contains__ctor () {
  };

  function Contains_Item (expected) {
    return new ($T01())(expected);
  };

  function Contains_Substring (expected) {
    return new ($T03())(expected);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Contains", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Contains__ctor
    );

    $.Method({Static:true , Public:true }, "Item", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionContainsConstraint"), [$.Object]), 
      Contains_Item
    );

    $.Method({Static:true , Public:true }, "Substring", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      Contains_Substring
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.DirectoryAssert */ 

(function DirectoryAssert$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.IO.DirectoryInfo)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Assert)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyDirectoryConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IO.FileSystemInfo)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubPathConstraint)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.AssertionException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.IO.DirectoryInfo"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.String"), 
        $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.String"), 
        $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.AssertionException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function DirectoryAssert__ctor () {
  };

  function DirectoryAssert_AreEqual$00 (expected, actual, message, args) {
    $T03().That(actual, new ($T04())(expected), message, args);
  };

  function DirectoryAssert_AreEqual$01 (expected, actual, message) {
    $S00().CallStatic($thisType, "AreEqual", null, actual, expected, message, null);
  };

  function DirectoryAssert_AreEqual$02 (expected, actual) {
    $S00().CallStatic($thisType, "AreEqual", null, actual, expected, $T01().Empty, null);
  };

  function DirectoryAssert_AreEqual$03 (expected, actual, message, args) {
    var expected2 = $S01().Construct(expected);
    var actual2 = $S01().Construct(actual);
    $S00().CallStatic($thisType, "AreEqual", null, expected2, actual2, message, args);
  };

  function DirectoryAssert_AreEqual$04 (expected, actual, message) {
    $S02().CallStatic($thisType, "AreEqual", null, expected, actual, message, null);
  };

  function DirectoryAssert_AreEqual$05 (expected, actual) {
    $S02().CallStatic($thisType, "AreEqual", null, expected, actual, $T01().Empty, null);
  };

  function DirectoryAssert_AreNotEqual$06 (expected, actual, message, args) {
    $T03().That(actual, new ($T05())(new ($T04())(expected)), message, args);
  };

  function DirectoryAssert_AreNotEqual$07 (expected, actual, message) {
    $S03().CallStatic($thisType, "AreNotEqual", null, actual, expected, message, null);
  };

  function DirectoryAssert_AreNotEqual$08 (expected, actual) {
    $S03().CallStatic($thisType, "AreNotEqual", null, actual, expected, $T01().Empty, null);
  };

  function DirectoryAssert_AreNotEqual$09 (expected, actual, message, args) {
    var expected2 = $S01().Construct(expected);
    var actual2 = $S01().Construct(actual);
    $S03().CallStatic($thisType, "AreNotEqual", null, expected2, actual2, message, args);
  };

  function DirectoryAssert_AreNotEqual$0A (expected, actual, message) {
    $S04().CallStatic($thisType, "AreNotEqual", null, expected, actual, message, null);
  };

  function DirectoryAssert_AreNotEqual$0B (expected, actual) {
    $S04().CallStatic($thisType, "AreNotEqual", null, expected, actual, $T01().Empty, null);
  };

  function DirectoryAssert_IsEmpty$0C (directory, message, args) {
    $T03().That(directory, new ($T06())(), message, args);
  };

  function DirectoryAssert_IsEmpty$0D (directory, message) {
    $S05().CallStatic($thisType, "IsEmpty", null, directory, message, null);
  };

  function DirectoryAssert_IsEmpty$0E (directory) {
    $S05().CallStatic($thisType, "IsEmpty", null, directory, $T01().Empty, null);
  };

  function DirectoryAssert_IsEmpty$0F (directory, message, args) {
    $S05().CallStatic($thisType, "IsEmpty", null, $S01().Construct(directory), message, args);
  };

  function DirectoryAssert_IsEmpty$10 (directory, message) {
    $S06().CallStatic($thisType, "IsEmpty", null, directory, message, null);
  };

  function DirectoryAssert_IsEmpty$11 (directory) {
    $S06().CallStatic($thisType, "IsEmpty", null, directory, $T01().Empty, null);
  };

  function DirectoryAssert_IsNotEmpty$12 (directory, message, args) {
    $T03().That(directory, new ($T05())(new ($T06())()), message, args);
  };

  function DirectoryAssert_IsNotEmpty$13 (directory, message) {
    $S07().CallStatic($thisType, "IsNotEmpty", null, directory, message, null);
  };

  function DirectoryAssert_IsNotEmpty$14 (directory) {
    $S07().CallStatic($thisType, "IsNotEmpty", null, directory, $T01().Empty, null);
  };

  function DirectoryAssert_IsNotEmpty$15 (directory, message, args) {
    var directory2 = $S01().Construct(directory);
    $S07().CallStatic($thisType, "IsNotEmpty", null, directory2, message, args);
  };

  function DirectoryAssert_IsNotEmpty$16 (directory, message) {
    $S08().CallStatic($thisType, "IsNotEmpty", null, directory, message, null);
  };

  function DirectoryAssert_IsNotEmpty$17 (directory) {
    $S08().CallStatic($thisType, "IsNotEmpty", null, directory, $T01().Empty, null);
  };

  function DirectoryAssert_IsNotWithin$18 (directory, actual, message, args) {
    if (directory === null) {
      throw $S09().Construct("The directory may not be null", "directory");
    }
    if (directory === null) {
      throw $S09().Construct("The actual value may not be null", "actual");
    }
    $S0A().CallStatic($thisType, "IsNotWithin", null, 
      directory.get_FullName(), 
      actual.get_FullName(), 
      message, 
      args
    );
  };

  function DirectoryAssert_IsNotWithin$19 (directory, actual, message) {
    if (directory === null) {
      throw $S09().Construct("The directory may not be null", "directory");
    }
    if (directory === null) {
      throw $S09().Construct("The actual value may not be null", "actual");
    }
    $S0A().CallStatic($thisType, "IsNotWithin", null, 
      directory.get_FullName(), 
      actual.get_FullName(), 
      message, 
      null
    );
  };

  function DirectoryAssert_IsNotWithin$1A (directory, actual) {
    if (directory === null) {
      throw $S09().Construct("The directory may not be null", "directory");
    }
    if (directory === null) {
      throw $S09().Construct("The actual value may not be null", "actual");
    }
    $S0A().CallStatic($thisType, "IsNotWithin", null, 
      directory.get_FullName(), 
      actual.get_FullName(), 
      $T01().Empty, 
      null
    );
  };

  function DirectoryAssert_IsNotWithin$1B (directory, actual, message, args) {
    $T03().That(actual, new ($T05())(new ($T09())(directory)), message, args);
  };

  function DirectoryAssert_IsNotWithin$1C (directory, actual, message) {
    $S0A().CallStatic($thisType, "IsNotWithin", null, directory, actual, message, null);
  };

  function DirectoryAssert_IsNotWithin$1D (directory, actual) {
    $S0A().CallStatic($thisType, "IsNotWithin", null, directory, actual, $T01().Empty, null);
  };

  function DirectoryAssert_IsWithin$1E (directory, actual, message, args) {
    if (directory === null) {
      throw $S09().Construct("The directory may not be null", "directory");
    }
    if (directory === null) {
      throw $S09().Construct("The actual value may not be null", "actual");
    }
    $S0B().CallStatic($thisType, "IsWithin", null, 
      directory.get_FullName(), 
      actual.get_FullName(), 
      message, 
      args
    );
  };

  function DirectoryAssert_IsWithin$1F (directory, actual, message) {
    if (directory === null) {
      throw $S09().Construct("The directory may not be null", "directory");
    }
    if (directory === null) {
      throw $S09().Construct("The actual value may not be null", "actual");
    }
    $S0B().CallStatic($thisType, "IsWithin", null, 
      directory.get_FullName(), 
      actual.get_FullName(), 
      message, 
      null
    );
  };

  function DirectoryAssert_IsWithin$20 (directory, actual) {
    if (directory === null) {
      throw $S09().Construct("The directory may not be null", "directory");
    }
    if (directory === null) {
      throw $S09().Construct("The actual value may not be null", "actual");
    }
    $S0B().CallStatic($thisType, "IsWithin", null, 
      directory.get_FullName(), 
      actual.get_FullName(), 
      $T01().Empty, 
      null
    );
  };

  function DirectoryAssert_IsWithin$21 (directory, actual, message, args) {
    $T03().That(actual, new ($T09())(directory), message, args);
  };

  function DirectoryAssert_IsWithin$22 (directory, actual, message) {
    $S0B().CallStatic($thisType, "IsWithin", null, directory, actual, message, null);
  };

  function DirectoryAssert_IsWithin$23 (directory, actual) {
    $S0B().CallStatic($thisType, "IsWithin", null, directory, actual, $T01().Empty, null);
  };

  function DirectoryAssert_ReferenceEquals$24 (a, b) {
    throw $S0C().Construct("Assert.ReferenceEquals should not be used for Assertions");
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.DirectoryAssert", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      DirectoryAssert__ctor
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_AreEqual$00
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String
        ]), 
      DirectoryAssert_AreEqual$01
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo")]), 
      DirectoryAssert_AreEqual$02
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_AreEqual$03
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      DirectoryAssert_AreEqual$04
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      DirectoryAssert_AreEqual$05
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_AreNotEqual$06
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String
        ]), 
      DirectoryAssert_AreNotEqual$07
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo")]), 
      DirectoryAssert_AreNotEqual$08
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_AreNotEqual$09
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      DirectoryAssert_AreNotEqual$0A
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      DirectoryAssert_AreNotEqual$0B
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsEmpty$0C
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.DirectoryInfo"), $.String]), 
      DirectoryAssert_IsEmpty$0D
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.IO.DirectoryInfo")), 
      DirectoryAssert_IsEmpty$0E
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsEmpty$0F
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsEmpty", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      DirectoryAssert_IsEmpty$10
    );

    $.Method({Static:true , Public:true }, "IsEmpty", 
      JSIL.MethodSignature.Action($.String), 
      DirectoryAssert_IsEmpty$11
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsNotEmpty$12
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.DirectoryInfo"), $.String]), 
      DirectoryAssert_IsNotEmpty$13
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.IO.DirectoryInfo")), 
      DirectoryAssert_IsNotEmpty$14
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsNotEmpty$15
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      DirectoryAssert_IsNotEmpty$16
    );

    $.Method({Static:true , Public:true }, "IsNotEmpty", 
      JSIL.MethodSignature.Action($.String), 
      DirectoryAssert_IsNotEmpty$17
    );

    $.Method({Static:true , Public:true }, "IsNotWithin", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsNotWithin$18
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotWithin", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String
        ]), 
      DirectoryAssert_IsNotWithin$19
    );

    $.Method({Static:true , Public:true }, "IsNotWithin", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo")]), 
      DirectoryAssert_IsNotWithin$1A
    );

    $.Method({Static:true , Public:true }, "IsNotWithin", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsNotWithin$1B
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsNotWithin", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      DirectoryAssert_IsNotWithin$1C
    );

    $.Method({Static:true , Public:true }, "IsNotWithin", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      DirectoryAssert_IsNotWithin$1D
    );

    $.Method({Static:true , Public:true }, "IsWithin", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsWithin$1E
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsWithin", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo"), 
          $.String
        ]), 
      DirectoryAssert_IsWithin$1F
    );

    $.Method({Static:true , Public:true }, "IsWithin", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo")]), 
      DirectoryAssert_IsWithin$20
    );

    $.Method({Static:true , Public:true }, "IsWithin", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      DirectoryAssert_IsWithin$21
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsWithin", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      DirectoryAssert_IsWithin$22
    );

    $.Method({Static:true , Public:true }, "IsWithin", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      DirectoryAssert_IsWithin$23
    );

    $.Method({Static:true , Public:true }, "ReferenceEquals", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      DirectoryAssert_ReferenceEquals$24
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Assert with constraint-based syntax"]; });

})();

/* class NUnit.Framework.FileAssert */ 

(function FileAssert$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.IO.Stream)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Assert)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.IO.FileInfo)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IO.FileStream)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IO.File)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.AssertionException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.AssertionException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function FileAssert__ctor () {
  };

  function FileAssert_AreEqual$00 (expected, actual, message, args) {
    $T03().That(actual, new ($T04())(expected), message, args);
  };

  function FileAssert_AreEqual$01 (expected, actual, message) {
    $S00().CallStatic($thisType, "AreEqual", null, expected, actual, message, null);
  };

  function FileAssert_AreEqual$02 (expected, actual) {
    $S00().CallStatic($thisType, "AreEqual", null, expected, actual, $T01().Empty, null);
  };

  function FileAssert_AreEqual$03 (expected, actual, message, args) {
    var fileStream = expected.OpenRead();
    try {
      var fileStream2 = actual.OpenRead();
      try {
        $S00().CallStatic($thisType, "AreEqual", null, fileStream, fileStream2, message, args);
      } finally {
        if (fileStream2 !== null) {
          $IM00().Call(fileStream2, null);
        }
      }
    } finally {
      if (fileStream !== null) {
        $IM00().Call(fileStream, null);
      }
    }
  };

  function FileAssert_AreEqual$04 (expected, actual, message) {
    $S01().CallStatic($thisType, "AreEqual", null, expected, actual, message, null);
  };

  function FileAssert_AreEqual$05 (expected, actual) {
    $S01().CallStatic($thisType, "AreEqual", null, expected, actual, $T01().Empty, null);
  };

  function FileAssert_AreEqual$06 (expected, actual, message, args) {
    var fileStream = $T08().OpenRead(expected);
    try {
      var fileStream2 = $T08().OpenRead(actual);
      try {
        $S00().CallStatic($thisType, "AreEqual", null, fileStream, fileStream2, message, args);
      } finally {
        if (fileStream2 !== null) {
          $IM00().Call(fileStream2, null);
        }
      }
    } finally {
      if (fileStream !== null) {
        $IM00().Call(fileStream, null);
      }
    }
  };

  function FileAssert_AreEqual$07 (expected, actual, message) {
    $S02().CallStatic($thisType, "AreEqual", null, expected, actual, message, null);
  };

  function FileAssert_AreEqual$08 (expected, actual) {
    $S02().CallStatic($thisType, "AreEqual", null, expected, actual, $T01().Empty, null);
  };

  function FileAssert_AreNotEqual$09 (expected, actual, message, args) {
    $T03().That(actual, new ($T09())(new ($T04())(expected)), message, args);
  };

  function FileAssert_AreNotEqual$0A (expected, actual, message) {
    $S03().CallStatic($thisType, "AreNotEqual", null, expected, actual, message, null);
  };

  function FileAssert_AreNotEqual$0B (expected, actual) {
    $S03().CallStatic($thisType, "AreNotEqual", null, expected, actual, $T01().Empty, null);
  };

  function FileAssert_AreNotEqual$0C (expected, actual, message, args) {
    var fileStream = expected.OpenRead();
    try {
      var fileStream2 = actual.OpenRead();
      try {
        $S03().CallStatic($thisType, "AreNotEqual", null, fileStream, fileStream2, message, args);
      } finally {
        if (fileStream2 !== null) {
          $IM00().Call(fileStream2, null);
        }
      }
    } finally {
      if (fileStream !== null) {
        $IM00().Call(fileStream, null);
      }
    }
  };

  function FileAssert_AreNotEqual$0D (expected, actual, message) {
    $S04().CallStatic($thisType, "AreNotEqual", null, expected, actual, message, null);
  };

  function FileAssert_AreNotEqual$0E (expected, actual) {
    $S04().CallStatic($thisType, "AreNotEqual", null, expected, actual, $T01().Empty, null);
  };

  function FileAssert_AreNotEqual$0F (expected, actual, message, args) {
    var fileStream = $T08().OpenRead(expected);
    try {
      var fileStream2 = $T08().OpenRead(actual);
      try {
        $S03().CallStatic($thisType, "AreNotEqual", null, fileStream, fileStream2, message, args);
      } finally {
        if (fileStream2 !== null) {
          $IM00().Call(fileStream2, null);
        }
      }
    } finally {
      if (fileStream !== null) {
        $IM00().Call(fileStream, null);
      }
    }
  };

  function FileAssert_AreNotEqual$10 (expected, actual, message) {
    $S05().CallStatic($thisType, "AreNotEqual", null, expected, actual, message, null);
  };

  function FileAssert_AreNotEqual$11 (expected, actual) {
    $S05().CallStatic($thisType, "AreNotEqual", null, expected, actual, $T01().Empty, null);
  };

  function FileAssert_ReferenceEquals$12 (a, b) {
    throw $S06().Construct("Assert.ReferenceEquals should not be used for Assertions");
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.FileAssert", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      FileAssert__ctor
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      FileAssert_AreEqual$00
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream"), 
          $.String
        ]), 
      FileAssert_AreEqual$01
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream")]), 
      FileAssert_AreEqual$02
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      FileAssert_AreEqual$03
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo"), 
          $.String
        ]), 
      FileAssert_AreEqual$04
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo")]), 
      FileAssert_AreEqual$05
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      FileAssert_AreEqual$06
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      FileAssert_AreEqual$07
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      FileAssert_AreEqual$08
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      FileAssert_AreNotEqual$09
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream"), 
          $.String
        ]), 
      FileAssert_AreNotEqual$0A
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream")]), 
      FileAssert_AreNotEqual$0B
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo"), 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      FileAssert_AreNotEqual$0C
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo"), 
          $.String
        ]), 
      FileAssert_AreNotEqual$0D
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.FileInfo"), $asm0A.TypeRef("System.IO.FileInfo")]), 
      FileAssert_AreNotEqual$0E
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      FileAssert_AreNotEqual$0F
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      FileAssert_AreNotEqual$10
    );

    $.Method({Static:true , Public:true }, "AreNotEqual", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      FileAssert_AreNotEqual$11
    );

    $.Method({Static:true , Public:true }, "ReferenceEquals", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      FileAssert_ReferenceEquals$12
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.GlobalSettings */ 

(function GlobalSettings$Members () {
  var $, $thisType;
  function GlobalSettings__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.GlobalSettings", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      GlobalSettings__ctor
    );

    $.Field({Static:true , Public:true }, "DefaultFloatingPointTolerance", $.Double, 0); 
    function GlobalSettings__cctor () {
      $thisType.DefaultFloatingPointTolerance = 0;
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      GlobalSettings__cctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Guard */ 

(function Guard$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.ArgumentNullException)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentNullException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };

  function Guard__ctor () {
  };

  function Guard_ArgumentNotNull (value, name) {
    if (value === null) {
      throw $S00().Construct(("Argument " + name + " must not be null"), name);
    }
  };

  function Guard_ArgumentNotNullOrEmpty (value, name) {
    $thisType.ArgumentNotNull(value, name);
    if (value == $T01().Empty) {
      throw $S01().Construct(("Argument " + name + " must not be the empty string"), name);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Guard", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Guard__ctor
    );

    $.Method({Static:true , Public:true }, "ArgumentNotNull", 
      new JSIL.MethodSignature(null, [$.Object, $.String]), 
      Guard_ArgumentNotNull
    );

    $.Method({Static:true , Public:true }, "ArgumentNotNullOrEmpty", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      Guard_ArgumentNotNullOrEmpty
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Has */ 

(function Has$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionContainsConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), null))) ();
  };

  function Has__ctor () {
  };

  function Has_Attribute (expectedType) {
    return $S00().Construct().Attribute(expectedType);
  };

  function Has_Attribute$b1 (T) {
    return $thisType.Attribute(T);
  };

  function Has_Exactly (expectedCount) {
    return $S00().Construct().Exactly(expectedCount);
  };

  function Has_get_All () {
    return $S00().Construct().get_All();
  };

  function Has_get_Count () {
    return $thisType.Property("Count");
  };

  function Has_get_InnerException () {
    return $thisType.Property("InnerException");
  };

  function Has_get_Length () {
    return $thisType.Property("Length");
  };

  function Has_get_Message () {
    return $thisType.Property("Message");
  };

  function Has_get_No () {
    return $S00().Construct().get_Not();
  };

  function Has_get_None () {
    return $S00().Construct().get_None();
  };

  function Has_get_Some () {
    return $S00().Construct().get_Some();
  };

  function Has_Member (expected) {
    return new ($T04())(expected);
  };

  function Has_Property (name) {
    return $S00().Construct().Property(name);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Has", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Has__ctor
    );

    $.Method({Static:true , Public:true }, "Attribute", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$asm0A.TypeRef("System.Type")]), 
      Has_Attribute
    );

    $.Method({Static:true , Public:true }, "Attribute", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), null, ["T"]), 
      Has_Attribute$b1
    );

    $.Method({Static:true , Public:true }, "Exactly", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), [$.Int32]), 
      Has_Exactly
    );

    $.Method({Static:true , Public:true }, "get_All", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Has_get_All
    );

    $.Method({Static:true , Public:true }, "get_Count", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      Has_get_Count
    );

    $.Method({Static:true , Public:true }, "get_InnerException", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      Has_get_InnerException
    );

    $.Method({Static:true , Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      Has_get_Length
    );

    $.Method({Static:true , Public:true }, "get_Message", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      Has_get_Message
    );

    $.Method({Static:true , Public:true }, "get_No", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Has_get_No
    );

    $.Method({Static:true , Public:true }, "get_None", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Has_get_None
    );

    $.Method({Static:true , Public:true }, "get_Some", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Has_get_Some
    );

    $.Method({Static:true , Public:true }, "Member", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionContainsConstraint"), [$.Object]), 
      Has_Member
    );

    $.Method({Static:true , Public:true }, "Property", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$.String]), 
      Has_Property
    );

    $.Property({Static:true , Public:true }, "No", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:true , Public:true }, "All", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:true , Public:true }, "Some", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:true , Public:true }, "None", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:true , Public:true }, "Length", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:true , Public:true }, "Count", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:true , Public:true }, "Message", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:true , Public:true }, "InnerException", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface NUnit.Framework.IExpectException */ 

JSIL.MakeInterface(
  "NUnit.Framework.IExpectException", true, [], function ($) {
    $.Method({}, "HandleException", JSIL.MethodSignature.Action($asm0A.TypeRef("System.Exception")));
  }, []);

/* class NUnit.Framework.Is */ 

(function Is$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AssignableFromConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AssignableToConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.GreaterThanOrEqualConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.LessThanOrEqualConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionEquivalentConstraint)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinarySerializableConstraint)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyConstraint)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FalseConstraint)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NaNConstraint)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.LessThanConstraint)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NullConstraint)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOrderedConstraint)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.GreaterThanConstraint)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TrueConstraint)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.UniqueItemsConstraint)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.XmlSerializableConstraint)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.InstanceOfTypeConstraint)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SameAsConstraint)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SamePathConstraint)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SamePathOrUnderConstraint)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubstringConstraint)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EndsWithConstraint)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.RegexConstraint)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StartsWithConstraint)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubPathConstraint)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionSubsetConstraint)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExactTypeConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), null))) ();
  };

  function Is__ctor () {
  };

  function Is_AssignableFrom (expectedType) {
    return new ($T01())(expectedType);
  };

  function Is_AssignableFrom$b1 (T) {
    return new ($T01())(T);
  };

  function Is_AssignableTo (expectedType) {
    return new ($T02())(expectedType);
  };

  function Is_AssignableTo$b1 (T) {
    return new ($T02())(T);
  };

  function Is_AtLeast (expected) {
    return new ($T04())(expected);
  };

  function Is_AtMost (expected) {
    return new ($T05())(expected);
  };

  function Is_EqualTo (expected) {
    return new ($T06())(expected);
  };

  function Is_EquivalentTo (expected) {
    return new ($T08())(expected);
  };

  function Is_get_All () {
    return $S00().Construct().get_All();
  };

  function Is_get_BinarySerializable () {
    return new ($T0A())();
  };

  function Is_get_Empty () {
    return new ($T0B())();
  };

  function Is_get_False () {
    return new ($T0C())();
  };

  function Is_get_NaN () {
    return new ($T0D())();
  };

  function Is_get_Negative () {
    return new ($T0E())(0);
  };

  function Is_get_Not () {
    return $S00().Construct().get_Not();
  };

  function Is_get_Null () {
    return new ($T0F())();
  };

  function Is_get_Ordered () {
    return new ($T10())();
  };

  function Is_get_Positive () {
    return new ($T11())(0);
  };

  function Is_get_True () {
    return new ($T12())();
  };

  function Is_get_Unique () {
    return new ($T13())();
  };

  function Is_get_XmlSerializable () {
    return new ($T14())();
  };

  function Is_GreaterThan (expected) {
    return new ($T11())(expected);
  };

  function Is_GreaterThanOrEqualTo (expected) {
    return new ($T04())(expected);
  };

  function Is_InRange$b1 (T, from, to) {
    return new ($asm0B.NUnit.Framework.Constraints.RangeConstraint$b1.Of(T)) (JSIL.CloneParameter(T, from), JSIL.CloneParameter(T, to));
  };

  function Is_InstanceOf (expectedType) {
    return new ($T15())(expectedType);
  };

  function Is_InstanceOf$b1 (T) {
    return new ($T15())(T);
  };

  function Is_InstanceOfType (expectedType) {
    return new ($T15())(expectedType);
  };

  function Is_InstanceOfType$b1 (T) {
    return new ($T15())(T);
  };

  function Is_LessThan (expected) {
    return new ($T0E())(expected);
  };

  function Is_LessThanOrEqualTo (expected) {
    return new ($T05())(expected);
  };

  function Is_SameAs (expected) {
    return new ($T16())(expected);
  };

  function Is_SamePath (expected) {
    return new ($T18())(expected);
  };

  function Is_SamePathOrUnder (expected) {
    return new ($T19())(expected);
  };

  function Is_StringContaining (expected) {
    return new ($T1A())(expected);
  };

  function Is_StringEnding (expected) {
    return new ($T1B())(expected);
  };

  function Is_StringMatching (pattern) {
    return new ($T1C())(pattern);
  };

  function Is_StringStarting (expected) {
    return new ($T1D())(expected);
  };

  function Is_SubPath (expected) {
    return new ($T1E())(expected);
  };

  function Is_SubsetOf (expected) {
    return new ($T1F())(expected);
  };

  function Is_TypeOf (expectedType) {
    return new ($T20())(expectedType);
  };

  function Is_TypeOf$b1 (T) {
    return new ($T20())(T);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Is", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Is__ctor
    );

    $.Method({Static:true , Public:true }, "AssignableFrom", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableFromConstraint"), [$asm0A.TypeRef("System.Type")]), 
      Is_AssignableFrom
    );

    $.Method({Static:true , Public:true }, "AssignableFrom", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableFromConstraint"), null, ["T"]), 
      Is_AssignableFrom$b1
    );

    $.Method({Static:true , Public:true }, "AssignableTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableToConstraint"), [$asm0A.TypeRef("System.Type")]), 
      Is_AssignableTo
    );

    $.Method({Static:true , Public:true }, "AssignableTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableToConstraint"), null, ["T"]), 
      Is_AssignableTo$b1
    );

    $.Method({Static:true , Public:true }, "AtLeast", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanOrEqualConstraint"), [$.Object]), 
      Is_AtLeast
    );

    $.Method({Static:true , Public:true }, "AtMost", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanOrEqualConstraint"), [$.Object]), 
      Is_AtMost
    );

    $.Method({Static:true , Public:true }, "EqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualConstraint"), [$.Object]), 
      Is_EqualTo
    );

    $.Method({Static:true , Public:true }, "EquivalentTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionEquivalentConstraint"), [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      Is_EquivalentTo
    );

    $.Method({Static:true , Public:true }, "get_All", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Is_get_All
    );

    $.Method({Static:true , Public:true }, "get_BinarySerializable", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.BinarySerializableConstraint")), 
      Is_get_BinarySerializable
    );

    $.Method({Static:true , Public:true }, "get_Empty", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.EmptyConstraint")), 
      Is_get_Empty
    );

    $.Method({Static:true , Public:true }, "get_False", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.FalseConstraint")), 
      Is_get_False
    );

    $.Method({Static:true , Public:true }, "get_NaN", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.NaNConstraint")), 
      Is_get_NaN
    );

    $.Method({Static:true , Public:true }, "get_Negative", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint")), 
      Is_get_Negative
    );

    $.Method({Static:true , Public:true }, "get_Not", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Is_get_Not
    );

    $.Method({Static:true , Public:true }, "get_Null", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.NullConstraint")), 
      Is_get_Null
    );

    $.Method({Static:true , Public:true }, "get_Ordered", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOrderedConstraint")), 
      Is_get_Ordered
    );

    $.Method({Static:true , Public:true }, "get_Positive", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint")), 
      Is_get_Positive
    );

    $.Method({Static:true , Public:true }, "get_True", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.TrueConstraint")), 
      Is_get_True
    );

    $.Method({Static:true , Public:true }, "get_Unique", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.UniqueItemsConstraint")), 
      Is_get_Unique
    );

    $.Method({Static:true , Public:true }, "get_XmlSerializable", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.XmlSerializableConstraint")), 
      Is_get_XmlSerializable
    );

    $.Method({Static:true , Public:true }, "GreaterThan", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint"), [$.Object]), 
      Is_GreaterThan
    );

    $.Method({Static:true , Public:true }, "GreaterThanOrEqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanOrEqualConstraint"), [$.Object]), 
      Is_GreaterThanOrEqualTo
    );

    $.Method({Static:true , Public:true }, "InRange", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RangeConstraint`1", ["!!0"]), ["!!0", "!!0"], ["T"]), 
      Is_InRange$b1
    );

    $.Method({Static:true , Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      Is_InstanceOf
    );

    $.Method({Static:true , Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), null, ["T"]), 
      Is_InstanceOf$b1
    );

    $.Method({Static:true , Public:true }, "InstanceOfType", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      Is_InstanceOfType
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use InstanceOf(expectedType)"]; });

    $.Method({Static:true , Public:true }, "InstanceOfType", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), null, ["T"]), 
      Is_InstanceOfType$b1
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use InstanceOf<T>()"]; });

    $.Method({Static:true , Public:true }, "LessThan", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint"), [$.Object]), 
      Is_LessThan
    );

    $.Method({Static:true , Public:true }, "LessThanOrEqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanOrEqualConstraint"), [$.Object]), 
      Is_LessThanOrEqualTo
    );

    $.Method({Static:true , Public:true }, "SameAs", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SameAsConstraint"), [$.Object]), 
      Is_SameAs
    );

    $.Method({Static:true , Public:true }, "SamePath", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SamePathConstraint"), [$.String]), 
      Is_SamePath
    );

    $.Method({Static:true , Public:true }, "SamePathOrUnder", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SamePathOrUnderConstraint"), [$.String]), 
      Is_SamePathOrUnder
    );

    $.Method({Static:true , Public:true }, "StringContaining", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      Is_StringContaining
    );

    $.Method({Static:true , Public:true }, "StringEnding", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      Is_StringEnding
    );

    $.Method({Static:true , Public:true }, "StringMatching", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      Is_StringMatching
    );

    $.Method({Static:true , Public:true }, "StringStarting", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      Is_StringStarting
    );

    $.Method({Static:true , Public:true }, "SubPath", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubPathConstraint"), [$.String]), 
      Is_SubPath
    );

    $.Method({Static:true , Public:true }, "SubsetOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionSubsetConstraint"), [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      Is_SubsetOf
    );

    $.Method({Static:true , Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      Is_TypeOf
    );

    $.Method({Static:true , Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), null, ["T"]), 
      Is_TypeOf$b1
    );

    $.Property({Static:true , Public:true }, "Not", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:true , Public:true }, "All", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:true , Public:true }, "Null", $asm0B.TypeRef("NUnit.Framework.Constraints.NullConstraint"));

    $.Property({Static:true , Public:true }, "True", $asm0B.TypeRef("NUnit.Framework.Constraints.TrueConstraint"));

    $.Property({Static:true , Public:true }, "False", $asm0B.TypeRef("NUnit.Framework.Constraints.FalseConstraint"));

    $.Property({Static:true , Public:true }, "Positive", $asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint"));

    $.Property({Static:true , Public:true }, "Negative", $asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint"));

    $.Property({Static:true , Public:true }, "NaN", $asm0B.TypeRef("NUnit.Framework.Constraints.NaNConstraint"));

    $.Property({Static:true , Public:true }, "Empty", $asm0B.TypeRef("NUnit.Framework.Constraints.EmptyConstraint"));

    $.Property({Static:true , Public:true }, "Unique", $asm0B.TypeRef("NUnit.Framework.Constraints.UniqueItemsConstraint"));

    $.Property({Static:true , Public:true }, "BinarySerializable", $asm0B.TypeRef("NUnit.Framework.Constraints.BinarySerializableConstraint"));

    $.Property({Static:true , Public:true }, "XmlSerializable", $asm0B.TypeRef("NUnit.Framework.Constraints.XmlSerializableConstraint"));

    $.Property({Static:true , Public:true }, "Ordered", $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOrderedConstraint"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface NUnit.Framework.ITestCaseData */ 

JSIL.MakeInterface(
  "NUnit.Framework.ITestCaseData", true, [], function ($) {
    $.Method({}, "get_Arguments", JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Object])));
    $.Method({}, "get_Result", JSIL.MethodSignature.Return($.Object));
    $.Method({}, "get_HasExpectedResult", JSIL.MethodSignature.Return($.Boolean));
    $.Method({}, "get_ExpectedException", JSIL.MethodSignature.Return($asm0A.TypeRef("System.Type")));
    $.Method({}, "get_ExpectedExceptionName", JSIL.MethodSignature.Return($.String));
    $.Method({}, "get_TestName", JSIL.MethodSignature.Return($.String));
    $.Method({}, "get_Description", JSIL.MethodSignature.Return($.String));
    $.Method({}, "get_Ignored", JSIL.MethodSignature.Return($.Boolean));
    $.Method({}, "get_Explicit", JSIL.MethodSignature.Return($.Boolean));
    $.Method({}, "get_IgnoreReason", JSIL.MethodSignature.Return($.String));
    $.Property({}, "Arguments");
    $.Property({}, "Result");
    $.Property({}, "HasExpectedResult");
    $.Property({}, "ExpectedException");
    $.Property({}, "ExpectedExceptionName");
    $.Property({}, "TestName");
    $.Property({}, "Description");
    $.Property({}, "Ignored");
    $.Property({}, "Explicit");
    $.Property({}, "IgnoreReason");
  }, []);

/* class NUnit.Framework.Iz */ 

(function Iz$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Is)) ();
  };

  function Iz__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Is"), 
      Name: "NUnit.Framework.Iz", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Iz__ctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.List */ 

(function List$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.ListMapper)) ();
  };

  function List__ctor () {
  };

  function List_Map (actual) {
    return new ($T01())(actual);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.List", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      List__ctor
    );

    $.Method({Static:true , Public:true }, "Map", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.ListMapper"), [$asm0A.TypeRef("System.Collections.ICollection")]), 
      List_Map
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.ListMapper */ 

(function ListMapper$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Collections.ArrayList)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Reflection.PropertyInfo)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Reflection.BindingFlags)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.ArrayList"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Reflection.PropertyInfo"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Reflection.BindingFlags")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function ListMapper__ctor (original) {
    this.original = original;
  };

  function ListMapper_Property (name) {
    var arrayList = $S00().Construct();
    var enumerator = $IM00().Call(this.original, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        var property = $S01().CallVirtual("GetProperty", null, JSIL.GetType(current), name, $T08().$Flags("Instance", "NonPublic", "Public"));
        if (property === null) {
          throw $S02().Construct($T01().Format("{0} does not have a {1} property", current, name));
        }
        arrayList.Add(property.GetValue(current, null));
      }
    } finally {
      var disposable = $T0A().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    return arrayList;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.ListMapper", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.ICollection")), 
      ListMapper__ctor
    );

    $.Method({Static:false, Public:true }, "Property", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Collections.ICollection"), [$.String]), 
      ListMapper_Property
    );

    $.Field({Static:false, Public:false}, "original", $asm0A.TypeRef("System.Collections.ICollection")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Randomizer */ 

(function Randomizer$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Random)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.Hashtable)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm0A.System.Double))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize(System.Array.Of($asm0A.System.Int32))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Reflection.ParameterInfo)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Random"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.Hashtable"), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Randomizer"), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Randomizer"), [$asm0A.TypeRef("System.Reflection.MemberInfo")]))) ();
  };

  function Randomizer__ctor$00 () {
    $T00().prototype._ctor.call(this, $thisType.get_RandomSeed());
  };

  function Randomizer__ctor$01 (seed) {
    $T00().prototype._ctor.call(this, seed);
  };

  function Randomizer_get_RandomSeed () {
    return $thisType.seedGenerator.Next();
  };

  function Randomizer_GetDoubles$02 (count) {
    var array = JSIL.Array.New($T04(), count);

    for (var i = 0; i < (count | 0); i = ((i + 1) | 0)) {
      array[i] = +this.NextDouble();
    }
    return array;
  };

  function Randomizer_GetDoubles$03 (min, max, count) {
    var num = +max - +min;
    var array = JSIL.Array.New($T04(), count);

    for (var i = 0; i < (count | 0); i = ((i + 1) | 0)) {
      array[i] = (+this.NextDouble() * num) + +min;
    }
    return array;
  };

  function Randomizer_GetInts (min, max, count) {
    var array = JSIL.Array.New($T02(), count);

    for (var i = 0; i < (count | 0); i = ((i + 1) | 0)) {
      array[i] = (this.Next(min, max) | 0);
    }
    return array;
  };

  function Randomizer_GetRandomizer$04 (member) {
    var $temp00, $temp01;
    var randomizer = $thisType.$Cast($thisType.randomizers.get_Item(member));
    if (randomizer === null) {
      randomizer = $thisType.$Cast(($temp00 = $thisType.randomizers, 
          $temp01 = $S02().Construct(), 
          $temp00.set_Item(member, $temp01), 
          $temp01));
    }
    return randomizer;
  };

  function Randomizer_GetRandomizer$05 (parameter) {
    return $S03().CallStatic($thisType, "GetRandomizer", null, parameter.get_Member());
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Random"), 
      Name: "NUnit.Framework.Randomizer", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Randomizer__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      Randomizer__ctor$01
    );

    $.Method({Static:true , Public:true }, "get_RandomSeed", 
      JSIL.MethodSignature.Return($.Int32), 
      Randomizer_get_RandomSeed
    );

    $.Method({Static:false, Public:true }, "GetDoubles", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Double]), [$.Int32]), 
      Randomizer_GetDoubles$02
    );

    $.Method({Static:false, Public:true }, "GetDoubles", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Double]), [
          $.Double, $.Double, 
          $.Int32
        ]), 
      Randomizer_GetDoubles$03
    );

    $.Method({Static:false, Public:true }, "GetInts", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Int32]), [
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      Randomizer_GetInts
    );

    $.Method({Static:true , Public:true }, "GetRandomizer", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Reflection.MemberInfo")]), 
      Randomizer_GetRandomizer$04
    );

    $.Method({Static:true , Public:true }, "GetRandomizer", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Reflection.ParameterInfo")]), 
      Randomizer_GetRandomizer$05
    );

    $.Field({Static:true , Public:false}, "seedGenerator", $asm0A.TypeRef("System.Random")); 
    $.Field({Static:true , Public:false}, "randomizers", $asm0A.TypeRef("System.Collections.Hashtable")); 
    function Randomizer__cctor () {
      $thisType.seedGenerator = $S00().Construct();
      $thisType.randomizers = $S01().Construct();
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Randomizer__cctor
    );

    $.Property({Static:true , Public:true }, "RandomSeed", $.Int32);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum NUnit.Framework.SpecialValue */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.SpecialValue", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Null: 0, 
  }
);

/* class NUnit.Framework.StringAssert */ 

(function StringAssert$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Assert)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubstringConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EndsWithConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.RegexConstraint)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StartsWithConstraint)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.AssertionException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.AssertionException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function StringAssert__ctor () {
  };

  function StringAssert_AreEqualIgnoringCase$00 (expected, actual, message, args) {
    $T02().That(actual, ((new ($T03())(expected))).get_IgnoreCase(), message, args);
  };

  function StringAssert_AreEqualIgnoringCase$01 (expected, actual, message) {
    $thisType.AreEqualIgnoringCase(expected, actual, message, null);
  };

  function StringAssert_AreEqualIgnoringCase$02 (expected, actual) {
    $thisType.AreEqualIgnoringCase(expected, actual, $T00().Empty, null);
  };

  function StringAssert_AreNotEqualIgnoringCase$03 (expected, actual, message, args) {
    $T02().That(actual, new ($T04())(((new ($T03())(expected))).get_IgnoreCase()), message, args);
  };

  function StringAssert_AreNotEqualIgnoringCase$04 (expected, actual, message) {
    $thisType.AreNotEqualIgnoringCase(expected, actual, message, null);
  };

  function StringAssert_AreNotEqualIgnoringCase$05 (expected, actual) {
    $thisType.AreNotEqualIgnoringCase(expected, actual, $T00().Empty, null);
  };

  function StringAssert_Contains$06 (expected, actual, message, args) {
    $T02().That(actual, new ($T05())(expected), message, args);
  };

  function StringAssert_Contains$07 (expected, actual, message) {
    $thisType.Contains(expected, actual, message, null);
  };

  function StringAssert_Contains$08 (expected, actual) {
    $thisType.Contains(expected, actual, $T00().Empty, null);
  };

  function StringAssert_DoesNotContain$09 (expected, actual, message, args) {
    $T02().That(actual, new ($T04())(new ($T05())(expected)), message, args);
  };

  function StringAssert_DoesNotContain$0A (expected, actual, message) {
    $thisType.DoesNotContain(expected, actual, message, null);
  };

  function StringAssert_DoesNotContain$0B (expected, actual) {
    $thisType.DoesNotContain(expected, actual, $T00().Empty, null);
  };

  function StringAssert_DoesNotEndWith$0C (expected, actual, message, args) {
    $T02().That(actual, new ($T04())(new ($T06())(expected)), message, args);
  };

  function StringAssert_DoesNotEndWith$0D (expected, actual, message) {
    $thisType.DoesNotEndWith(expected, actual, message, null);
  };

  function StringAssert_DoesNotEndWith$0E (expected, actual) {
    $thisType.DoesNotEndWith(expected, actual, $T00().Empty, null);
  };

  function StringAssert_DoesNotMatch$0F (pattern, actual, message, args) {
    $T02().That(actual, new ($T04())(new ($T07())(pattern)), message, args);
  };

  function StringAssert_DoesNotMatch$10 (pattern, actual, message) {
    $thisType.DoesNotMatch(pattern, actual, message, null);
  };

  function StringAssert_DoesNotMatch$11 (pattern, actual) {
    $thisType.DoesNotMatch(pattern, actual, $T00().Empty, null);
  };

  function StringAssert_DoesNotStartWith$12 (expected, actual, message, args) {
    $T02().That(actual, new ($T04())(new ($T08())(expected)), message, args);
  };

  function StringAssert_DoesNotStartWith$13 (expected, actual, message) {
    $thisType.DoesNotStartWith(expected, actual, message, null);
  };

  function StringAssert_DoesNotStartWith$14 (expected, actual) {
    $thisType.DoesNotStartWith(expected, actual, $T00().Empty, null);
  };

  function StringAssert_EndsWith$15 (expected, actual, message, args) {
    $T02().That(actual, new ($T06())(expected), message, args);
  };

  function StringAssert_EndsWith$16 (expected, actual, message) {
    $thisType.EndsWith(expected, actual, message, null);
  };

  function StringAssert_EndsWith$17 (expected, actual) {
    $thisType.EndsWith(expected, actual, $T00().Empty, null);
  };

  function StringAssert_IsMatch$18 (pattern, actual, message, args) {
    $T02().That(actual, new ($T07())(pattern), message, args);
  };

  function StringAssert_IsMatch$19 (pattern, actual, message) {
    $thisType.IsMatch(pattern, actual, message, null);
  };

  function StringAssert_IsMatch$1A (pattern, actual) {
    $thisType.IsMatch(pattern, actual, $T00().Empty, null);
  };

  function StringAssert_ReferenceEquals$1B (a, b) {
    throw $S00().Construct("Assert.ReferenceEquals should not be used for Assertions");
  };

  function StringAssert_StartsWith$1C (expected, actual, message, args) {
    $T02().That(actual, new ($T08())(expected), message, args);
  };

  function StringAssert_StartsWith$1D (expected, actual, message) {
    $thisType.StartsWith(expected, actual, message, null);
  };

  function StringAssert_StartsWith$1E (expected, actual) {
    $thisType.StartsWith(expected, actual, $T00().Empty, null);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.StringAssert", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      StringAssert__ctor
    );

    $.Method({Static:true , Public:true }, "AreEqualIgnoringCase", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_AreEqualIgnoringCase$00
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreEqualIgnoringCase", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_AreEqualIgnoringCase$01
    );

    $.Method({Static:true , Public:true }, "AreEqualIgnoringCase", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_AreEqualIgnoringCase$02
    );

    $.Method({Static:true , Public:true }, "AreNotEqualIgnoringCase", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_AreNotEqualIgnoringCase$03
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "AreNotEqualIgnoringCase", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_AreNotEqualIgnoringCase$04
    );

    $.Method({Static:true , Public:true }, "AreNotEqualIgnoringCase", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_AreNotEqualIgnoringCase$05
    );

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_Contains$06
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_Contains$07
    );

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_Contains$08
    );

    $.Method({Static:true , Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_DoesNotContain$09
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_DoesNotContain$0A
    );

    $.Method({Static:true , Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_DoesNotContain$0B
    );

    $.Method({Static:true , Public:true }, "DoesNotEndWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_DoesNotEndWith$0C
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "DoesNotEndWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_DoesNotEndWith$0D
    );

    $.Method({Static:true , Public:true }, "DoesNotEndWith", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_DoesNotEndWith$0E
    );

    $.Method({Static:true , Public:true }, "DoesNotMatch", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_DoesNotMatch$0F
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "DoesNotMatch", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_DoesNotMatch$10
    );

    $.Method({Static:true , Public:true }, "DoesNotMatch", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_DoesNotMatch$11
    );

    $.Method({Static:true , Public:true }, "DoesNotStartWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_DoesNotStartWith$12
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "DoesNotStartWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_DoesNotStartWith$13
    );

    $.Method({Static:true , Public:true }, "DoesNotStartWith", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_DoesNotStartWith$14
    );

    $.Method({Static:true , Public:true }, "EndsWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_EndsWith$15
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "EndsWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_EndsWith$16
    );

    $.Method({Static:true , Public:true }, "EndsWith", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_EndsWith$17
    );

    $.Method({Static:true , Public:true }, "IsMatch", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_IsMatch$18
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "IsMatch", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_IsMatch$19
    );

    $.Method({Static:true , Public:true }, "IsMatch", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_IsMatch$1A
    );

    $.Method({Static:true , Public:true }, "ReferenceEquals", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      StringAssert_ReferenceEquals$1B
    );

    $.Method({Static:true , Public:true }, "StartsWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      StringAssert_StartsWith$1C
    )
      .Parameter(3, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:true , Public:true }, "StartsWith", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ]), 
      StringAssert_StartsWith$1D
    );

    $.Method({Static:true , Public:true }, "StartsWith", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      StringAssert_StartsWith$1E
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.TestCaseData */ 

(function TestCaseData$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.ArrayList)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.IList)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0D.System.Collections.Specialized.ListDictionary)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.ArrayList"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.TypeRef("System.Collections.Specialized.ListDictionary"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.get_Item)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IDictionary.set_Item)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IList.Add)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.Collections.IDictionary.Add)) ();
  };

  function TestCaseData__ctor$00 (args) {
    if (args === null) {
      var array = JSIL.Array.New($T01(), 1);
      this.$arguments = array;
    } else {
      this.$arguments = args;
    }
  };

  function TestCaseData__ctor$01 (arg) {
    this.$arguments = JSIL.Array.New($T01(), [arg]);
  };

  function TestCaseData__ctor$02 (arg1, arg2) {
    this.$arguments = JSIL.Array.New($T01(), [arg1, arg2]);
  };

  function TestCaseData__ctor$03 (arg1, arg2, arg3) {
    this.$arguments = JSIL.Array.New($T01(), [arg1, arg2, arg3]);
  };

  function TestCaseData_get_Arguments () {
    return this.$arguments;
  };

  function TestCaseData_get_Categories () {
    if ($IM00().Call(this.get_Properties(), null, $thisType.CATEGORIES) === null) {
      $IM01().Call(this.get_Properties(), null, $thisType.CATEGORIES, $S00().Construct());
    }
    return $T04().$Cast($IM00().Call(this.get_Properties(), null, $thisType.CATEGORIES));
  };

  function TestCaseData_get_Description () {
    return this.description;
  };

  function TestCaseData_get_ExpectedException () {
    return this.expectedExceptionType;
  };

  function TestCaseData_get_ExpectedExceptionName () {
    return this.expectedExceptionName;
  };

  function TestCaseData_get_Explicit () {
    return this.isExplicit;
  };

  function TestCaseData_get_HasExpectedResult () {
    return this.hasExpectedResult;
  };

  function TestCaseData_get_Ignored () {
    return this.isIgnored;
  };

  function TestCaseData_get_IgnoreReason () {
    return this.ignoreReason;
  };

  function TestCaseData_get_Properties () {
    if (this.properties === null) {
      this.properties = $S01().Construct();
    }
    return this.properties;
  };

  function TestCaseData_get_Result () {
    return this.expectedResult;
  };

  function TestCaseData_get_TestName () {
    return this.testName;
  };

  function TestCaseData_Ignore$04 () {
    this.isIgnored = true;
    return this;
  };

  function TestCaseData_Ignore$05 (reason) {
    this.isIgnored = true;
    this.ignoreReason = reason;
    return this;
  };

  function TestCaseData_MakeExplicit$06 () {
    this.isExplicit = true;
    return this;
  };

  function TestCaseData_MakeExplicit$07 (reason) {
    this.isExplicit = true;
    this.ignoreReason = reason;
    return this;
  };

  function TestCaseData_Returns (result) {
    this.expectedResult = result;
    this.hasExpectedResult = true;
    return this;
  };

  function TestCaseData_SetCategory (category) {
    $IM02().Call(this.get_Categories(), null, category);
    return this;
  };

  function TestCaseData_SetDescription (description) {
    this.description = description;
    return this;
  };

  function TestCaseData_SetName (name) {
    this.testName = name;
    return this;
  };

  function TestCaseData_SetProperty$08 (propName, propValue) {
    $IM03().Call(this.get_Properties(), null, propName, propValue);
    return this;
  };

  function TestCaseData_SetProperty$09 (propName, propValue) {
    $IM03().Call(this.get_Properties(), null, propName, propValue);
    return this;
  };

  function TestCaseData_SetProperty$0A (propName, propValue) {
    $IM03().Call(this.get_Properties(), null, propName, propValue);
    return this;
  };

  function TestCaseData_Throws$0B (exceptionType) {
    this.expectedExceptionType = exceptionType;
    this.expectedExceptionName = exceptionType.get_FullName();
    return this;
  };

  function TestCaseData_Throws$0C (exceptionName) {
    this.expectedExceptionName = exceptionName;
    return this;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.TestCaseData", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Object])), 
      TestCaseData__ctor$00
    )
      .Parameter(0, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      TestCaseData__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      TestCaseData__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.Object
        ]), 
      TestCaseData__ctor$03
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Arguments", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Object])), 
      TestCaseData_get_Arguments
    );

    $.Method({Static:false, Public:true }, "get_Categories", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.IList")), 
      TestCaseData_get_Categories
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Description", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseData_get_Description
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_ExpectedException", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Type")), 
      TestCaseData_get_ExpectedException
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_ExpectedExceptionName", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseData_get_ExpectedExceptionName
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Explicit", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestCaseData_get_Explicit
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_HasExpectedResult", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestCaseData_get_HasExpectedResult
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Ignored", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestCaseData_get_Ignored
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_IgnoreReason", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseData_get_IgnoreReason
    );

    $.Method({Static:false, Public:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.IDictionary")), 
      TestCaseData_get_Properties
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Result", 
      JSIL.MethodSignature.Return($.Object), 
      TestCaseData_get_Result
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_TestName", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseData_get_TestName
    );

    $.Method({Static:false, Public:true }, "Ignore", 
      JSIL.MethodSignature.Return($.Type), 
      TestCaseData_Ignore$04
    );

    $.Method({Static:false, Public:true }, "Ignore", 
      new JSIL.MethodSignature($.Type, [$.String]), 
      TestCaseData_Ignore$05
    );

    $.Method({Static:false, Public:true }, "MakeExplicit", 
      JSIL.MethodSignature.Return($.Type), 
      TestCaseData_MakeExplicit$06
    );

    $.Method({Static:false, Public:true }, "MakeExplicit", 
      new JSIL.MethodSignature($.Type, [$.String]), 
      TestCaseData_MakeExplicit$07
    );

    $.Method({Static:false, Public:true }, "Returns", 
      new JSIL.MethodSignature($.Type, [$.Object]), 
      TestCaseData_Returns
    );

    $.Method({Static:false, Public:true }, "SetCategory", 
      new JSIL.MethodSignature($.Type, [$.String]), 
      TestCaseData_SetCategory
    );

    $.Method({Static:false, Public:true }, "SetDescription", 
      new JSIL.MethodSignature($.Type, [$.String]), 
      TestCaseData_SetDescription
    );

    $.Method({Static:false, Public:true }, "SetName", 
      new JSIL.MethodSignature($.Type, [$.String]), 
      TestCaseData_SetName
    );

    $.Method({Static:false, Public:true }, "SetProperty", 
      new JSIL.MethodSignature($.Type, [$.String, $.String]), 
      TestCaseData_SetProperty$08
    );

    $.Method({Static:false, Public:true }, "SetProperty", 
      new JSIL.MethodSignature($.Type, [$.String, $.Int32]), 
      TestCaseData_SetProperty$09
    );

    $.Method({Static:false, Public:true }, "SetProperty", 
      new JSIL.MethodSignature($.Type, [$.String, $.Double]), 
      TestCaseData_SetProperty$0A
    );

    $.Method({Static:false, Public:true }, "Throws", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Type")]), 
      TestCaseData_Throws$0B
    );

    $.Method({Static:false, Public:true }, "Throws", 
      new JSIL.MethodSignature($.Type, [$.String]), 
      TestCaseData_Throws$0C
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "CATEGORIES", $.String, "_CATEGORIES"); 
    $.Field({Static:false, Public:false}, "$arguments", $jsilcore.TypeRef("System.Array", [$.Object])); 
    $.Field({Static:false, Public:false}, "expectedResult", $.Object); 
    $.Field({Static:false, Public:false}, "hasExpectedResult", $.Boolean); 
    $.Field({Static:false, Public:false}, "expectedExceptionType", $asm0A.TypeRef("System.Type")); 
    $.Field({Static:false, Public:false}, "expectedExceptionName", $.String); 
    $.Field({Static:false, Public:false}, "testName", $.String); 
    $.Field({Static:false, Public:false}, "description", $.String); 
    $.Field({Static:false, Public:false}, "properties", $asm0A.TypeRef("System.Collections.IDictionary")); 
    $.Field({Static:false, Public:false}, "isIgnored", $.Boolean); 
    $.Field({Static:false, Public:false}, "isExplicit", $.Boolean); 
    $.Field({Static:false, Public:false}, "ignoreReason", $.String); 
    function TestCaseData__cctor () {
      $thisType.CATEGORIES = "_CATEGORIES";
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      TestCaseData__cctor
    );

    $.Property({Static:false, Public:true , Virtual:true }, "Arguments", $jsilcore.TypeRef("System.Array", [$.Object]));

    $.Property({Static:false, Public:true , Virtual:true }, "Result", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "HasExpectedResult", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "ExpectedException", $asm0A.TypeRef("System.Type"));

    $.Property({Static:false, Public:true , Virtual:true }, "ExpectedExceptionName", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "TestName", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "Description", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "Ignored", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Explicit", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "IgnoreReason", $.String);

    $.Property({Static:false, Public:true }, "Categories", $asm0A.TypeRef("System.Collections.IList"));

    $.Property({Static:false, Public:true }, "Properties", $asm0A.TypeRef("System.Collections.IDictionary"));

    $.ImplementInterfaces(
      /* 0 */ $asm0B.TypeRef("NUnit.Framework.ITestCaseData")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.TestContext */ 

(function TestContext$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Runtime.Remoting.Messaging.CallContext)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.TestContext_ResultAdapter)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.TestContext_TestAdapter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.get_Item)) ();
  };

  function TestContext__ctor (context) {
    this._context = context;
  };

  function TestContext_get_CurrentContext () {
    return new $thisType($T00().$Cast($T01().GetData("NUnit.Framework.TestContext")));
  };

  function TestContext_get_Result () {
    if (this._result === null) {
      this._result = new ($T02())(this._context);
    }
    return this._result;
  };

  function TestContext_get_Test () {
    if (this._test === null) {
      this._test = new ($T03())(this._context);
    }
    return this._test;
  };

  function TestContext_get_TestDirectory () {
    return $T04().$Cast($IM00().Call(this._context, null, "TestDirectory"));
  };

  function TestContext_get_WorkDirectory () {
    return $T04().$Cast($IM00().Call(this._context, null, "WorkDirectory"));
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.TestContext", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IDictionary")), 
      TestContext__ctor
    );

    $.Method({Static:true , Public:true }, "get_CurrentContext", 
      JSIL.MethodSignature.Return($.Type), 
      TestContext_get_CurrentContext
    );

    $.Method({Static:false, Public:true }, "get_Result", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.TestContext+ResultAdapter")), 
      TestContext_get_Result
    );

    $.Method({Static:false, Public:true }, "get_Test", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.TestContext+TestAdapter")), 
      TestContext_get_Test
    );

    $.Method({Static:false, Public:true }, "get_TestDirectory", 
      JSIL.MethodSignature.Return($.String), 
      TestContext_get_TestDirectory
    );

    $.Method({Static:false, Public:true }, "get_WorkDirectory", 
      JSIL.MethodSignature.Return($.String), 
      TestContext_get_WorkDirectory
    );

    $.Constant({Static:true , Public:false}, "contextKey", "NUnit.Framework.TestContext"); 
    $.Constant({Static:true , Public:false}, "stateKey", "Result.State"); 
    $.Field({Static:false, Public:false}, "_context", $asm0A.TypeRef("System.Collections.IDictionary")); 
    $.Field({Static:false, Public:false}, "_test", $asm0B.TypeRef("NUnit.Framework.TestContext+TestAdapter")); 
    $.Field({Static:false, Public:false}, "_result", $asm0B.TypeRef("NUnit.Framework.TestContext+ResultAdapter")); 
    $.Property({Static:true , Public:true }, "CurrentContext", $.Type);

    $.Property({Static:false, Public:true }, "Test", $asm0B.TypeRef("NUnit.Framework.TestContext+TestAdapter"));

    $.Property({Static:false, Public:true }, "Result", $asm0B.TypeRef("NUnit.Framework.TestContext+ResultAdapter"));

    $.Property({Static:false, Public:true }, "TestDirectory", $.String);

    $.Property({Static:false, Public:true }, "WorkDirectory", $.String);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.TestContext+TestAdapter */ 

(function TestAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.get_Item)) ();
  };

  function TestAdapter__ctor (context) {
    this._context = context;
  };

  function TestAdapter_get_FullName () {
    return $T01().$As($IM00().Call(this._context, null, "Test.FullName"));
  };

  function TestAdapter_get_Name () {
    return $T01().$As($IM00().Call(this._context, null, "Test.Name"));
  };

  function TestAdapter_get_Properties () {
    return $T00().$As($IM00().Call(this._context, null, "Test.Properties"));
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.TestContext+TestAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IDictionary")), 
      TestAdapter__ctor
    );

    $.Method({Static:false, Public:true }, "get_FullName", 
      JSIL.MethodSignature.Return($.String), 
      TestAdapter_get_FullName
    );

    $.Method({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String), 
      TestAdapter_get_Name
    );

    $.Method({Static:false, Public:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.IDictionary")), 
      TestAdapter_get_Properties
    );

    $.Field({Static:false, Public:false}, "_context", $asm0A.TypeRef("System.Collections.IDictionary")); 
    $.Property({Static:false, Public:true }, "Name", $.String);

    $.Property({Static:false, Public:true }, "FullName", $.String);

    $.Property({Static:false, Public:true }, "Properties", $asm0A.TypeRef("System.Collections.IDictionary"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.TestContext+ResultAdapter */ 

(function ResultAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.TestState)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.TestStatus)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.get_Item)) ();
  };

  function ResultAdapter__ctor (context) {
    this._context = context;
  };

  function ResultAdapter_get_State () {
    return $T01().$Cast($IM00().Call(this._context, null, "Result.State"));
  };

  function ResultAdapter_get_Status () {
    switch ((this.get_State()).valueOf()) {
      default: 
      case 0: 
        var result = $T02().Inconclusive;
        break;

      case 1: 
      case 2: 
      case 3: 
        result = $T02().Skipped;
        break;

      case 4: 
        result = $T02().Passed;
        break;

      case 5: 
      case 6: 
      case 7: 
        result = $T02().Failed;
        break;

    }
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.TestContext+ResultAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IDictionary")), 
      ResultAdapter__ctor
    );

    $.Method({Static:false, Public:true }, "get_State", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.TestState")), 
      ResultAdapter_get_State
    );

    $.Method({Static:false, Public:true }, "get_Status", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.TestStatus")), 
      ResultAdapter_get_Status
    );

    $.Field({Static:false, Public:false}, "_context", $asm0A.TypeRef("System.Collections.IDictionary")); 
    $.Property({Static:false, Public:true }, "State", $asm0B.TypeRef("NUnit.Framework.TestState"));

    $.Property({Static:false, Public:true }, "Status", $asm0B.TypeRef("NUnit.Framework.TestStatus"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.TestDetails */ 

(function TestDetails$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Reflection.MethodInfo)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };

  function TestDetails__ctor (fixture, method, fullName, type, isSuite) {
    this.TestDetails$Fixture$value = fixture;
    this.TestDetails$Method$value = method;
    this.TestDetails$FullName$value = fullName;
    this.TestDetails$Type$value = type;
    this.TestDetails$IsSuite$value = isSuite;
  };

  function TestDetails_get_Fixture () {
    return this.TestDetails$Fixture$value;
  };

  function TestDetails_get_FullName () {
    return this.TestDetails$FullName$value;
  };

  function TestDetails_get_IsSuite () {
    return this.TestDetails$IsSuite$value;
  };

  function TestDetails_get_Method () {
    return this.TestDetails$Method$value;
  };

  function TestDetails_get_Type () {
    return this.TestDetails$Type$value;
  };

  function TestDetails_set_Fixture (value) {
    this.TestDetails$Fixture$value = value;
  };

  function TestDetails_set_FullName (value) {
    this.TestDetails$FullName$value = value;
  };

  function TestDetails_set_IsSuite (value) {
    this.TestDetails$IsSuite$value = value;
  };

  function TestDetails_set_Method (value) {
    this.TestDetails$Method$value = value;
  };

  function TestDetails_set_Type (value) {
    this.TestDetails$Type$value = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.TestDetails", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 5, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Object, $asm0A.TypeRef("System.Reflection.MethodInfo"), 
          $.String, $.String, 
          $.Boolean
        ]), 
      TestDetails__ctor
    );

    $.Method({Static:false, Public:true }, "get_Fixture", 
      JSIL.MethodSignature.Return($.Object), 
      TestDetails_get_Fixture
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_FullName", 
      JSIL.MethodSignature.Return($.String), 
      TestDetails_get_FullName
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_IsSuite", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestDetails_get_IsSuite
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_Method", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Reflection.MethodInfo")), 
      TestDetails_get_Method
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_Type", 
      JSIL.MethodSignature.Return($.String), 
      TestDetails_get_Type
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_Fixture", 
      JSIL.MethodSignature.Action($.Object), 
      TestDetails_set_Fixture
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_FullName", 
      JSIL.MethodSignature.Action($.String), 
      TestDetails_set_FullName
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_IsSuite", 
      JSIL.MethodSignature.Action($.Boolean), 
      TestDetails_set_IsSuite
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_Method", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Reflection.MethodInfo")), 
      TestDetails_set_Method
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_Type", 
      JSIL.MethodSignature.Action($.String), 
      TestDetails_set_Type
    )
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:false, Public:false}, "TestDetails$Fixture$value", $.Object)
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "TestDetails$Method$value", $asm0A.TypeRef("System.Reflection.MethodInfo"))
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "TestDetails$FullName$value", $.String)
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "TestDetails$Type$value", $.String)
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "TestDetails$IsSuite$value", $.Boolean)
      .Attribute($asm0A.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Property({Static:false, Public:true }, "Fixture", $.Object);

    $.Property({Static:false, Public:true }, "Method", $asm0A.TypeRef("System.Reflection.MethodInfo"));

    $.Property({Static:false, Public:true }, "FullName", $.String);

    $.Property({Static:false, Public:true }, "Type", $.String);

    $.Property({Static:false, Public:true }, "IsSuite", $.Boolean);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum NUnit.Framework.TestState */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.TestState", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Inconclusive: 0, 
    NotRunnable: 1, 
    Skipped: 2, 
    Ignored: 3, 
    Success: 4, 
    Failure: 5, 
    Error: 6, 
    Cancelled: 7, 
  }
);

/* enum NUnit.Framework.TestStatus */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.TestStatus", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Inconclusive: 0, 
    Skipped: 1, 
    Passed: 2, 
    Failed: 3, 
  }
);

/* class NUnit.Framework.Text */ 

(function Text$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubstringConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EndsWithConstraint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.RegexConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StartsWithConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function Text__ctor () {
  };

  function Text_Contains (expected) {
    return new ($T01())(expected);
  };

  function Text_DoesNotContain (expected) {
    return $S00().Construct().get_Not().ContainsSubstring(expected);
  };

  function Text_DoesNotEndWith (expected) {
    return $S00().Construct().get_Not().EndsWith(expected);
  };

  function Text_DoesNotMatch (pattern) {
    return $S01().CallVirtual("Matches", null, $S00().Construct().get_Not(), pattern);
  };

  function Text_DoesNotStartWith (expected) {
    return $S00().Construct().get_Not().StartsWith(expected);
  };

  function Text_EndsWith (expected) {
    return new ($T03())(expected);
  };

  function Text_get_All () {
    return $S00().Construct().get_All();
  };

  function Text_Matches (pattern) {
    return new ($T04())(pattern);
  };

  function Text_StartsWith (expected) {
    return new ($T05())(expected);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Text", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Text__ctor
    );

    $.Method({Static:true , Public:true }, "Contains", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      Text_Contains
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Is.StringContaining"]; });

    $.Method({Static:true , Public:true }, "DoesNotContain", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      Text_DoesNotContain
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Is.Not.StringContaining"]; });

    $.Method({Static:true , Public:true }, "DoesNotEndWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      Text_DoesNotEndWith
    );

    $.Method({Static:true , Public:true }, "DoesNotMatch", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      Text_DoesNotMatch
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:true , Public:true }, "DoesNotStartWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      Text_DoesNotStartWith
    );

    $.Method({Static:true , Public:true }, "EndsWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      Text_EndsWith
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Is.StringEnding"]; });

    $.Method({Static:true , Public:true }, "get_All", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Text_get_All
    );

    $.Method({Static:true , Public:true }, "Matches", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      Text_Matches
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Is.StringMatching"]; });

    $.Method({Static:true , Public:true }, "StartsWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      Text_StartsWith
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Is.StringStarting"]; });

    $.Property({Static:true , Public:true }, "All", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"))
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Is.All"]; });

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Is class for string constraints"]; });

})();

/* class NUnit.Framework.Constraints.MessageWriter */ 

(function MessageWriter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.IO.StringWriter)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Globalization.CultureInfo)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.IFormatProvider")))) ();
  };

  function MessageWriter__ctor () {
    $S00().Call($T00().prototype, "_ctor", null, this, $T01().get_InvariantCulture());
  };

  function MessageWriter_WriteMessageLine$00 (message, args) {
    this.WriteMessageLine(0, message, args);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.IO.StringWriter"), 
      Name: "NUnit.Framework.Constraints.MessageWriter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      MessageWriter__ctor
    );

    $.Method({Static:false, Public:true }, "WriteMessageLine", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("System.Array", [$.Object])]), 
      MessageWriter_WriteMessageLine$00
    )
      .Parameter(1, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Property({Static:false, Public:true , Virtual:true }, "MaxLineLength", $.Int32);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.TextMessageWriter */ 

(function TextMessageWriter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Tolerance)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MsgUtils)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Array)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize(System.Array.Of($asm0A.System.Int32))) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.Char)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.DateTime)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0A.System.Globalization.CultureInfo)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0A.System.Decimal)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ToleranceMode)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0A.System.Single)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.Object")))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.Object")))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.String"), [$asm0A.TypeRef("System.Char"), $asm0A.TypeRef("System.Int32")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.Double")))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.Single")))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };

  function TextMessageWriter__ctor$00 () {
    this.maxLineLength = ($thisType.DEFAULT_LINE_LENGTH | 0);
    $T01().prototype._ctor.call(this);
  };

  function TextMessageWriter__ctor$01 (userMessage, args) {
    this.maxLineLength = ($thisType.DEFAULT_LINE_LENGTH | 0);
    $T01().prototype._ctor.call(this);
    if (!((userMessage === null) || !(userMessage != $T00().Empty))) {
      this.WriteMessageLine(userMessage, args);
    }
  };

  function TextMessageWriter_DisplayDifferences$02 (constraint) {
    $S00().CallVirtual("WriteExpectedLine", null, this, constraint);
    $S01().CallVirtual("WriteActualLine", null, this, constraint);
  };

  function TextMessageWriter_DisplayDifferences$03 (expected, actual) {
    $S02().CallVirtual("WriteExpectedLine", null, this, expected);
    $S03().CallVirtual("WriteActualLine", null, this, actual);
  };

  function TextMessageWriter_DisplayDifferences$04 (expected, actual, tolerance) {
    this.WriteExpectedLine(expected, tolerance);
    $S03().CallVirtual("WriteActualLine", null, this, actual);
  };

  function TextMessageWriter_DisplayStringDifferences ($expected, $actual, mismatch, ignoreCase, clipping) {
    var actual = new JSIL.BoxedVariable($actual);
    var expected = new JSIL.BoxedVariable($expected);
    var maxDisplayLength = (((((this.get_MaxLineLength() | 0) - ($thisType.PrefixLength | 0)) | 0) - 2) | 0);
    if (clipping) {
      $T08().ClipExpectedAndActual(/* ref */ expected, /* ref */ actual, maxDisplayLength, mismatch);
    }
    expected.set($T08().EscapeControlChars(expected.get()));
    actual.set($T08().EscapeControlChars(actual.get()));
    mismatch = ($T08().FindMismatchPosition(expected.get(), actual.get(), 0, ignoreCase) | 0);
    $S04().CallVirtual("Write", null, this, $thisType.Pfx_Expected);
    this.WriteExpectedValue(expected.get());
    if (ignoreCase) {
      this.WriteModifier("ignoring case");
    }
    this.WriteLine();
    $S03().CallVirtual("WriteActualLine", null, this, actual.get());
    if ((mismatch | 0) >= 0) {
      this.WriteCaretLine(mismatch);
    }
  };

  function TextMessageWriter_get_MaxLineLength () {
    return this.maxLineLength;
  };

  function TextMessageWriter_set_MaxLineLength (value) {
    this.maxLineLength = (value | 0);
  };

  function TextMessageWriter_WriteActualLine$05 (constraint) {
    $S04().CallVirtual("Write", null, this, $thisType.Pfx_Actual);
    constraint.WriteActualValueTo(this);
    this.WriteLine();
  };

  function TextMessageWriter_WriteActualLine$06 (actual) {
    $S04().CallVirtual("Write", null, this, $thisType.Pfx_Actual);
    this.WriteActualValue(actual);
    this.WriteLine();
  };

  function TextMessageWriter_WriteActualValue (actual) {
    this.WriteValue(actual);
  };

  function TextMessageWriter_WriteArray (array) {
    if ((array.length | 0) === 0) {
      $S04().CallVirtual("Write", null, this, $thisType.Fmt_EmptyCollection);
    } else {
      var rank = (array.get_Rank() | 0);
      var array2 = JSIL.Array.New($T06(), rank);
      var num = 1;
      var i = rank;

      while ((i = ((i - 1) | 0)) >= 0) {
        num = array2[i] = Math.imul(num, array.GetLength(i));
      }
      var num2 = 0;
      var enumerator = (JSIL.GetEnumerator(array));
      try {

        while ($IM00().Call(enumerator, null)) {
          var current = $IM01().Call(enumerator, null);
          if (num2 > 0) {
            $S04().CallVirtual("Write", null, this, ", ");
          }
          var flag = false;

          for (i = 0; i < rank; i = ((i + 1) | 0)) {
            flag = flag || 
            (((num2 % (array2[i] | 0)) | 0) === 0);
            if (flag) {
              $S04().CallVirtual("Write", null, this, "< ");
            }
          }
          this.WriteValue(current);
          num2 = ((num2 + 1) | 0);
          var flag2 = false;

          for (i = 0; i < rank; i = ((i + 1) | 0)) {
            flag2 = flag2 || 
            (((num2 % (array2[i] | 0)) | 0) === 0);
            if (flag2) {
              $S04().CallVirtual("Write", null, this, " >");
            }
          }
        }
      } finally {
        var disposable = $T0D().$As(enumerator);
        if (disposable !== null) {
          $IM02().Call(disposable, null);
        }
      }
    }
  };

  function TextMessageWriter_WriteCaretLine (mismatch) {
    $S05().CallVirtual("WriteLine", null, this, "  {0}^", $S06().Construct("-", ((((((($thisType.PrefixLength | 0) + (mismatch | 0)) | 0) - 2) | 0) + 1) | 0)));
  };

  function TextMessageWriter_WriteChar (c) {
    $S07().CallVirtual("Write", null, this, $thisType.Fmt_Char, c);
  };

  function TextMessageWriter_WriteCollectionElements (collection, start, max) {
    var $temp00;
    var num = 0;
    var num2 = 0;
    var enumerator = $IM03().Call(collection, null);
    try {

    $loop0: 
      while ($IM00().Call(enumerator, null)) {
        var current = $IM01().Call(enumerator, null);
        if ((($temp00 = num2, 
            num2 = ((num2 + 1) | 0), 
            $temp00) | 0) >= (start | 0)) {
          if ((num = ((num + 1) | 0)) > (max | 0)) {
            break $loop0;
          }
          $S04().CallVirtual("Write", null, this, (
              (num === 1)
                 ? "< "
                 : ", ")
          );
          this.WriteValue(current);
        }
      }
    } finally {
      var disposable = $T0D().$As(enumerator);
      if (disposable !== null) {
        $IM02().Call(disposable, null);
      }
    }
    if (num === 0) {
      $S04().CallVirtual("Write", null, this, $thisType.Fmt_EmptyCollection);
    } else {
      if (num > (max | 0)) {
        $S04().CallVirtual("Write", null, this, "...");
      }
      $S04().CallVirtual("Write", null, this, " >");
    }
  };

  function TextMessageWriter_WriteConnector (connector) {
    $S07().CallVirtual("Write", null, this, $thisType.Fmt_Connector, connector);
  };

  function TextMessageWriter_WriteDateTime (dt) {
    $S04().CallVirtual("Write", null, this, dt.ToString($thisType.Fmt_DateTime, $T11().get_InvariantCulture()));
  };

  function TextMessageWriter_WriteDecimal (d) {
    $S04().CallVirtual("Write", null, this, JSIL.ConcatString(JSIL.NumberToFormattedString(d, null, "G29", $T11().get_InvariantCulture()), "m"));
  };

  function TextMessageWriter_WriteDouble (d) {
    if (!(!(isNaN(d)) && !$T13().IsInfinity(d))) {
      $S08().CallVirtual("Write", null, this, d);
    } else {
      var text = (JSIL.NumberToFormattedString(d, null, "G17", $T11().get_InvariantCulture()));
      if ((text.indexOf(".")) > 0) {
        $S04().CallVirtual("Write", null, this, JSIL.ConcatString(text, "d"));
      } else {
        $S04().CallVirtual("Write", null, this, JSIL.ConcatString(text, ".0d"));
      }
    }
  };

  function TextMessageWriter_WriteExpectedLine$07 (constraint) {
    $S04().CallVirtual("Write", null, this, $thisType.Pfx_Expected);
    constraint.WriteDescriptionTo(this);
    this.WriteLine();
  };

  function TextMessageWriter_WriteExpectedLine$08 (expected) {
    this.WriteExpectedLine(expected, null);
  };

  function TextMessageWriter_WriteExpectedLine$09 (expected, tolerance) {
    $S04().CallVirtual("Write", null, this, $thisType.Pfx_Expected);
    this.WriteExpectedValue(expected);
    if (!((tolerance === null) || tolerance.get_IsEmpty())) {
      this.WriteConnector("+/-");
      this.WriteExpectedValue(tolerance.get_Value());
      if (tolerance.get_Mode() !== $T14().Linear) {
        $S07().CallVirtual("Write", null, this, " {0}", tolerance.get_Mode());
      }
    }
    this.WriteLine();
  };

  function TextMessageWriter_WriteExpectedValue (expected) {
    this.WriteValue(expected);
  };

  function TextMessageWriter_WriteFloat (f) {
    if (!(!(isNaN(f)) && !$T15().IsInfinity(f))) {
      $S09().CallVirtual("Write", null, this, f);
    } else {
      var text = (JSIL.NumberToFormattedString(f, null, "G9", $T11().get_InvariantCulture()));
      if ((text.indexOf(".")) > 0) {
        $S04().CallVirtual("Write", null, this, JSIL.ConcatString(text, "f"));
      } else {
        $S04().CallVirtual("Write", null, this, JSIL.ConcatString(text, ".0f"));
      }
    }
  };

  function TextMessageWriter_WriteMessageLine$0A (level, message, args) {
    var $temp00;
    if (message !== null) {

      while ((($temp00 = (level | 0), 
          level = (((level | 0) - 1) | 0), 
          $temp00) | 0) >= 0) {
        $S04().CallVirtual("Write", null, this, "  ");
      }
      if (!((args === null) || ((args.length | 0) <= 0))) {
        message = $T00().Format(message, args);
      }
      $S0A().CallVirtual("WriteLine", null, this, message);
    }
  };

  function TextMessageWriter_WriteModifier (modifier) {
    $S07().CallVirtual("Write", null, this, $thisType.Fmt_Modifier, modifier);
  };

  function TextMessageWriter_WritePredicate (predicate) {
    $S07().CallVirtual("Write", null, this, $thisType.Fmt_Predicate, predicate);
  };

  function TextMessageWriter_WriteString (s) {
    if (s == $T00().Empty) {
      $S04().CallVirtual("Write", null, this, $thisType.Fmt_EmptyString);
    } else {
      $S07().CallVirtual("Write", null, this, $thisType.Fmt_String, s);
    }
  };

  function TextMessageWriter_WriteValue (val) {
    if (val === null) {
      $S04().CallVirtual("Write", null, this, $thisType.Fmt_Null);
    } else if ((JSIL.GetType(val)).get_IsArray()) {
      this.WriteArray($T0A().$Cast(val));
    } else if ($T00().$Is(val)) {
      this.WriteString($T00().$Cast(val));
    } else if ($T0F().$Is(val)) {
      this.WriteCollectionElements($T0F().$Cast(val), 0, 10);
    } else if ($T0E().$Is(val)) {
      this.WriteChar($T0E().$Cast(val));
    } else if ($T13().$Is(val)) {
      this.WriteDouble($T13().$Cast(val));
    } else if ($T15().$Is(val)) {
      this.WriteFloat($T15().$Cast(val));
    } else if ($T12().$Is(val)) {
      this.WriteDecimal($T12().$Cast(val));
    } else if ($T10().$Is(val)) {
      this.WriteDateTime($T10().$Cast(val).MemberwiseClone());
    } else if ((JSIL.GetType(val)).get_IsValueType()) {
      $S07().CallVirtual("Write", null, this, $thisType.Fmt_ValueType, val);
    } else {
      $S07().CallVirtual("Write", null, this, $thisType.Fmt_Default, val);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), 
      Name: "NUnit.Framework.TextMessageWriter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TextMessageWriter__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("System.Array", [$.Object])]), 
      TextMessageWriter__ctor$01
    )
      .Parameter(1, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true , Virtual:true }, "DisplayDifferences", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      TextMessageWriter_DisplayDifferences$02
    );

    $.Method({Static:false, Public:true , Virtual:true }, "DisplayDifferences", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      TextMessageWriter_DisplayDifferences$03
    );

    $.Method({Static:false, Public:true , Virtual:true }, "DisplayDifferences", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
        ]), 
      TextMessageWriter_DisplayDifferences$04
    );

    $.Method({Static:false, Public:true , Virtual:true }, "DisplayStringDifferences", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.Int32, $.Boolean, 
          $.Boolean
        ]), 
      TextMessageWriter_DisplayStringDifferences
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_MaxLineLength", 
      JSIL.MethodSignature.Return($.Int32), 
      TextMessageWriter_get_MaxLineLength
    );

    $.Method({Static:false, Public:true , Virtual:true }, "set_MaxLineLength", 
      JSIL.MethodSignature.Action($.Int32), 
      TextMessageWriter_set_MaxLineLength
    );

    $.Method({Static:false, Public:false}, "WriteActualLine", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      TextMessageWriter_WriteActualLine$05
    );

    $.Method({Static:false, Public:false}, "WriteActualLine", 
      JSIL.MethodSignature.Action($.Object), 
      TextMessageWriter_WriteActualLine$06
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValue", 
      JSIL.MethodSignature.Action($.Object), 
      TextMessageWriter_WriteActualValue
    );

    $.Method({Static:false, Public:false}, "WriteArray", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Array")), 
      TextMessageWriter_WriteArray
    );

    $.Method({Static:false, Public:false}, "WriteCaretLine", 
      JSIL.MethodSignature.Action($.Int32), 
      TextMessageWriter_WriteCaretLine
    );

    $.Method({Static:false, Public:false}, "WriteChar", 
      JSIL.MethodSignature.Action($.Char), 
      TextMessageWriter_WriteChar
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteCollectionElements", 
      new JSIL.MethodSignature(null, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.Int32, 
          $.Int32
        ]), 
      TextMessageWriter_WriteCollectionElements
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteConnector", 
      JSIL.MethodSignature.Action($.String), 
      TextMessageWriter_WriteConnector
    );

    $.Method({Static:false, Public:false}, "WriteDateTime", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.DateTime")), 
      TextMessageWriter_WriteDateTime
    );

    $.Method({Static:false, Public:false}, "WriteDecimal", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Decimal")), 
      TextMessageWriter_WriteDecimal
    );

    $.Method({Static:false, Public:false}, "WriteDouble", 
      JSIL.MethodSignature.Action($.Double), 
      TextMessageWriter_WriteDouble
    );

    $.Method({Static:false, Public:false}, "WriteExpectedLine", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      TextMessageWriter_WriteExpectedLine$07
    );

    $.Method({Static:false, Public:false}, "WriteExpectedLine", 
      JSIL.MethodSignature.Action($.Object), 
      TextMessageWriter_WriteExpectedLine$08
    );

    $.Method({Static:false, Public:false}, "WriteExpectedLine", 
      new JSIL.MethodSignature(null, [$.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")]), 
      TextMessageWriter_WriteExpectedLine$09
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteExpectedValue", 
      JSIL.MethodSignature.Action($.Object), 
      TextMessageWriter_WriteExpectedValue
    );

    $.Method({Static:false, Public:false}, "WriteFloat", 
      JSIL.MethodSignature.Action($.Single), 
      TextMessageWriter_WriteFloat
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteMessageLine", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.String, 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ]), 
      TextMessageWriter_WriteMessageLine$0A
    )
      .Parameter(2, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true , Virtual:true }, "WriteModifier", 
      JSIL.MethodSignature.Action($.String), 
      TextMessageWriter_WriteModifier
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WritePredicate", 
      JSIL.MethodSignature.Action($.String), 
      TextMessageWriter_WritePredicate
    );

    $.Method({Static:false, Public:false}, "WriteString", 
      JSIL.MethodSignature.Action($.String), 
      TextMessageWriter_WriteString
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteValue", 
      JSIL.MethodSignature.Action($.Object), 
      TextMessageWriter_WriteValue
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "DEFAULT_LINE_LENGTH", $.Int32, 78); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Pfx_Expected", $.String, "  Expected: "); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Pfx_Actual", $.String, "  But was:  "); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "PrefixLength", $.Int32); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_Connector", $.String, " {0} "); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_Predicate", $.String, "{0} "); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_Modifier", $.String, ", {0}"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_Null", $.String, "null"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_EmptyString", $.String, "<string.Empty>"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_EmptyCollection", $.String, "<empty>"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_String", $.String, "\"{0}\""); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_Char", $.String, "'{0}'"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_DateTime", $.String, "yyyy-MM-dd HH:mm:ss.fff"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_ValueType", $.String, "{0}"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "Fmt_Default", $.String, "<{0}>"); 
    $.Field({Static:false, Public:false}, "maxLineLength", $.Int32); 
    function TextMessageWriter__cctor () {
      $thisType.DEFAULT_LINE_LENGTH = 78;
      $thisType.Pfx_Expected = "  Expected: ";
      $thisType.Pfx_Actual = "  But was:  ";
      $thisType.PrefixLength = ($thisType.Pfx_Expected.length | 0);
      $thisType.Fmt_Connector = " {0} ";
      $thisType.Fmt_Predicate = "{0} ";
      $thisType.Fmt_Modifier = ", {0}";
      $thisType.Fmt_Null = "null";
      $thisType.Fmt_EmptyString = "<string.Empty>";
      $thisType.Fmt_EmptyCollection = "<empty>";
      $thisType.Fmt_String = "\"{0}\"";
      $thisType.Fmt_Char = "'{0}'";
      $thisType.Fmt_DateTime = "yyyy-MM-dd HH:mm:ss.fff";
      $thisType.Fmt_ValueType = "{0}";
      $thisType.Fmt_Default = "<{0}>";
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      TextMessageWriter__cctor
    );

    $.Property({Static:false, Public:true , Virtual:true }, "MaxLineLength", $.Int32);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Throws */ 

(function Throws$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpressionBase)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ThrowsOperator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ThrowsNothingConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Reflection.TargetInvocationException)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.SelfResolvingOperator")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), null))) ();
  };

  function Throws__ctor () {
  };

  function Throws_get_ArgumentException () {
    return $thisType.TypeOf($T00().__Type__);
  };

  function Throws_get_Exception () {
    return $S00().CallVirtual("Append", null, $S01().Construct(), new ($T03())());
  };

  function Throws_get_InnerException () {
    return $thisType.get_Exception().get_InnerException();
  };

  function Throws_get_InvalidOperationException () {
    return $thisType.TypeOf($T04().__Type__);
  };

  function Throws_get_Nothing () {
    return new ($T05())();
  };

  function Throws_get_TargetInvocationException () {
    return $thisType.TypeOf($T06().__Type__);
  };

  function Throws_InstanceOf (expectedType) {
    return $thisType.get_Exception().InstanceOf(expectedType);
  };

  function Throws_InstanceOf$b1 (T) {
    return $thisType.InstanceOf(T);
  };

  function Throws_TypeOf (expectedType) {
    return $thisType.get_Exception().TypeOf(expectedType);
  };

  function Throws_TypeOf$b1 (T) {
    return $thisType.TypeOf(T);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Throws", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Throws__ctor
    );

    $.Method({Static:true , Public:true }, "get_ArgumentException", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint")), 
      Throws_get_ArgumentException
    );

    $.Method({Static:true , Public:true }, "get_Exception", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      Throws_get_Exception
    );

    $.Method({Static:true , Public:true }, "get_InnerException", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      Throws_get_InnerException
    );

    $.Method({Static:true , Public:true }, "get_InvalidOperationException", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint")), 
      Throws_get_InvalidOperationException
    );

    $.Method({Static:true , Public:true }, "get_Nothing", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ThrowsNothingConstraint")), 
      Throws_get_Nothing
    );

    $.Method({Static:true , Public:true }, "get_TargetInvocationException", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint")), 
      Throws_get_TargetInvocationException
    );

    $.Method({Static:true , Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      Throws_InstanceOf
    );

    $.Method({Static:true , Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), null, ["T"]), 
      Throws_InstanceOf$b1
    );

    $.Method({Static:true , Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      Throws_TypeOf
    );

    $.Method({Static:true , Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), null, ["T"]), 
      Throws_TypeOf$b1
    );

    $.Property({Static:true , Public:true }, "Exception", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:true , Public:true }, "InnerException", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:true , Public:true }, "TargetInvocationException", $asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"));

    $.Property({Static:true , Public:true }, "ArgumentException", $asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"));

    $.Property({Static:true , Public:true }, "InvalidOperationException", $asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"));

    $.Property({Static:true , Public:true }, "Nothing", $asm0B.TypeRef("NUnit.Framework.Constraints.ThrowsNothingConstraint"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.CategoryAttribute */ 

(function CategoryAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Int32)) ();
  };

  function CategoryAttribute__ctor$00 (name) {
    $T01().prototype._ctor.call(this);
    this.categoryName = (name.trim());
  };

  function CategoryAttribute__ctor$01 () {
    $T01().prototype._ctor.call(this);
    this.categoryName = (JSIL.GetType(this)).get_Name();
    if (System.String.EndsWith(this.categoryName, "Attribute")) {
      this.categoryName = (this.categoryName.substr(0, (((this.categoryName.length | 0) - 9) | 0)));
    }
  };

  function CategoryAttribute_get_Name () {
    return this.categoryName;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.CategoryAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      CategoryAttribute__ctor$00
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      CategoryAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String), 
      CategoryAttribute_get_Name
    );

    $.Field({Static:false, Public:false}, "categoryName", $.String); 
    $.Property({Static:false, Public:true }, "Name", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.DatapointAttribute */ 

(function DatapointAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function DatapointAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.DatapointAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      DatapointAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Field]; });

})();

/* class NUnit.Framework.DatapointsAttribute */ 

(function DatapointsAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function DatapointsAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.DatapointsAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      DatapointsAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Field", "Method", "Property")]; });

})();

/* class NUnit.Framework.DescriptionAttribute */ 

(function DescriptionAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function DescriptionAttribute__ctor (description) {
    $T01().prototype._ctor.call(this);
    this.description = description;
  };

  function DescriptionAttribute_get_Description () {
    return this.description;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.DescriptionAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      DescriptionAttribute__ctor
    );

    $.Method({Static:false, Public:true }, "get_Description", 
      JSIL.MethodSignature.Return($.String), 
      DescriptionAttribute_get_Description
    );

    $.Field({Static:false, Public:false}, "description", $.String); 
    $.Property({Static:false, Public:true }, "Description", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* enum NUnit.Framework.MessageMatch */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.MessageMatch", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Exact: 0, 
    Contains: 1, 
    Regex: 2, 
    StartsWith: 3, 
  }
);

/* class NUnit.Framework.ExpectedExceptionAttribute */ 

(function ExpectedExceptionAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.MessageMatch)) ();
  };

  function ExpectedExceptionAttribute__ctor$00 () {
    $T00().prototype._ctor.call(this);
  };

  function ExpectedExceptionAttribute__ctor$01 (exceptionType) {
    $T00().prototype._ctor.call(this);
    this.expectedException = exceptionType;
    this.expectedExceptionName = exceptionType.get_FullName();
  };

  function ExpectedExceptionAttribute__ctor$02 (exceptionName) {
    $T00().prototype._ctor.call(this);
    this.expectedExceptionName = exceptionName;
  };

  function ExpectedExceptionAttribute_get_ExpectedException () {
    return this.expectedException;
  };

  function ExpectedExceptionAttribute_get_ExpectedExceptionName () {
    return this.expectedExceptionName;
  };

  function ExpectedExceptionAttribute_get_ExpectedMessage () {
    return this.expectedMessage;
  };

  function ExpectedExceptionAttribute_get_Handler () {
    return this.handler;
  };

  function ExpectedExceptionAttribute_get_MatchType () {
    return this.matchType;
  };

  function ExpectedExceptionAttribute_get_UserMessage () {
    return this.userMessage;
  };

  function ExpectedExceptionAttribute_set_ExpectedException (value) {
    this.expectedException = value;
    this.expectedExceptionName = (this.expectedException).get_FullName();
  };

  function ExpectedExceptionAttribute_set_ExpectedExceptionName (value) {
    this.expectedExceptionName = value;
  };

  function ExpectedExceptionAttribute_set_ExpectedMessage (value) {
    this.expectedMessage = value;
  };

  function ExpectedExceptionAttribute_set_Handler (value) {
    this.handler = value;
  };

  function ExpectedExceptionAttribute_set_MatchType (value) {
    this.matchType = value;
  };

  function ExpectedExceptionAttribute_set_UserMessage (value) {
    this.userMessage = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.ExpectedExceptionAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ExpectedExceptionAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      ExpectedExceptionAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      ExpectedExceptionAttribute__ctor$02
    );

    $.Method({Static:false, Public:true }, "get_ExpectedException", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Type")), 
      ExpectedExceptionAttribute_get_ExpectedException
    );

    $.Method({Static:false, Public:true }, "get_ExpectedExceptionName", 
      JSIL.MethodSignature.Return($.String), 
      ExpectedExceptionAttribute_get_ExpectedExceptionName
    );

    $.Method({Static:false, Public:true }, "get_ExpectedMessage", 
      JSIL.MethodSignature.Return($.String), 
      ExpectedExceptionAttribute_get_ExpectedMessage
    );

    $.Method({Static:false, Public:true }, "get_Handler", 
      JSIL.MethodSignature.Return($.String), 
      ExpectedExceptionAttribute_get_Handler
    );

    $.Method({Static:false, Public:true }, "get_MatchType", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.MessageMatch")), 
      ExpectedExceptionAttribute_get_MatchType
    );

    $.Method({Static:false, Public:true }, "get_UserMessage", 
      JSIL.MethodSignature.Return($.String), 
      ExpectedExceptionAttribute_get_UserMessage
    );

    $.Method({Static:false, Public:true }, "set_ExpectedException", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      ExpectedExceptionAttribute_set_ExpectedException
    );

    $.Method({Static:false, Public:true }, "set_ExpectedExceptionName", 
      JSIL.MethodSignature.Action($.String), 
      ExpectedExceptionAttribute_set_ExpectedExceptionName
    );

    $.Method({Static:false, Public:true }, "set_ExpectedMessage", 
      JSIL.MethodSignature.Action($.String), 
      ExpectedExceptionAttribute_set_ExpectedMessage
    );

    $.Method({Static:false, Public:true }, "set_Handler", 
      JSIL.MethodSignature.Action($.String), 
      ExpectedExceptionAttribute_set_Handler
    );

    $.Method({Static:false, Public:true }, "set_MatchType", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.MessageMatch")), 
      ExpectedExceptionAttribute_set_MatchType
    );

    $.Method({Static:false, Public:true }, "set_UserMessage", 
      JSIL.MethodSignature.Action($.String), 
      ExpectedExceptionAttribute_set_UserMessage
    );

    $.Field({Static:false, Public:false}, "expectedException", $asm0A.TypeRef("System.Type")); 
    $.Field({Static:false, Public:false}, "expectedExceptionName", $.String); 
    $.Field({Static:false, Public:false}, "expectedMessage", $.String); 
    $.Field({Static:false, Public:false}, "matchType", $asm0B.TypeRef("NUnit.Framework.MessageMatch")); 
    $.Field({Static:false, Public:false}, "userMessage", $.String); 
    $.Field({Static:false, Public:false}, "handler", $.String); 
    $.Property({Static:false, Public:true }, "ExpectedException", $asm0A.TypeRef("System.Type"));

    $.Property({Static:false, Public:true }, "ExpectedExceptionName", $.String);

    $.Property({Static:false, Public:true }, "ExpectedMessage", $.String);

    $.Property({Static:false, Public:true }, "UserMessage", $.String);

    $.Property({Static:false, Public:true }, "MatchType", $asm0B.TypeRef("NUnit.Framework.MessageMatch"));

    $.Property({Static:false, Public:true }, "Handler", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.ExplicitAttribute */ 

(function ExplicitAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };

  function ExplicitAttribute__ctor$00 () {
    $T00().prototype._ctor.call(this);
    this.reason = "";
  };

  function ExplicitAttribute__ctor$01 (reason) {
    $T00().prototype._ctor.call(this);
    this.reason = reason;
  };

  function ExplicitAttribute_get_Reason () {
    return this.reason;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.ExplicitAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ExplicitAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      ExplicitAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, "get_Reason", 
      JSIL.MethodSignature.Return($.String), 
      ExplicitAttribute_get_Reason
    );

    $.Field({Static:false, Public:false}, "reason", $.String); 
    $.Property({Static:false, Public:true }, "Reason", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.IgnoreAttribute */ 

(function IgnoreAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };

  function IgnoreAttribute__ctor$00 () {
    $T00().prototype._ctor.call(this);
    this.reason = "";
  };

  function IgnoreAttribute__ctor$01 (reason) {
    $T00().prototype._ctor.call(this);
    this.reason = reason;
  };

  function IgnoreAttribute_get_Reason () {
    return this.reason;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.IgnoreAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      IgnoreAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      IgnoreAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, "get_Reason", 
      JSIL.MethodSignature.Return($.String), 
      IgnoreAttribute_get_Reason
    );

    $.Field({Static:false, Public:false}, "reason", $.String); 
    $.Property({Static:false, Public:true }, "Reason", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.IncludeExcludeAttribute */ 

(function IncludeExcludeAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };

  function IncludeExcludeAttribute__ctor$00 () {
    $T00().prototype._ctor.call(this);
  };

  function IncludeExcludeAttribute__ctor$01 (include) {
    $T00().prototype._ctor.call(this);
    this.include = include;
  };

  function IncludeExcludeAttribute_get_Exclude () {
    return this.exclude;
  };

  function IncludeExcludeAttribute_get_Include () {
    return this.include;
  };

  function IncludeExcludeAttribute_get_Reason () {
    return this.reason;
  };

  function IncludeExcludeAttribute_set_Exclude (value) {
    this.exclude = value;
  };

  function IncludeExcludeAttribute_set_Include (value) {
    this.include = value;
  };

  function IncludeExcludeAttribute_set_Reason (value) {
    this.reason = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.IncludeExcludeAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      IncludeExcludeAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      IncludeExcludeAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, "get_Exclude", 
      JSIL.MethodSignature.Return($.String), 
      IncludeExcludeAttribute_get_Exclude
    );

    $.Method({Static:false, Public:true }, "get_Include", 
      JSIL.MethodSignature.Return($.String), 
      IncludeExcludeAttribute_get_Include
    );

    $.Method({Static:false, Public:true }, "get_Reason", 
      JSIL.MethodSignature.Return($.String), 
      IncludeExcludeAttribute_get_Reason
    );

    $.Method({Static:false, Public:true }, "set_Exclude", 
      JSIL.MethodSignature.Action($.String), 
      IncludeExcludeAttribute_set_Exclude
    );

    $.Method({Static:false, Public:true }, "set_Include", 
      JSIL.MethodSignature.Action($.String), 
      IncludeExcludeAttribute_set_Include
    );

    $.Method({Static:false, Public:true }, "set_Reason", 
      JSIL.MethodSignature.Action($.String), 
      IncludeExcludeAttribute_set_Reason
    );

    $.Field({Static:false, Public:false}, "include", $.String); 
    $.Field({Static:false, Public:false}, "exclude", $.String); 
    $.Field({Static:false, Public:false}, "reason", $.String); 
    $.Property({Static:false, Public:true }, "Include", $.String);

    $.Property({Static:false, Public:true }, "Exclude", $.String);

    $.Property({Static:false, Public:true }, "Reason", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.PlatformAttribute */ 

(function PlatformAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.IncludeExcludeAttribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };

  function PlatformAttribute__ctor$00 () {
    $T00().prototype._ctor.call(this);
  };

  function PlatformAttribute__ctor$01 (platforms) {
    $T00().prototype._ctor.call(this, platforms);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.IncludeExcludeAttribute"), 
      Name: "NUnit.Framework.PlatformAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      PlatformAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      PlatformAttribute__ctor$01
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.CultureAttribute */ 

(function CultureAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.IncludeExcludeAttribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };

  function CultureAttribute__ctor$00 () {
    $T00().prototype._ctor.call(this);
  };

  function CultureAttribute__ctor$01 (cultures) {
    $T00().prototype._ctor.call(this, cultures);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.IncludeExcludeAttribute"), 
      Name: "NUnit.Framework.CultureAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CultureAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      CultureAttribute__ctor$01
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.PropertyAttribute */ 

(function PropertyAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0D.System.Collections.Specialized.ListDictionary)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.TypeRef("System.Collections.Specialized.ListDictionary"), null))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.Add)) ();
  };

  function PropertyAttribute__ctor$00 (propertyName, propertyValue) {
    this.properties = $S00().Construct();
    $T02().prototype._ctor.call(this);
    $IM00().Call(this.properties, null, propertyName, propertyValue);
  };

  function PropertyAttribute__ctor$01 (propertyName, propertyValue) {
    this.properties = $S00().Construct();
    $T02().prototype._ctor.call(this);
    $IM00().Call(this.properties, null, propertyName, propertyValue);
  };

  function PropertyAttribute__ctor$02 (propertyName, propertyValue) {
    this.properties = $S00().Construct();
    $T02().prototype._ctor.call(this);
    $IM00().Call(this.properties, null, propertyName, propertyValue);
  };

  function PropertyAttribute__ctor$03 () {
    this.properties = $S00().Construct();
    $T02().prototype._ctor.call(this);
  };

  function PropertyAttribute__ctor$04 (propertyValue) {
    this.properties = $S00().Construct();
    $T02().prototype._ctor.call(this);
    var text = (JSIL.GetType(this)).get_Name();
    if (System.String.EndsWith(text, "Attribute")) {
      text = (text.substr(0, (((text.length | 0) - 9) | 0)));
    }
    $IM00().Call(this.properties, null, text, propertyValue);
  };

  function PropertyAttribute_get_Properties () {
    return this.properties;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.PropertyAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $.String]), 
      PropertyAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $.Int32]), 
      PropertyAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $.Double]), 
      PropertyAttribute__ctor$02
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      PropertyAttribute__ctor$03
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      PropertyAttribute__ctor$04
    );

    $.Method({Static:false, Public:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.IDictionary")), 
      PropertyAttribute_get_Properties
    );

    $.Field({Static:false, Public:false}, "properties", $asm0A.TypeRef("System.Collections.IDictionary")); 
    $.Property({Static:false, Public:true }, "Properties", $asm0A.TypeRef("System.Collections.IDictionary"));

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.CombinatorialAttribute */ 

(function CombinatorialAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };

  function CombinatorialAttribute__ctor () {
    $S00().Call($T00().prototype, "_ctor", null, this, "_JOINTYPE", "Combinatorial");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.CombinatorialAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CombinatorialAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.PairwiseAttribute */ 

(function PairwiseAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };

  function PairwiseAttribute__ctor () {
    $S00().Call($T00().prototype, "_ctor", null, this, "_JOINTYPE", "Pairwise");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.PairwiseAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      PairwiseAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.SequentialAttribute */ 

(function SequentialAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };

  function SequentialAttribute__ctor () {
    $S00().Call($T00().prototype, "_ctor", null, this, "_JOINTYPE", "Sequential");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.SequentialAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SequentialAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.MaxTimeAttribute */ 

(function MaxTimeAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };

  function MaxTimeAttribute__ctor (milliseconds) {
    $T01().prototype._ctor.call(this, milliseconds);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.MaxTimeAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      MaxTimeAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.ParameterDataAttribute */ 

(function ParameterDataAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function ParameterDataAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.ParameterDataAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      ParameterDataAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Parameter]; });

})();

/* class NUnit.Framework.ValuesAttribute */ 

(function ValuesAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.ParameterDataAttribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Reflection.ParameterInfo)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.DBNull)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Int16)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Byte)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.SByte)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.Decimal)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.DateTime)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.System.TimeSpan)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.Convert)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0A.System.Globalization.CultureInfo)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Object"), [
        $asm0A.TypeRef("System.Object"), $asm0A.TypeRef("System.Type"), 
        $asm0A.TypeRef("System.IFormatProvider")
      ]))) ();
  };

  function ValuesAttribute__ctor$00 (arg1) {
    $T01().prototype._ctor.call(this);
    this.data = JSIL.Array.New($T00(), [arg1]);
  };

  function ValuesAttribute__ctor$01 (arg1, arg2) {
    $T01().prototype._ctor.call(this);
    this.data = JSIL.Array.New($T00(), [arg1, arg2]);
  };

  function ValuesAttribute__ctor$02 (arg1, arg2, arg3) {
    $T01().prototype._ctor.call(this);
    this.data = JSIL.Array.New($T00(), [arg1, arg2, arg3]);
  };

  function ValuesAttribute__ctor$03 (args) {
    $T01().prototype._ctor.call(this);
    this.data = args;
  };

  function ValuesAttribute_GetData (parameter) {
    var parameterType = parameter.get_ParameterType();

    for (var i = 0; i < (this.data.length | 0); i = ((i + 1) | 0)) {
      var obj = this.data[i];
      if (obj !== null) {
        if (!(!((JSIL.GetType(obj)).get_FullName() == "NUnit.Framework.SpecialValue") || !(obj.toString() == "Null"))) {
          this.data[i] = null;
        } else if (!parameterType.IsAssignableFrom(JSIL.GetType(obj))) {
          if ($T07().$Is(obj)) {
            this.data[i] = null;
          } else {
            var flag = false;
            if (!(!((parameterType === $T09().__Type__) || 
                  (parameterType === $T0A().__Type__)) && (parameterType !== $T0B().__Type__))) {
              flag = $T05().$Is(obj);
            } else if (parameterType === $T0C().__Type__) {
              flag = $T0D().$Is(obj) || 
              ($T06().$As(obj) !== null) || 
              $T05().$Is(obj);
            } else if (!((parameterType !== $T0E().__Type__) && (parameterType !== $T0F().__Type__))) {
              flag = $T06().$Is(obj);
            }
            if (flag) {
              this.data[i] = $S00().CallStatic($T10(), "ChangeType", null, obj, parameterType, $T11().get_InvariantCulture());
            }
          }
        }
      }
    }
    return $T12().$Cast(this.data);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.ParameterDataAttribute"), 
      Name: "NUnit.Framework.ValuesAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      ValuesAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      ValuesAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.Object
        ]), 
      ValuesAttribute__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Object])), 
      ValuesAttribute__ctor$03
    )
      .Parameter(0, "args", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true , Virtual:true }, "GetData", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Collections.IEnumerable"), [$asm0A.TypeRef("System.Reflection.ParameterInfo")]), 
      ValuesAttribute_GetData
    );

    $.Field({Static:false, Public:false}, "data", $jsilcore.TypeRef("System.Array", [$.Object])); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Parameter]; });

})();

/* class NUnit.Framework.RandomAttribute */ 

(function RandomAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.ValuesAttribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.RandomAttribute_SampleType)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Reflection.ParameterInfo)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Randomizer)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Collections.IList)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Randomizer"), [$asm0A.TypeRef("System.Reflection.ParameterInfo")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.ICollection.get_Count)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IList.get_Item)) ();
  };

  function RandomAttribute__ctor$00 (count) {
    $S00().Call($T01().prototype, "_ctor", null, this, JSIL.Array.New($T02(), 0));
    this.count = (count | 0);
    this.sampleType = $T03().Raw;
  };

  function RandomAttribute__ctor$01 (min, max, count) {
    $S00().Call($T01().prototype, "_ctor", null, this, JSIL.Array.New($T02(), 0));
    this.count = (count | 0);
    this.dmin = +min;
    this.dmax = +max;
    this.sampleType = $T03().DoubleRange;
  };

  function RandomAttribute__ctor$02 (min, max, count) {
    $S00().Call($T01().prototype, "_ctor", null, this, JSIL.Array.New($T02(), 0));
    this.count = (count | 0);
    this.min = (min | 0);
    this.max = (max | 0);
    this.sampleType = $T03().IntRange;
  };

  function RandomAttribute_GetData (parameter) {
    var randomizer = $S01().CallStatic($T06(), "GetRandomizer", null, parameter);
    switch ((this.sampleType).valueOf()) {
      default: 
      case 0: 
        var list = randomizer.GetDoubles(this.count);
        break;

      case 1: 
        list = randomizer.GetInts(this.min, this.max, this.count);
        break;

      case 2: 
        list = randomizer.GetDoubles(this.dmin, this.dmax, this.count);
        break;

    }
    this.data = JSIL.Array.New($T02(), $IM00().Call(list, null));

    for (var i = 0; i < ($IM00().Call(list, null) | 0); i = ((i + 1) | 0)) {
      this.data[i] = $IM01().Call(list, null, i);
    }
    return $T01().prototype.GetData.call(this, parameter);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.ValuesAttribute"), 
      Name: "NUnit.Framework.RandomAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      RandomAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Int32
        ]), 
      RandomAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      RandomAttribute__ctor$02
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetData", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Collections.IEnumerable"), [$asm0A.TypeRef("System.Reflection.ParameterInfo")]), 
      RandomAttribute_GetData
    );

    $.Field({Static:false, Public:false}, "sampleType", $asm0B.TypeRef("NUnit.Framework.RandomAttribute+SampleType")); 
    $.Field({Static:false, Public:false}, "count", $.Int32); 
    $.Field({Static:false, Public:false}, "min", $.Int32); 
    $.Field({Static:false, Public:false}, "max", $.Int32); 
    $.Field({Static:false, Public:false}, "dmin", $.Double); 
    $.Field({Static:false, Public:false}, "dmax", $.Double); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum NUnit.Framework.RandomAttribute+SampleType */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.RandomAttribute+SampleType", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Raw: 0, 
    IntRange: 1, 
    DoubleRange: 2, 
  }
);

/* class NUnit.Framework.RangeAttribute */ 

(function RangeAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.ValuesAttribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Single)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.Int32"), $asm0A.TypeRef("System.Int32"), 
        $asm0A.TypeRef("System.Int32")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")])))) ();
  };

  function RangeAttribute__ctor$00 (from, to) {
    $S00().Call($thisType.prototype, "_ctor", null, this, from, to, 1);
  };

  function RangeAttribute__ctor$01 (from, to, step) {
    var $temp00;
    $S01().Call($T01().prototype, "_ctor", null, this, JSIL.Array.New($T02(), 0));
    var num = (((((((to | 0) - (from | 0)) | 0) / (step | 0)) | 0) + 1) | 0);
    this.data = JSIL.Array.New($T02(), num);
    var i = 0;
    var num2 = (from | 0);

    while (i < num) {
      this.data[($temp00 = i, 
        i = ((i + 1) | 0), 
        $temp00)] = num2;
      num2 = ((num2 + (step | 0)) | 0);
    }
  };

  function RangeAttribute__ctor$02 (from, to, step) {
    var $temp00;
    $S01().Call($T01().prototype, "_ctor", null, this, JSIL.Array.New($T02(), 0));
    var num = $T03().op_Addition(
      $T03().op_Division($T03().op_Subtraction(to, from), step), 
      $T03().Create(1, 0, 0)
    );
    this.data = JSIL.Array.New($T02(), num);
    var num2 = 0;
    var num3 = from;

    while ($T03().op_LessThan($T03().FromNumber(num2), num)) {
      this.data[($temp00 = num2, 
        num2 = ((num2 + 1) | 0), 
        $temp00)] = num3;
      num3 = $T03().op_Addition(num3, step);
    }
  };

  function RangeAttribute__ctor$03 (from, to, step) {
    var $temp00;
    $S01().Call($T01().prototype, "_ctor", null, this, JSIL.Array.New($T02(), 0));
    var num2 = (((+(((+to - +from) / +step)) + +((+step / 1000))) + 1) | 0);
    this.data = JSIL.Array.New($T02(), num2);
    var i = 0;
    var num3 = +from;

    while (i < num2) {
      this.data[($temp00 = i, 
        i = ((i + 1) | 0), 
        $temp00)] = num3;
      num3 += +step;
    }
  };

  function RangeAttribute__ctor$04 (from, to, step) {
    var $temp00;
    $S01().Call($T01().prototype, "_ctor", null, this, JSIL.Array.New($T02(), 0));
    var num2 = (((+(((+to - +from) / +step)) + +((+step / 1000))) + 1) | 0);
    this.data = JSIL.Array.New($T02(), num2);
    var i = 0;
    var num3 = +from;

    while (i < num2) {
      this.data[($temp00 = i, 
        i = ((i + 1) | 0), 
        $temp00)] = num3;
      num3 += +step;
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.ValuesAttribute"), 
      Name: "NUnit.Framework.RangeAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32]), 
      RangeAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      RangeAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.Int64
        ]), 
      RangeAttribute__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ]), 
      RangeAttribute__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ]), 
      RangeAttribute__ctor$04
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.RepeatAttribute */ 

(function RepeatAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };

  function RepeatAttribute__ctor (count) {
    $T01().prototype._ctor.call(this, count);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.RepeatAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      RepeatAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.RequiredAddinAttribute */ 

(function RequiredAddinAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function RequiredAddinAttribute__ctor (requiredAddin) {
    $T01().prototype._ctor.call(this);
    this.requiredAddin = requiredAddin;
  };

  function RequiredAddinAttribute_get_RequiredAddin () {
    return this.requiredAddin;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.RequiredAddinAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      RequiredAddinAttribute__ctor
    );

    $.Method({Static:false, Public:true }, "get_RequiredAddin", 
      JSIL.MethodSignature.Return($.String), 
      RequiredAddinAttribute_get_RequiredAddin
    );

    $.Field({Static:false, Public:false}, "requiredAddin", $.String); 
    $.Property({Static:false, Public:true }, "RequiredAddin", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Assembly]; });

})();

/* class NUnit.Framework.SetCultureAttribute */ 

(function SetCultureAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };

  function SetCultureAttribute__ctor (culture) {
    $S00().Call($T01().prototype, "_ctor", null, this, "_SETCULTURE", culture);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.SetCultureAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      SetCultureAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.SetUICultureAttribute */ 

(function SetUICultureAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };

  function SetUICultureAttribute__ctor (culture) {
    $S00().Call($T01().prototype, "_ctor", null, this, "_SETUICULTURE", culture);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.SetUICultureAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      SetUICultureAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.SetUpAttribute */ 

(function SetUpAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function SetUpAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.SetUpAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SetUpAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.SetUpFixtureAttribute */ 

(function SetUpFixtureAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function SetUpFixtureAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.SetUpFixtureAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SetUpFixtureAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Class]; });

})();

/* class NUnit.Framework.SuiteAttribute */ 

(function SuiteAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function SuiteAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.SuiteAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SuiteAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Property]; });

})();

/* class NUnit.Framework.TearDownAttribute */ 

(function TearDownAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function TearDownAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TearDownAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TearDownAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* interface NUnit.Framework.ITestAction */ 

JSIL.MakeInterface(
  "NUnit.Framework.ITestAction", true, [], function ($) {
    $.Method({}, "BeforeTest", JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.TestDetails")));
    $.Method({}, "AfterTest", JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.TestDetails")));
    $.Method({}, "get_Targets", JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.ActionTargets")));
    $.Property({}, "Targets");
  }, []);

/* class NUnit.Framework.TestActionAttribute */ 

(function TestActionAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.TestDetails)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.ActionTargets)) ();
  };

  function TestActionAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function TestActionAttribute_AfterTest (testDetails) {
  };

  function TestActionAttribute_BeforeTest (testDetails) {
  };

  function TestActionAttribute_get_Targets () {
    return $T02().Default;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TestActionAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      TestActionAttribute__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "AfterTest", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.TestDetails")), 
      TestActionAttribute_AfterTest
    );

    $.Method({Static:false, Public:true , Virtual:true }, "BeforeTest", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.TestDetails")), 
      TestActionAttribute_BeforeTest
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Targets", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.ActionTargets")), 
      TestActionAttribute_get_Targets
    );

    $.Property({Static:false, Public:true , Virtual:true }, "Targets", $asm0B.TypeRef("NUnit.Framework.ActionTargets"));

    $.ImplementInterfaces(
      /* 1 */ $asm0B.TypeRef("NUnit.Framework.ITestAction")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Interface", "Method")]; });

})();

/* class NUnit.Framework.TestAttribute */ 

(function TestAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };

  function TestAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function TestAttribute_get_Description () {
    return this.description;
  };

  function TestAttribute_set_Description (value) {
    this.description = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TestAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TestAttribute__ctor
    );

    $.Method({Static:false, Public:true }, "get_Description", 
      JSIL.MethodSignature.Return($.String), 
      TestAttribute_get_Description
    );

    $.Method({Static:false, Public:true }, "set_Description", 
      JSIL.MethodSignature.Action($.String), 
      TestAttribute_set_Description
    );

    $.Field({Static:false, Public:false}, "description", $.String); 
    $.Property({Static:false, Public:true }, "Description", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.TestCaseAttribute */ 

(function TestCaseAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Char)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize(System.Array.Of($asm0A.System.Char))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.MessageMatch)) ();
  };

  function TestCaseAttribute__ctor$00 ($arguments) {
    $T01().prototype._ctor.call(this);
    if ($arguments === null) {
      var array = JSIL.Array.New($T02(), 1);
      this.$arguments = array;
    } else {
      this.$arguments = $arguments;
    }
  };

  function TestCaseAttribute__ctor$01 (arg) {
    $T01().prototype._ctor.call(this);
    this.$arguments = JSIL.Array.New($T02(), [arg]);
  };

  function TestCaseAttribute__ctor$02 (arg1, arg2) {
    $T01().prototype._ctor.call(this);
    this.$arguments = JSIL.Array.New($T02(), [arg1, arg2]);
  };

  function TestCaseAttribute__ctor$03 (arg1, arg2, arg3) {
    $T01().prototype._ctor.call(this);
    this.$arguments = JSIL.Array.New($T02(), [arg1, arg2, arg3]);
  };

  function TestCaseAttribute_get_Arguments () {
    return this.$arguments;
  };

  function TestCaseAttribute_get_Categories () {
    return (
      (this.category === null)
         ? null
         : JSIL.SplitString(this.category, JSIL.Array.New($T04(), [","])))
    ;
  };

  function TestCaseAttribute_get_Category () {
    return this.category;
  };

  function TestCaseAttribute_get_Description () {
    return this.description;
  };

  function TestCaseAttribute_get_ExpectedException () {
    return this.expectedExceptionType;
  };

  function TestCaseAttribute_get_ExpectedExceptionName () {
    return this.expectedExceptionName;
  };

  function TestCaseAttribute_get_ExpectedMessage () {
    return this.expectedMessage;
  };

  function TestCaseAttribute_get_ExpectedResult () {
    return this.expectedResult;
  };

  function TestCaseAttribute_get_Explicit () {
    return this.isExplicit;
  };

  function TestCaseAttribute_get_HasExpectedResult () {
    return this.hasExpectedResult;
  };

  function TestCaseAttribute_get_Ignore () {
    return this.isIgnored;
  };

  function TestCaseAttribute_get_Ignored () {
    return this.isIgnored;
  };

  function TestCaseAttribute_get_IgnoreReason () {
    return this.reason;
  };

  function TestCaseAttribute_get_MatchType () {
    return this.matchType;
  };

  function TestCaseAttribute_get_Reason () {
    return this.reason;
  };

  function TestCaseAttribute_get_Result () {
    return this.get_ExpectedResult();
  };

  function TestCaseAttribute_get_TestName () {
    return this.testName;
  };

  function TestCaseAttribute_set_Category (value) {
    this.category = value;
  };

  function TestCaseAttribute_set_Description (value) {
    this.description = value;
  };

  function TestCaseAttribute_set_ExpectedException (value) {
    this.expectedExceptionType = value;
    this.expectedExceptionName = (this.expectedExceptionType).get_FullName();
  };

  function TestCaseAttribute_set_ExpectedExceptionName (value) {
    this.expectedExceptionName = value;
    this.expectedExceptionType = null;
  };

  function TestCaseAttribute_set_ExpectedMessage (value) {
    this.expectedMessage = value;
  };

  function TestCaseAttribute_set_ExpectedResult (value) {
    this.expectedResult = value;
    this.hasExpectedResult = true;
  };

  function TestCaseAttribute_set_Explicit (value) {
    this.isExplicit = value;
  };

  function TestCaseAttribute_set_Ignore (value) {
    this.isIgnored = value;
  };

  function TestCaseAttribute_set_Ignored (value) {
    this.isIgnored = value;
  };

  function TestCaseAttribute_set_IgnoreReason (value) {
    this.reason = value;
    this.isIgnored = (this.reason !== null) && 
    (this.reason != $T03().Empty);
  };

  function TestCaseAttribute_set_MatchType (value) {
    this.matchType = value;
  };

  function TestCaseAttribute_set_Reason (value) {
    this.reason = value;
  };

  function TestCaseAttribute_set_Result (value) {
    this.set_ExpectedResult(value);
  };

  function TestCaseAttribute_set_TestName (value) {
    this.testName = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TestCaseAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Object])), 
      TestCaseAttribute__ctor$00
    )
      .Parameter(0, "arguments", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      TestCaseAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      TestCaseAttribute__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $.Object
        ]), 
      TestCaseAttribute__ctor$03
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Arguments", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Object])), 
      TestCaseAttribute_get_Arguments
    );

    $.Method({Static:false, Public:true }, "get_Categories", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.IList")), 
      TestCaseAttribute_get_Categories
    );

    $.Method({Static:false, Public:true }, "get_Category", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseAttribute_get_Category
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Description", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseAttribute_get_Description
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_ExpectedException", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Type")), 
      TestCaseAttribute_get_ExpectedException
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_ExpectedExceptionName", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseAttribute_get_ExpectedExceptionName
    );

    $.Method({Static:false, Public:true }, "get_ExpectedMessage", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseAttribute_get_ExpectedMessage
    );

    $.Method({Static:false, Public:true }, "get_ExpectedResult", 
      JSIL.MethodSignature.Return($.Object), 
      TestCaseAttribute_get_ExpectedResult
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Explicit", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestCaseAttribute_get_Explicit
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_HasExpectedResult", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestCaseAttribute_get_HasExpectedResult
    );

    $.Method({Static:false, Public:true }, "get_Ignore", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestCaseAttribute_get_Ignore
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Ignored", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestCaseAttribute_get_Ignored
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_IgnoreReason", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseAttribute_get_IgnoreReason
    );

    $.Method({Static:false, Public:true }, "get_MatchType", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.MessageMatch")), 
      TestCaseAttribute_get_MatchType
    );

    $.Method({Static:false, Public:true }, "get_Reason", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseAttribute_get_Reason
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Result", 
      JSIL.MethodSignature.Return($.Object), 
      TestCaseAttribute_get_Result
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_TestName", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseAttribute_get_TestName
    );

    $.Method({Static:false, Public:true }, "set_Category", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseAttribute_set_Category
    );

    $.Method({Static:false, Public:true }, "set_Description", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseAttribute_set_Description
    );

    $.Method({Static:false, Public:true }, "set_ExpectedException", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      TestCaseAttribute_set_ExpectedException
    );

    $.Method({Static:false, Public:true }, "set_ExpectedExceptionName", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseAttribute_set_ExpectedExceptionName
    );

    $.Method({Static:false, Public:true }, "set_ExpectedMessage", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseAttribute_set_ExpectedMessage
    );

    $.Method({Static:false, Public:true }, "set_ExpectedResult", 
      JSIL.MethodSignature.Action($.Object), 
      TestCaseAttribute_set_ExpectedResult
    );

    $.Method({Static:false, Public:true }, "set_Explicit", 
      JSIL.MethodSignature.Action($.Boolean), 
      TestCaseAttribute_set_Explicit
    );

    $.Method({Static:false, Public:true }, "set_Ignore", 
      JSIL.MethodSignature.Action($.Boolean), 
      TestCaseAttribute_set_Ignore
    );

    $.Method({Static:false, Public:true }, "set_Ignored", 
      JSIL.MethodSignature.Action($.Boolean), 
      TestCaseAttribute_set_Ignored
    );

    $.Method({Static:false, Public:true }, "set_IgnoreReason", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseAttribute_set_IgnoreReason
    );

    $.Method({Static:false, Public:true }, "set_MatchType", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.MessageMatch")), 
      TestCaseAttribute_set_MatchType
    );

    $.Method({Static:false, Public:true }, "set_Reason", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseAttribute_set_Reason
    );

    $.Method({Static:false, Public:true }, "set_Result", 
      JSIL.MethodSignature.Action($.Object), 
      TestCaseAttribute_set_Result
    );

    $.Method({Static:false, Public:true }, "set_TestName", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseAttribute_set_TestName
    );

    $.Field({Static:false, Public:false}, "$arguments", $jsilcore.TypeRef("System.Array", [$.Object])); 
    $.Field({Static:false, Public:false}, "expectedResult", $.Object); 
    $.Field({Static:false, Public:false}, "hasExpectedResult", $.Boolean); 
    $.Field({Static:false, Public:false}, "expectedExceptionType", $asm0A.TypeRef("System.Type")); 
    $.Field({Static:false, Public:false}, "expectedExceptionName", $.String); 
    $.Field({Static:false, Public:false}, "expectedMessage", $.String); 
    $.Field({Static:false, Public:false}, "matchType", $asm0B.TypeRef("NUnit.Framework.MessageMatch")); 
    $.Field({Static:false, Public:false}, "description", $.String); 
    $.Field({Static:false, Public:false}, "testName", $.String); 
    $.Field({Static:false, Public:false}, "isIgnored", $.Boolean); 
    $.Field({Static:false, Public:false}, "isExplicit", $.Boolean); 
    $.Field({Static:false, Public:false}, "reason", $.String); 
    $.Field({Static:false, Public:false}, "category", $.String); 
    $.Property({Static:false, Public:true , Virtual:true }, "Arguments", $jsilcore.TypeRef("System.Array", [$.Object]));

    $.Property({Static:false, Public:true , Virtual:true }, "Result", $.Object);

    $.Property({Static:false, Public:true }, "ExpectedResult", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "HasExpectedResult", $.Boolean);

    $.Property({Static:false, Public:true }, "Categories", $asm0A.TypeRef("System.Collections.IList"));

    $.Property({Static:false, Public:true }, "Category", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "ExpectedException", $asm0A.TypeRef("System.Type"));

    $.Property({Static:false, Public:true , Virtual:true }, "ExpectedExceptionName", $.String);

    $.Property({Static:false, Public:true }, "ExpectedMessage", $.String);

    $.Property({Static:false, Public:true }, "MatchType", $asm0B.TypeRef("NUnit.Framework.MessageMatch"));

    $.Property({Static:false, Public:true , Virtual:true }, "Description", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "TestName", $.String);

    $.Property({Static:false, Public:true }, "Ignore", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Ignored", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Explicit", $.Boolean);

    $.Property({Static:false, Public:true }, "Reason", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "IgnoreReason", $.String);

    $.ImplementInterfaces(
      /* 1 */ $asm0B.TypeRef("NUnit.Framework.ITestCaseData")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.TestCaseSourceAttribute */ 

(function TestCaseSourceAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Type)) ();
  };

  function TestCaseSourceAttribute__ctor$00 (sourceName) {
    $T01().prototype._ctor.call(this);
    this.sourceName = sourceName;
  };

  function TestCaseSourceAttribute__ctor$01 (sourceType) {
    $T01().prototype._ctor.call(this);
    this.sourceType = sourceType;
  };

  function TestCaseSourceAttribute__ctor$02 (sourceType, sourceName) {
    $T01().prototype._ctor.call(this);
    this.sourceType = sourceType;
    this.sourceName = sourceName;
  };

  function TestCaseSourceAttribute_get_Category () {
    return this.category;
  };

  function TestCaseSourceAttribute_get_SourceName () {
    return this.sourceName;
  };

  function TestCaseSourceAttribute_get_SourceType () {
    return this.sourceType;
  };

  function TestCaseSourceAttribute_set_Category (value) {
    this.category = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TestCaseSourceAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseSourceAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      TestCaseSourceAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.String]), 
      TestCaseSourceAttribute__ctor$02
    );

    $.Method({Static:false, Public:true }, "get_Category", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseSourceAttribute_get_Category
    );

    $.Method({Static:false, Public:true }, "get_SourceName", 
      JSIL.MethodSignature.Return($.String), 
      TestCaseSourceAttribute_get_SourceName
    );

    $.Method({Static:false, Public:true }, "get_SourceType", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Type")), 
      TestCaseSourceAttribute_get_SourceType
    );

    $.Method({Static:false, Public:true }, "set_Category", 
      JSIL.MethodSignature.Action($.String), 
      TestCaseSourceAttribute_set_Category
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "sourceName", $.String); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "sourceType", $asm0A.TypeRef("System.Type")); 
    $.Field({Static:false, Public:false}, "category", $.String); 
    $.Property({Static:false, Public:true }, "SourceName", $.String);

    $.Property({Static:false, Public:true }, "SourceType", $asm0A.TypeRef("System.Type"));

    $.Property({Static:false, Public:true }, "Category", $.String);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.TestFixtureAttribute */ 

(function TestFixtureAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.SpecialValue)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Char)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm0A.System.Char))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize(System.Array.Of($asm0A.System.Type))) ();
  };

  function TestFixtureAttribute__ctor$00 () {
    $thisType.prototype._ctor.call(this, null);
  };

  function TestFixtureAttribute__ctor$01 ($arguments) {
    $T01().prototype._ctor.call(this);
    this.$arguments = (
      ($arguments === null)
         ? JSIL.Array.New($T02(), 0)
         : $arguments)
    ;

    for (var i = 0; i < (this.$arguments.length | 0); i = ((i + 1) | 0)) {
      if (!(!$T04().$Is($arguments[i]) || ($T04().$Cast($arguments[i]) !== $T04().Null))) {
        $arguments[i] = null;
      }
    }
  };

  function TestFixtureAttribute_get_Arguments () {
    return this.$arguments;
  };

  function TestFixtureAttribute_get_Categories () {
    return (
      (this.category === null)
         ? null
         : JSIL.SplitString(this.category, JSIL.Array.New($T06(), [","])))
    ;
  };

  function TestFixtureAttribute_get_Category () {
    return this.category;
  };

  function TestFixtureAttribute_get_Description () {
    return this.description;
  };

  function TestFixtureAttribute_get_Ignore () {
    return this.isIgnored;
  };

  function TestFixtureAttribute_get_IgnoreReason () {
    return this.ignoreReason;
  };

  function TestFixtureAttribute_get_TypeArgs () {
    return this.typeArgs;
  };

  function TestFixtureAttribute_set_Category (value) {
    this.category = value;
  };

  function TestFixtureAttribute_set_Description (value) {
    this.description = value;
  };

  function TestFixtureAttribute_set_Ignore (value) {
    this.isIgnored = value;
  };

  function TestFixtureAttribute_set_IgnoreReason (value) {
    this.ignoreReason = value;
    this.isIgnored = (this.ignoreReason !== null) && 
    (this.ignoreReason != $T05().Empty);
  };

  function TestFixtureAttribute_set_TypeArgs (value) {
    this.typeArgs = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TestFixtureAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TestFixtureAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Object])), 
      TestFixtureAttribute__ctor$01
    )
      .Parameter(0, "arguments", function (_) {
          _.Attribute($asm0A.TypeRef("System.ParamArrayAttribute"))
        });

    $.Method({Static:false, Public:true }, "get_Arguments", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Object])), 
      TestFixtureAttribute_get_Arguments
    );

    $.Method({Static:false, Public:true }, "get_Categories", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.IList")), 
      TestFixtureAttribute_get_Categories
    );

    $.Method({Static:false, Public:true }, "get_Category", 
      JSIL.MethodSignature.Return($.String), 
      TestFixtureAttribute_get_Category
    );

    $.Method({Static:false, Public:true }, "get_Description", 
      JSIL.MethodSignature.Return($.String), 
      TestFixtureAttribute_get_Description
    );

    $.Method({Static:false, Public:true }, "get_Ignore", 
      JSIL.MethodSignature.Return($.Boolean), 
      TestFixtureAttribute_get_Ignore
    );

    $.Method({Static:false, Public:true }, "get_IgnoreReason", 
      JSIL.MethodSignature.Return($.String), 
      TestFixtureAttribute_get_IgnoreReason
    );

    $.Method({Static:false, Public:true }, "get_TypeArgs", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Type")])), 
      TestFixtureAttribute_get_TypeArgs
    );

    $.Method({Static:false, Public:true }, "set_Category", 
      JSIL.MethodSignature.Action($.String), 
      TestFixtureAttribute_set_Category
    );

    $.Method({Static:false, Public:true }, "set_Description", 
      JSIL.MethodSignature.Action($.String), 
      TestFixtureAttribute_set_Description
    );

    $.Method({Static:false, Public:true }, "set_Ignore", 
      JSIL.MethodSignature.Action($.Boolean), 
      TestFixtureAttribute_set_Ignore
    );

    $.Method({Static:false, Public:true }, "set_IgnoreReason", 
      JSIL.MethodSignature.Action($.String), 
      TestFixtureAttribute_set_IgnoreReason
    );

    $.Method({Static:false, Public:true }, "set_TypeArgs", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Type")])), 
      TestFixtureAttribute_set_TypeArgs
    );

    $.Field({Static:false, Public:false}, "description", $.String); 
    $.Field({Static:false, Public:false}, "$arguments", $jsilcore.TypeRef("System.Array", [$.Object])); 
    $.Field({Static:false, Public:false}, "isIgnored", $.Boolean); 
    $.Field({Static:false, Public:false}, "ignoreReason", $.String); 
    $.Field({Static:false, Public:false}, "category", $.String); 
    $.Field({Static:false, Public:false}, "typeArgs", $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Type")])); 
    $.Property({Static:false, Public:true }, "Description", $.String);

    $.Property({Static:false, Public:true }, "Category", $.String);

    $.Property({Static:false, Public:true }, "Categories", $asm0A.TypeRef("System.Collections.IList"));

    $.Property({Static:false, Public:true }, "Arguments", $jsilcore.TypeRef("System.Array", [$.Object]));

    $.Property({Static:false, Public:true }, "Ignore", $.Boolean);

    $.Property({Static:false, Public:true }, "IgnoreReason", $.String);

    $.Property({Static:false, Public:true }, "TypeArgs", $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Type")]));

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Class]; });

})();

/* class NUnit.Framework.TestFixtureSetUpAttribute */ 

(function TestFixtureSetUpAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function TestFixtureSetUpAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TestFixtureSetUpAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TestFixtureSetUpAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.TestFixtureTearDownAttribute */ 

(function TestFixtureTearDownAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function TestFixtureTearDownAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TestFixtureTearDownAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TestFixtureTearDownAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.TheoryAttribute */ 

(function TheoryAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };

  function TheoryAttribute__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.TheoryAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TheoryAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Method]; });

})();

/* class NUnit.Framework.TimeoutAttribute */ 

(function TimeoutAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };

  function TimeoutAttribute__ctor (timeout) {
    $T01().prototype._ctor.call(this, timeout);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.TimeoutAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      TimeoutAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.RequiresSTAAttribute */ 

(function RequiresSTAAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Threading.ApartmentState)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.Add)) ();
  };

  function RequiresSTAAttribute__ctor () {
    $T00().prototype._ctor.call(this);
    $IM00().Call(this.get_Properties(), null, "APARTMENT_STATE", $T02().STA);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.RequiresSTAAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RequiresSTAAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.RequiresMTAAttribute */ 

(function RequiresMTAAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Threading.ApartmentState)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.Add)) ();
  };

  function RequiresMTAAttribute__ctor () {
    $T00().prototype._ctor.call(this);
    $IM00().Call(this.get_Properties(), null, "APARTMENT_STATE", $T02().MTA);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.RequiresMTAAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RequiresMTAAttribute__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.RequiresThreadAttribute */ 

(function RequiresThreadAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.PropertyAttribute)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Threading.ApartmentState)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IDictionary.Add)) ();
  };

  function RequiresThreadAttribute__ctor$00 () {
    $T00().prototype._ctor.call(this, true);
  };

  function RequiresThreadAttribute__ctor$01 (apartment) {
    $T00().prototype._ctor.call(this, true);
    $IM00().Call(this.get_Properties(), null, "APARTMENT_STATE", apartment);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.PropertyAttribute"), 
      Name: "NUnit.Framework.RequiresThreadAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RequiresThreadAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Threading.ApartmentState")), 
      RequiresThreadAttribute__ctor$01
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.$Flags("Assembly", "Class", "Method")]; });

})();

/* class NUnit.Framework.ValueSourceAttribute */ 

(function ValueSourceAttribute$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Type)) ();
  };

  function ValueSourceAttribute__ctor$00 (sourceName) {
    $T01().prototype._ctor.call(this);
    this.sourceName = sourceName;
  };

  function ValueSourceAttribute__ctor$01 (sourceType, sourceName) {
    $T01().prototype._ctor.call(this);
    this.sourceType = sourceType;
    this.sourceName = sourceName;
  };

  function ValueSourceAttribute_get_SourceName () {
    return this.sourceName;
  };

  function ValueSourceAttribute_get_SourceType () {
    return this.sourceType;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Attribute"), 
      Name: "NUnit.Framework.ValueSourceAttribute", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      ValueSourceAttribute__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $.String]), 
      ValueSourceAttribute__ctor$01
    );

    $.Method({Static:false, Public:true }, "get_SourceName", 
      JSIL.MethodSignature.Return($.String), 
      ValueSourceAttribute_get_SourceName
    );

    $.Method({Static:false, Public:true }, "get_SourceType", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Type")), 
      ValueSourceAttribute_get_SourceType
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "sourceName", $.String); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "sourceType", $asm0A.TypeRef("System.Type")); 
    $.Property({Static:false, Public:true }, "SourceName", $.String);

    $.Property({Static:false, Public:true }, "SourceType", $asm0A.TypeRef("System.Type"));

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0A.TypeRef("System.AttributeUsageAttribute"), function () { return [$asm0A.System.AttributeTargets.Parameter]; });

})();

/* interface NUnit.Framework.Constraints.IResolveConstraint */ 

JSIL.MakeInterface(
  "NUnit.Framework.Constraints.IResolveConstraint", true, [], function ($) {
    $.Method({}, "Resolve", JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")));
  }, []);

/* class NUnit.Framework.Constraints.Constraint */ 

(function Constraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint_UnsetObject)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Globalization.CultureInfo)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.DelayedConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AndOperator)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.OrOperator)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AndConstraint)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.OrConstraint)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NullConstraint)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.DelayedConstraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $asm0A.TypeRef("System.Int32")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.DelayedConstraint"), [
        $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $asm0A.TypeRef("System.Int32"), 
        $asm0A.TypeRef("System.Int32")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.AsyncInvocationRegion"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };

  function Constraint__ctor$00 () {
    this.actual = $thisType.UNSET;
    this.argcnt = 0;
  };

  function Constraint__ctor$01 (arg) {
    this.actual = $thisType.UNSET;
    this.argcnt = 1;
    this.arg1 = arg;
  };

  function Constraint__ctor$02 (arg1, arg2) {
    this.actual = $thisType.UNSET;
    this.argcnt = 2;
    this.arg1 = arg1;
    this.arg2 = arg2;
  };

  function Constraint__displayable (o) {
    if (o === null) {
      var result = "null";
    } else {
      var format = (
        ($T02().$As(o) !== null)
           ? "\"{0}\""
           : "{0}")
      ;
      result = $T02().Format($T03().get_InvariantCulture(), format, JSIL.Array.New($T01(), [o]));
    }
    return result;
  };

  function Constraint_After$03 (delayInMilliseconds) {
    return $S00().Construct((
        (this.builder === null)
           ? this
           : (this.builder).Resolve())
      , delayInMilliseconds);
  };

  function Constraint_After$04 (delayInMilliseconds, pollingInterval) {
    return $S01().Construct((
        (this.builder === null)
           ? this
           : (this.builder).Resolve())
      , delayInMilliseconds, pollingInterval);
  };

  function Constraint_get_And () {
    var constraintBuilder = this.builder;
    if (constraintBuilder === null) {
      constraintBuilder = new ($T06())();
      $S02().CallVirtual("Append", null, constraintBuilder, this);
    }
    $S03().CallVirtual("Append", null, constraintBuilder, new ($T07())());
    return $S04().Construct(constraintBuilder);
  };

  function Constraint_get_DisplayName () {
    if (this.displayName === null) {
      this.displayName = ((JSIL.GetType(this)).get_Name().toLowerCase());
      if (!(!(System.String.EndsWith(this.displayName, "`1")) && !(System.String.EndsWith(this.displayName, "`2")))) {
        this.displayName = (this.displayName.substr(0, (((this.displayName.length | 0) - 2) | 0)));
      }
      if (System.String.EndsWith(this.displayName, "constraint")) {
        this.displayName = (this.displayName.substr(0, (((this.displayName.length | 0) - 10) | 0)));
      }
    }
    return this.displayName;
  };

  function Constraint_get_Or () {
    var constraintBuilder = this.builder;
    if (constraintBuilder === null) {
      constraintBuilder = new ($T06())();
      $S02().CallVirtual("Append", null, constraintBuilder, this);
    }
    $S03().CallVirtual("Append", null, constraintBuilder, new ($T0A())());
    return $S04().Construct(constraintBuilder);
  };

  function Constraint_get_With () {
    return this.get_And();
  };

  function Constraint_GetStringRepresentation () {
    switch (this.argcnt) {
      default: 
      case 0: 
        var result = $T02().Format("<{0}>", this.get_DisplayName());
        break;

      case 1: 
        result = $T02().Format(
          "<{0} {1}>", 
          this.get_DisplayName(), 
          $thisType._displayable(this.arg1)
        );
        break;

      case 2: 
        result = $T02().Format(
          "<{0} {1} {2}>", 
          this.get_DisplayName(), 
          $thisType._displayable(this.arg1), 
          $thisType._displayable(this.arg2)
        );
        break;

    }
    return result;
  };

  function Constraint_Matches$b1$05 (T, del) {
    if ($S05().CallStatic($T0C(), "IsAsyncOperation", null, del)) {
      var asyncInvocationRegion = $S06().CallStatic($T0C(), "Create", null, del);
      try {
        var result = $S07().CallVirtual("Matches", null, this, asyncInvocationRegion.WaitForPendingOperationsToComplete(JSIL.CloneParameter(T, del())));
        return result;
      } finally {
        if (asyncInvocationRegion !== null) {
          $IM00().Call(asyncInvocationRegion, null);
        }
      }
    }
    result = $S07().CallVirtual("Matches", null, this, JSIL.CloneParameter(T, del()));
    return result;
  };

  function Constraint_Matches$b1$06 (T, /* ref */ actual) {
    return $S07().CallVirtual("Matches", null, this, JSIL.CloneParameter(T, actual.get()));
  };

  function Constraint_NUnit_Framework_Constraints_IResolveConstraint_Resolve () {
    return (
      (this.builder === null)
         ? this
         : (this.builder).Resolve())
    ;
  };

  function Constraint_op_BitwiseAnd (left, right) {
    return new ($T0F())($IM01().Call(left, null), $IM01().Call(right, null));
  };

  function Constraint_op_BitwiseOr (left, right) {
    return new ($T11())($IM01().Call(left, null), $IM01().Call(right, null));
  };

  function Constraint_op_LogicalNot (constraint) {
    return new ($T12())((
        (constraint === null)
           ? new ($T13())()
           : $IM01().Call(constraint, null))
    );
  };

  function Constraint_set_DisplayName (value) {
    this.displayName = value;
  };

  function Constraint_SetBuilder (builder) {
    this.builder = builder;
  };

  function Constraint_toString () {
    var stringRepresentation = this.GetStringRepresentation();
    return (
      (this.builder === null)
         ? stringRepresentation
         : $T02().Format("<unresolved {0}>", stringRepresentation))
    ;
  };

  function Constraint_WriteActualValueTo (writer) {
    writer.WriteActualValue(this.actual);
  };

  function Constraint_WriteMessageTo (writer) {
    writer.DisplayDifferences(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.Constraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      Constraint__ctor$00
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      Constraint__ctor$01
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      Constraint__ctor$02
    );

    $.Method({Static:true , Public:false}, "_displayable", 
      new JSIL.MethodSignature($.String, [$.Object]), 
      Constraint__displayable
    );

    $.Method({Static:false, Public:true }, "After", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.DelayedConstraint"), [$.Int32]), 
      Constraint_After$03
    );

    $.Method({Static:false, Public:true }, "After", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.DelayedConstraint"), [$.Int32, $.Int32]), 
      Constraint_After$04
    );

    $.Method({Static:false, Public:true }, "get_And", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Constraint_get_And
    );

    $.Method({Static:false, Public:false}, "get_DisplayName", 
      JSIL.MethodSignature.Return($.String), 
      Constraint_get_DisplayName
    );

    $.Method({Static:false, Public:true }, "get_Or", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Constraint_get_Or
    );

    $.Method({Static:false, Public:true }, "get_With", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      Constraint_get_With
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      Constraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"])], ["T"]), 
      Constraint_Matches$b1$05
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", ["!!0"])], ["T"]), 
      Constraint_Matches$b1$06
    );

    $.Method({Static:false, Public:false, Virtual:true }, "NUnit.Framework.Constraints.IResolveConstraint.Resolve", 
      JSIL.MethodSignature.Return($.Type), 
      Constraint_NUnit_Framework_Constraints_IResolveConstraint_Resolve
    )
      .Overrides($asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), "Resolve");

    $.Method({Static:true , Public:true }, "op_BitwiseAnd", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Constraint_op_BitwiseAnd
    );

    $.Method({Static:true , Public:true }, "op_BitwiseOr", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Constraint_op_BitwiseOr
    );

    $.Method({Static:true , Public:true }, "op_LogicalNot", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Constraint_op_LogicalNot
    );

    $.Method({Static:false, Public:false}, "set_DisplayName", 
      JSIL.MethodSignature.Action($.String), 
      Constraint_set_DisplayName
    );

    $.Method({Static:false, Public:false}, "SetBuilder", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")), 
      Constraint_SetBuilder
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      Constraint_toString
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      Constraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteMessageTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      Constraint_WriteMessageTo
    );

    $.Field({Static:true , Public:false}, "UNSET", $.Object); 
    $.Field({Static:false, Public:false}, "actual", $.Object); 
    $.Field({Static:false, Public:false}, "displayName", $.String); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "argcnt", $.Int32); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "arg1", $.Object); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "arg2", $.Object); 
    $.Field({Static:false, Public:false}, "builder", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")); 
    function Constraint__cctor () {
      $thisType.UNSET = new ($T00())();
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Constraint__cctor
    );

    $.Property({Static:false, Public:false}, "DisplayName", $.String);

    $.Property({Static:false, Public:true }, "And", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "With", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "Or", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.ImplementInterfaces(
      /* 0 */ $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.Constraint+UnsetObject */ 

(function UnsetObject$Members () {
  var $, $thisType;
  function UnsetObject__ctor () {
  };

  function UnsetObject_toString () {
    return "UNSET";
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.Constraint+UnsetObject", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      UnsetObject__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      UnsetObject_toString
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.PrefixConstraint */ 

(function PrefixConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };

  function PrefixConstraint__ctor (resolvable) {
    $T01().prototype._ctor.call(this, resolvable);
    if (resolvable !== null) {
      this.baseConstraint = $IM00().Call(resolvable, null);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.PrefixConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")), 
      PrefixConstraint__ctor
    );

    $.Field({Static:false, Public:false}, "baseConstraint", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AllItemsConstraint */ 

(function AllItemsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function AllItemsConstraint__ctor (itemConstraint) {
    $T01().prototype._ctor.call(this, itemConstraint);
    this.set_DisplayName("all");
  };

  function AllItemsConstraint_Matches (actual) {
    this.actual = actual;
    if (!$T03().$Is(actual)) {
      throw $S00().Construct("The actual value must be an IEnumerable", "actual");
    }
    var enumerator = $IM00().Call($T03().$Cast(actual), null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        if (!$S01().CallVirtual("Matches", null, this.baseConstraint, current)) {
          var result = false;
          return result;
        }
      }
    } finally {
      var disposable = $T07().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    result = true;
    return result;
  };

  function AllItemsConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("all items");
    (this.baseConstraint).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.AllItemsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      AllItemsConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      AllItemsConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AllItemsConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.BinaryConstraint */ 

(function BinaryConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };

  function BinaryConstraint__ctor (left, right) {
    $T00().prototype._ctor.call(this, left, right);
    this.left = left;
    this.right = right;
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.BinaryConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      BinaryConstraint__ctor
    );

    $.Field({Static:false, Public:false}, "left", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")); 
    $.Field({Static:false, Public:false}, "right", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AndConstraint */ 

(function AndConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinaryConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AndConstraint_FailurePoint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };

  function AndConstraint__ctor (left, right) {
    $T01().prototype._ctor.call(this, left, right);
  };

  function AndConstraint_Matches (actual) {
    this.actual = actual;
    this.failurePoint = (
      $S00().CallVirtual("Matches", null, this.left, actual)
         ? (
          $S00().CallVirtual("Matches", null, this.right, actual)
             ? $T03().None
             : $T03().Right)

         : $T03().Left)
    ;
    return (this.failurePoint === $T03().None);
  };

  function AndConstraint_WriteActualValueTo (writer) {
    switch ((this.failurePoint).valueOf()) {
      case 1: 
        (this.left).WriteActualValueTo(writer);
        break;

      case 2: 
        (this.right).WriteActualValueTo(writer);
        break;

      default: 
        $T00().prototype.WriteActualValueTo.call(this, writer);
        break;

    }
  };

  function AndConstraint_WriteDescriptionTo (writer) {
    (this.left).WriteDescriptionTo(writer);
    writer.WriteConnector("and");
    (this.right).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.BinaryConstraint"), 
      Name: "NUnit.Framework.Constraints.AndConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      AndConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      AndConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AndConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AndConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "failurePoint", $asm0B.TypeRef("NUnit.Framework.Constraints.AndConstraint+FailurePoint")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum NUnit.Framework.Constraints.AndConstraint+FailurePoint */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.Constraints.AndConstraint+FailurePoint", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    None: 0, 
    Left: 1, 
    Right: 2, 
  }
);

/* class NUnit.Framework.Constraints.TypeConstraint */ 

(function TypeConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };

  function TypeConstraint__ctor (type) {
    $T01().prototype._ctor.call(this, type);
    this.expectedType = type;
  };

  function TypeConstraint_WriteActualValueTo (writer) {
    writer.WriteActualValue((
        (this.actual === null)
           ? null
           : JSIL.GetType(this.actual))
    );
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.TypeConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      TypeConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      TypeConstraint_WriteActualValueTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expectedType", $asm0A.TypeRef("System.Type")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AssignableFromConstraint */ 

(function AssignableFromConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TypeConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function AssignableFromConstraint__ctor (type) {
    $T01().prototype._ctor.call(this, type);
  };

  function AssignableFromConstraint_Matches (actual) {
    this.actual = actual;
    return ((actual !== null) && (JSIL.GetType(actual)).IsAssignableFrom(this.expectedType));
  };

  function AssignableFromConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("assignable from");
    writer.WriteExpectedValue(this.expectedType);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.TypeConstraint"), 
      Name: "NUnit.Framework.Constraints.AssignableFromConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      AssignableFromConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      AssignableFromConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AssignableFromConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AssignableToConstraint */ 

(function AssignableToConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TypeConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function AssignableToConstraint__ctor (type) {
    $T01().prototype._ctor.call(this, type);
  };

  function AssignableToConstraint_Matches (actual) {
    this.actual = actual;
    return ((actual !== null) && (this.expectedType).IsAssignableFrom(JSIL.GetType(actual)));
  };

  function AssignableToConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("assignable to");
    writer.WriteExpectedValue(this.expectedType);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.TypeConstraint"), 
      Name: "NUnit.Framework.Constraints.AssignableToConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      AssignableToConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      AssignableToConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AssignableToConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AttributeConstraint */ 

(function AttributeConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Reflection.ICustomAttributeProvider)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm0A.System.Attribute))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")]), [$asm0A.TypeRef("System.Type"), $asm0A.TypeRef("System.Boolean")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Reflection.ICustomAttributeProvider.GetCustomAttributes)) ();
  };

  function AttributeConstraint__ctor (type, baseConstraint) {
    $T02().prototype._ctor.call(this, baseConstraint);
    this.expectedType = type;
    if (!$T03().__Type__.IsAssignableFrom(this.expectedType)) {
      throw $S00().Construct($T05().Format("Type {0} is not an attribute", this.expectedType), "type");
    }
  };

  function AttributeConstraint_GetStringRepresentation () {
    return $T05().Format("<attribute {0} {1}>", this.expectedType, this.baseConstraint);
  };

  function AttributeConstraint_Matches (actual) {
    this.actual = actual;
    var customAttributeProvider = $T07().$As(actual);
    if (customAttributeProvider === null) {
      throw $S00().Construct($T05().Format("Actual value {0} does not implement ICustomAttributeProvider", actual), "actual");
    }
    var array = $T08().$Cast($S01().CallVirtual($IM00(), null, customAttributeProvider, this.expectedType, true));
    if ((array.length | 0) === 0) {
      throw $S00().Construct($T05().Format("Attribute {0} was not found", this.expectedType), "actual");
    }
    this.attrFound = array[0];
    return $S02().CallVirtual("Matches", null, this.baseConstraint, this.attrFound);
  };

  function AttributeConstraint_WriteActualValueTo (writer) {
    writer.WriteActualValue(this.attrFound);
  };

  function AttributeConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate(JSIL.ConcatString("attribute ", (this.expectedType).get_FullName()));
    if (this.baseConstraint !== null) {
      if ($T0A().$Is(this.baseConstraint)) {
        writer.WritePredicate("equal to");
      }
      (this.baseConstraint).WriteDescriptionTo(writer);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.AttributeConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Type"), $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      AttributeConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      AttributeConstraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      AttributeConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AttributeConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AttributeConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expectedType", $asm0A.TypeRef("System.Type")); 
    $.Field({Static:false, Public:false}, "attrFound", $asm0A.TypeRef("System.Attribute")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AttributeExistsConstraint */ 

(function AttributeExistsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Attribute)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Reflection.ICustomAttributeProvider)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm0A.System.Object))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Object")]), [$asm0A.TypeRef("System.Type"), $asm0A.TypeRef("System.Boolean")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Reflection.ICustomAttributeProvider.GetCustomAttributes)) ();
  };

  function AttributeExistsConstraint__ctor (type) {
    $T01().prototype._ctor.call(this, type);
    this.expectedType = type;
    if (!$T02().__Type__.IsAssignableFrom(this.expectedType)) {
      throw $S00().Construct($T04().Format("Type {0} is not an attribute", this.expectedType), "type");
    }
  };

  function AttributeExistsConstraint_Matches (actual) {
    this.actual = actual;
    var customAttributeProvider = $T06().$As(actual);
    if (customAttributeProvider === null) {
      throw $S00().Construct($T04().Format("Actual value {0} does not implement ICustomAttributeProvider", actual), "actual");
    }
    return (($S01().CallVirtual($IM00(), null, customAttributeProvider, this.expectedType, true).length | 0) > 0);
  };

  function AttributeExistsConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("type with attribute");
    writer.WriteExpectedValue(this.expectedType);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.AttributeExistsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      AttributeExistsConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      AttributeExistsConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      AttributeExistsConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "expectedType", $asm0A.TypeRef("System.Type")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.BasicConstraint */ 

(function BasicConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function BasicConstraint__ctor (expected, description) {
    $T02().prototype._ctor.call(this);
    this.expected = expected;
    this.description = description;
  };

  function BasicConstraint_Matches (actual) {
    this.actual = actual;
    return (!((actual !== null) || 
        (this.expected !== null)) || ((actual !== null) && 
        (this.expected !== null) && 
        (this.expected).Object_Equals(actual)));
  };

  function BasicConstraint_WriteDescriptionTo (writer) {
    $S00().CallVirtual("Write", null, writer, this.description);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.BasicConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $.String]), 
      BasicConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      BasicConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      BasicConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expected", $.Object); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "description", $.String); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.BinarySerializableConstraint */ 

(function BinarySerializableConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Runtime.Serialization.Formatters.Binary.BinaryFormatter)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.IO.MemoryStream)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IO.Stream)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IO.SeekOrigin)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Runtime.Serialization.SerializationException)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.IO.MemoryStream"), null))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function BinarySerializableConstraint__ctor () {
    this.serializer = $S00().Construct();
    $T01().prototype._ctor.call(this);
  };

  function BinarySerializableConstraint_GetStringRepresentation () {
    return "<binaryserializable>";
  };

  function BinarySerializableConstraint_Matches (actual, $exception) {
    this.actual = actual;
    if (actual === null) {
      throw $S01().Construct();
    }
    var memoryStream = $S02().Construct();
    try {
      (this.serializer).Serialize(memoryStream, actual);
      memoryStream.Seek($T07().Create(0, 0, 0), $T08().Begin);
      var obj = (this.serializer).Deserialize(memoryStream);
      var result = obj !== null;
    } catch ($exception) {
      if ($T0A().$Is($exception)) {
        result = false;
      } else {
        throw $exception;
      }
    }
    return result;
  };

  function BinarySerializableConstraint_WriteActualValueTo (writer) {
    $S03().CallVirtual("Write", null, writer, "<{0}>", (JSIL.GetType(this.actual)).get_Name());
  };

  function BinarySerializableConstraint_WriteDescriptionTo (writer) {
    $S04().CallVirtual("Write", null, writer, "binary serializable");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.BinarySerializableConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      BinarySerializableConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      BinarySerializableConstraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      BinarySerializableConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      BinarySerializableConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      BinarySerializableConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "serializer", $asm0A.TypeRef("System.Runtime.Serialization.Formatters.Binary.BinaryFormatter")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionConstraint */ 

(function CollectionConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.ICollection.get_Count)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function CollectionConstraint__ctor$00 () {
    $T00().prototype._ctor.call(this);
  };

  function CollectionConstraint__ctor$01 (arg) {
    $T00().prototype._ctor.call(this, arg);
  };

  function CollectionConstraint_IsEmpty (enumerable) {
    var collection = $T03().$As(enumerable);
    if (collection !== null) {
      var result = ($IM00().Call(collection, null) | 0) === 0;
    } else {
      var enumerator = $IM01().Call(enumerable, null);
      try {
        if ($IM02().Call(enumerator, null)) {
          var current = $IM03().Call(enumerator, null);
          result = false;
          return result;
        }
      } finally {
        var disposable = $T06().$As(enumerator);
        if (disposable !== null) {
          $IM04().Call(disposable, null);
        }
      }
      result = true;
    }
    return result;
  };

  function CollectionConstraint_Matches (actual) {
    this.actual = actual;
    var enumerable = $T02().$As(actual);
    if (enumerable === null) {
      throw $S00().Construct("The actual value must be an IEnumerable", "actual");
    }
    return this.doMatch(enumerable);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.CollectionConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      CollectionConstraint__ctor$00
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      CollectionConstraint__ctor$01
    );

    $.Method({Static:true , Public:false}, "IsEmpty", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionConstraint_IsEmpty
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      CollectionConstraint_Matches
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionItemsEqualConstraint */ 

(function CollectionItemsEqualConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NUnitEqualityComparer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Tolerance)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionTally)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Collections.Generic.ICollection$b1.Of($asm0B.NUnit.Framework.Constraints.EqualityAdapter))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Collections.IEqualityComparer)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionItemsEqualConstraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.IComparer")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.IEqualityComparer")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", ["!!0"])], ["T"]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.Generic.ICollection$b1.Of($asm0B.NUnit.Framework.Constraints.EqualityAdapter).Add)) ();
  };

  function CollectionItemsEqualConstraint__ctor$00 () {
    this.comparer = $T00().get_Default();
    $T01().prototype._ctor.call(this);
  };

  function CollectionItemsEqualConstraint__ctor$01 (arg) {
    this.comparer = $T00().get_Default();
    $T01().prototype._ctor.call(this, arg);
  };

  function CollectionItemsEqualConstraint_get_IgnoreCase () {
    (this.comparer).set_IgnoreCase(true);
    return this;
  };

  function CollectionItemsEqualConstraint_ItemsEqual (x, y) {
    var zero = new JSIL.BoxedVariable($T03().get_Zero());
    return (this.comparer).AreEqual(x, y, /* ref */ zero);
  };

  function CollectionItemsEqualConstraint_Tally (c) {
    return new ($T05())(this.comparer, c);
  };

  function CollectionItemsEqualConstraint_Using$02 (adapter) {
    $IM00().Call((this.comparer).get_ExternalComparers(), null, adapter);
    return this;
  };

  function CollectionItemsEqualConstraint_Using$03 (comparer) {
    return $S00().CallVirtual("Using", null, this, $S01().CallStatic($T06(), "For", null, comparer));
  };

  function CollectionItemsEqualConstraint_Using$b1$04 (T, comparer) {
    return $S00().CallVirtual("Using", null, this, $S02().CallStatic($T06(), "For$b1", [T], comparer));
  };

  function CollectionItemsEqualConstraint_Using$b1$05 (T, comparer) {
    return $S00().CallVirtual("Using", null, this, $S03().CallStatic($T06(), "For$b1", [T], comparer));
  };

  function CollectionItemsEqualConstraint_Using$06 (comparer) {
    return $S00().CallVirtual("Using", null, this, $S04().CallStatic($T06(), "For", null, comparer));
  };

  function CollectionItemsEqualConstraint_Using$b1$07 (T, comparer) {
    return $S00().CallVirtual("Using", null, this, $S05().CallStatic($T06(), "For$b1", [T], comparer));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionConstraint"), 
      Name: "NUnit.Framework.Constraints.CollectionItemsEqualConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      CollectionItemsEqualConstraint__ctor$00
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      CollectionItemsEqualConstraint__ctor$01
    );

    $.Method({Static:false, Public:true }, "get_IgnoreCase", 
      JSIL.MethodSignature.Return($.Type), 
      CollectionItemsEqualConstraint_get_IgnoreCase
    );

    $.Method({Static:false, Public:false}, "ItemsEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      CollectionItemsEqualConstraint_ItemsEqual
    );

    $.Method({Static:false, Public:false}, "Tally", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionTally"), [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionItemsEqualConstraint_Tally
    );

    $.Method({Static:false, Public:false}, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")]), 
      CollectionItemsEqualConstraint_Using$02
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      CollectionItemsEqualConstraint_Using$03
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]), 
      CollectionItemsEqualConstraint_Using$b1$04
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]), 
      CollectionItemsEqualConstraint_Using$b1$05
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IEqualityComparer")]), 
      CollectionItemsEqualConstraint_Using$06
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", ["!!0"])], ["T"]), 
      CollectionItemsEqualConstraint_Using$b1$07
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "comparer", $asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer")); 
    $.Property({Static:false, Public:true }, "IgnoreCase", $.Type);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionContainsConstraint */ 

(function CollectionContainsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionItemsEqualConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function CollectionContainsConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
    this.set_DisplayName("contains");
  };

  function CollectionContainsConstraint_doMatch (actual) {
    var enumerator = $IM00().Call(actual, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        if (this.ItemsEqual(current, this.expected)) {
          var result = true;
          return result;
        }
      }
    } finally {
      var disposable = $T06().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    result = false;
    return result;
  };

  function CollectionContainsConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("collection containing");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionItemsEqualConstraint"), 
      Name: "NUnit.Framework.Constraints.CollectionContainsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      CollectionContainsConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "doMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionContainsConstraint_doMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      CollectionContainsConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expected", $.Object); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionEquivalentConstraint */ 

(function CollectionEquivalentConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionItemsEqualConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionTally)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Collections.IEnumerable")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.ICollection.get_Count)) ();
  };

  function CollectionEquivalentConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
    this.set_DisplayName("equivalent");
  };

  function CollectionEquivalentConstraint_doMatch (actual) {
    if (!(($T03().$As(this.expected) === null) || 
        !$T03().$Is(actual) || (($IM00().Call($T03().$Cast(actual), null) | 0) === ($IM00().Call($T03().$Cast(this.expected), null) | 0)))) {
      var result = false;
    } else {
      var collectionTally = this.Tally(this.expected);
      result = $S00().CallVirtual("TryRemove", null, collectionTally, actual) && 
      ((collectionTally.get_Count() | 0) === 0);
    }
    return result;
  };

  function CollectionEquivalentConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("equivalent to");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionItemsEqualConstraint"), 
      Name: "NUnit.Framework.Constraints.CollectionEquivalentConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      CollectionEquivalentConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "doMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionEquivalentConstraint_doMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      CollectionEquivalentConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expected", $asm0A.TypeRef("System.Collections.IEnumerable")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionOrderedConstraint */ 

(function CollectionOrderedConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.ArgumentNullException)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Reflection.PropertyInfo)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.Text.StringBuilder)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentNullException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Text.StringBuilder"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Text.StringBuilder"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter"), [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function CollectionOrderedConstraint__ctor () {
    this.comparer = $T00().get_Default();
    $T01().prototype._ctor.call(this);
    this.set_DisplayName("ordered");
  };

  function CollectionOrderedConstraint_By (propertyName) {
    this.propertyName = propertyName;
    return this;
  };

  function CollectionOrderedConstraint_doMatch (actual) {
    var obj = null;
    var num = 0;
    var enumerator = $IM00().Call(actual, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        var obj2 = current;
        if (current === null) {
          throw $S00().Construct("actual", JSIL.ConcatString("Null value at index ", (num).toString()));
        }
        if (this.propertyName !== null) {
          var property = (JSIL.GetType(current)).GetProperty(this.propertyName);
          obj2 = property.GetValue(current, null);
          if (obj2 === null) {
            throw $S00().Construct("actual", JSIL.ConcatString("Null property value at index ", (num).toString()));
          }
        }
        if (obj !== null) {
          var num2 = ((this.comparer).Compare(obj, obj2) | 0);
          if (!(!this.descending || (num2 >= 0))) {
            var result = false;
            return result;
          }
          if (!(this.descending || (num2 <= 0))) {
            result = false;
            return result;
          }
        }
        obj = obj2;
        num = ((num + 1) | 0);
      }
    } finally {
      var disposable = $T0C().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    result = true;
    return result;
  };

  function CollectionOrderedConstraint_get_Descending () {
    this.descending = true;
    return this;
  };

  function CollectionOrderedConstraint_GetStringRepresentation () {
    var stringBuilder = $S01().Construct("<ordered");
    if (this.propertyName !== null) {
      $S02().CallVirtual("Append", null, stringBuilder, JSIL.ConcatString("by ", this.propertyName));
    }
    if (this.descending) {
      $S02().CallVirtual("Append", null, stringBuilder, " descending");
    }
    if (this.comparerName !== null) {
      $S02().CallVirtual("Append", null, stringBuilder, JSIL.ConcatString(" ", this.comparerName));
    }
    $S02().CallVirtual("Append", null, stringBuilder, ">");
    return stringBuilder.toString();
  };

  function CollectionOrderedConstraint_Using (comparer) {
    this.comparer = $T00().For(comparer);
    this.comparerName = (JSIL.GetType(comparer)).get_FullName();
    return this;
  };

  function CollectionOrderedConstraint_Using$b1$00 (T, comparer) {
    this.comparer = $S03().CallStatic($T00(), "For$b1", [T], comparer);
    this.comparerName = (JSIL.GetType(comparer)).get_FullName();
    return this;
  };

  function CollectionOrderedConstraint_Using$b1$01 (T, comparer) {
    this.comparer = $S04().CallStatic($T00(), "For$b1", [T], comparer);
    this.comparerName = (JSIL.GetType(comparer)).get_FullName();
    return this;
  };

  function CollectionOrderedConstraint_WriteDescriptionTo (writer) {
    if (this.propertyName === null) {
      $S05().CallVirtual("Write", null, writer, "collection ordered");
    } else {
      writer.WritePredicate("collection ordered by");
      writer.WriteExpectedValue(this.propertyName);
    }
    if (this.descending) {
      writer.WriteModifier("descending");
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionConstraint"), 
      Name: "NUnit.Framework.Constraints.CollectionOrderedConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      CollectionOrderedConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "By", 
      new JSIL.MethodSignature($.Type, [$.String]), 
      CollectionOrderedConstraint_By
    );

    $.Method({Static:false, Public:false, Virtual:true }, "doMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionOrderedConstraint_doMatch
    );

    $.Method({Static:false, Public:true }, "get_Descending", 
      JSIL.MethodSignature.Return($.Type), 
      CollectionOrderedConstraint_get_Descending
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      CollectionOrderedConstraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      CollectionOrderedConstraint_Using
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]), 
      CollectionOrderedConstraint_Using$b1$00
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]), 
      CollectionOrderedConstraint_Using$b1$01
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      CollectionOrderedConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "comparer", $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter")); 
    $.Field({Static:false, Public:false}, "comparerName", $.String); 
    $.Field({Static:false, Public:false}, "propertyName", $.String); 
    $.Field({Static:false, Public:false}, "descending", $.Boolean); 
    $.Property({Static:false, Public:true }, "Descending", $.Type);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionSubsetConstraint */ 

(function CollectionSubsetConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionItemsEqualConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionTally)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Collections.IEnumerable")]))) ();
  };

  function CollectionSubsetConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
    this.set_DisplayName("subsetof");
  };

  function CollectionSubsetConstraint_doMatch (actual) {
    return $S00().CallVirtual("TryRemove", null, this.Tally(this.expected), actual);
  };

  function CollectionSubsetConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("subset of");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionItemsEqualConstraint"), 
      Name: "NUnit.Framework.Constraints.CollectionSubsetConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEnumerable")), 
      CollectionSubsetConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "doMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionSubsetConstraint_doMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      CollectionSubsetConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "expected", $asm0A.TypeRef("System.Collections.IEnumerable")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionTally */ 

(function CollectionTally$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NUnitEqualityComparer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Collections.ArrayList)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Tolerance)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.ArrayList"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function CollectionTally__ctor (comparer, c) {
    this.list = $S00().Construct();
    this.comparer = comparer;
    var enumerator = $IM00().Call(c, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        (this.list).Add(current);
      }
    } finally {
      var disposable = $T05().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
  };

  function CollectionTally_get_Count () {
    return (this.list).get_Count();
  };

  function CollectionTally_ItemsEqual (expected, actual) {
    var zero = new JSIL.BoxedVariable($T06().get_Zero());
    return (this.comparer).AreEqual(expected, actual, /* ref */ zero);
  };

  function CollectionTally_TryRemove$00 (o) {

    for (var i = 0; i < ((this.list).get_Count() | 0); i = ((i + 1) | 0)) {
      if (this.ItemsEqual((this.list).get_Item(i), o)) {
        (this.list).RemoveAt(i);
        var result = true;
        return result;
      }
    }
    result = false;
    return result;
  };

  function CollectionTally_TryRemove$01 (c) {
    var enumerator = $IM00().Call(c, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        if (!$S01().CallVirtual("TryRemove", null, this, current)) {
          var result = false;
          return result;
        }
      }
    } finally {
      var disposable = $T05().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    result = true;
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.CollectionTally", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionTally__ctor
    );

    $.Method({Static:false, Public:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32), 
      CollectionTally_get_Count
    );

    $.Method({Static:false, Public:false}, "ItemsEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      CollectionTally_ItemsEqual
    );

    $.Method({Static:false, Public:true }, "TryRemove", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      CollectionTally_TryRemove$00
    );

    $.Method({Static:false, Public:true }, "TryRemove", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      CollectionTally_TryRemove$01
    );

    $.Field({Static:false, Public:false}, "list", $asm0A.TypeRef("System.Collections.ArrayList")); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "comparer", $asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer")); 
    $.Property({Static:false, Public:true }, "Count", $.Int32);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ComparisonAdapter */ 

(function ComparisonAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter_ComparerAdapter)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter_DefaultComparisonAdapter)) ();
  };

  function ComparisonAdapter__ctor () {
  };

  function ComparisonAdapter_For (comparer) {
    return new ($T01())(comparer);
  };

  function ComparisonAdapter_For$b1$00 (T, comparer) {
    return new ($asm0B.NUnit.Framework.Constraints.ComparisonAdapter_ComparerAdapter$b1.Of(T)) (comparer);
  };

  function ComparisonAdapter_For$b1$01 (T, comparer) {
    return new ($asm0B.NUnit.Framework.Constraints.ComparisonAdapter_ComparisonAdapterForComparison$b1.Of(T)) (comparer);
  };

  function ComparisonAdapter_get_Default () {
    return new ($T03())();
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ComparisonAdapter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      ComparisonAdapter__ctor
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      ComparisonAdapter_For
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]), 
      ComparisonAdapter_For$b1$00
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]), 
      ComparisonAdapter_For$b1$01
    );

    $.Method({Static:true , Public:true }, "get_Default", 
      JSIL.MethodSignature.Return($.Type), 
      ComparisonAdapter_get_Default
    );

    $.Property({Static:true , Public:true }, "Default", $.Type);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ComparisonAdapter+ComparerAdapter */ 

(function ComparerAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IComparer.Compare)) ();
  };

  function ComparerAdapter__ctor (comparer) {
    $T01().prototype._ctor.call(this);
    this.comparer = comparer;
  };

  function ComparerAdapter_Compare (expected, actual) {
    return $IM00().Call(this.comparer, null, expected, actual);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter"), 
      Name: "NUnit.Framework.Constraints.ComparisonAdapter+ComparerAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IComparer")), 
      ComparerAdapter__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$.Object, $.Object]), 
      ComparerAdapter_Compare
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "comparer", $asm0A.TypeRef("System.Collections.IComparer")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ComparisonAdapter+DefaultComparisonAdapter */ 

(function DefaultComparisonAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter_ComparerAdapter)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NUnitComparer)) ();
  };

  function DefaultComparisonAdapter__ctor () {
    $T00().prototype._ctor.call(this, $T01().get_Default());
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter+ComparerAdapter"), 
      Name: "NUnit.Framework.Constraints.ComparisonAdapter+DefaultComparisonAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      DefaultComparisonAdapter__ctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ComparisonAdapter+ComparerAdapter`1 */ 

(function ComparerAdapter$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function ComparerAdapter$b1__ctor (comparer) {
    $T00().prototype._ctor.call(this);
    this.comparer = comparer;
  };

  function ComparerAdapter$b1_Compare (expected, actual) {
    var $im00 = $asm0A.System.Collections.Generic.IComparer$b1.Of($thisType.T.get(this)).Compare;
    if (!$thisType.T.get(this).IsAssignableFrom(JSIL.GetType(expected))) {
      throw $S00().Construct(JSIL.ConcatString("Cannot compare ", expected.toString()));
    }
    if (!$thisType.T.get(this).IsAssignableFrom(JSIL.GetType(actual))) {
      throw $S00().Construct(JSIL.ConcatString("Cannot compare to ", actual.toString()));
    }
    return $im00.Call(this.comparer, null, JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(expected)), JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(actual)));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter"), 
      Name: "NUnit.Framework.Constraints.ComparisonAdapter+ComparerAdapter`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")])]), 
      ComparerAdapter$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$.Object, $.Object]), 
      ComparerAdapter$b1_Compare
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "comparer", $asm0A.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ComparisonAdapter+ComparisonAdapterForComparison`1 */ 

(function ComparisonAdapterForComparison$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function ComparisonAdapterForComparison$b1__ctor (comparer) {
    $T00().prototype._ctor.call(this);
    this.comparison = comparer;
  };

  function ComparisonAdapterForComparison$b1_Compare (expected, actual) {
    if (!$thisType.T.get(this).IsAssignableFrom(JSIL.GetType(expected))) {
      throw $S00().Construct(JSIL.ConcatString("Cannot compare ", expected.toString()));
    }
    if (!$thisType.T.get(this).IsAssignableFrom(JSIL.GetType(actual))) {
      throw $S00().Construct(JSIL.ConcatString("Cannot compare to ", actual.toString()));
    }
    return this.comparison(JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(expected)), JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(actual)));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter"), 
      Name: "NUnit.Framework.Constraints.ComparisonAdapter+ComparisonAdapterForComparison`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Comparison`1", [$.GenericParameter("T")])]), 
      ComparisonAdapterForComparison$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$.Object, $.Object]), 
      ComparisonAdapterForComparison$b1_Compare
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "comparison", $asm0A.TypeRef("System.Comparison`1", [$.GenericParameter("T")])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ComparisonConstraint */ 

(function ComparisonConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter"), [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]))) ();
  };

  function ComparisonConstraint__ctor$00 (arg) {
    this.comparer = $T01().get_Default();
    $T02().prototype._ctor.call(this, arg);
  };

  function ComparisonConstraint__ctor$01 (arg1, arg2) {
    this.comparer = $T01().get_Default();
    $T02().prototype._ctor.call(this, arg1, arg2);
  };

  function ComparisonConstraint_Using (comparer) {
    this.comparer = $T01().For(comparer);
    return this;
  };

  function ComparisonConstraint_Using$b1$02 (T, comparer) {
    this.comparer = $S00().CallStatic($T01(), "For$b1", [T], comparer);
    return this;
  };

  function ComparisonConstraint_Using$b1$03 (T, comparer) {
    this.comparer = $S01().CallStatic($T01(), "For$b1", [T], comparer);
    return this;
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.ComparisonConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      ComparisonConstraint__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      ComparisonConstraint__ctor$01
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      ComparisonConstraint_Using
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]), 
      ComparisonConstraint_Using$b1$02
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]), 
      ComparisonConstraint_Using$b1$03
    );

    $.Field({Static:false, Public:false}, "comparer", $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonAdapter")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate NUnit.Framework.Constraints.ActualValueDelegate`1 */ 

JSIL.MakeDelegate("NUnit.Framework.Constraints.ActualValueDelegate`1", true, ["T"], 
  new JSIL.MethodSignature(new JSIL.GenericParameter("T", "NUnit.Framework.Constraints.ActualValueDelegate`1"), null));

/* class NUnit.Framework.Constraints.ConstraintBuilder */ 

(function ConstraintBuilder$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder_OperatorStack)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder_ConstraintStack)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SelfResolvingOperator)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.InvalidOperationException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function ConstraintBuilder__ctor () {
    this.ops = new ($T00())(this);
    this.constraints = new ($T01())(this);
  };

  function ConstraintBuilder_Append$00 (op) {
    op.set_LeftContext(this.lastPushed);
    if ($T02().$Is(this.lastPushed)) {
      this.SetTopOperatorRightContext(op);
    }
    this.ReduceOperatorStack(op.get_LeftPrecedence());
    (this.ops).Push(op);
    this.lastPushed = op;
  };

  function ConstraintBuilder_Append$01 (constraint) {
    if ($T02().$Is(this.lastPushed)) {
      this.SetTopOperatorRightContext(constraint);
    }
    (this.constraints).Push(constraint);
    this.lastPushed = constraint;
    constraint.SetBuilder(this);
  };

  function ConstraintBuilder_get_IsResolvable () {
    return (($T03().$As(this.lastPushed) !== null) || $T04().$Is(this.lastPushed));
  };

  function ConstraintBuilder_ReduceOperatorStack (targetPrecedence) {

    while (!(this.ops).get_Empty() && ((((this.ops).get_Top()).get_RightPrecedence() | 0) < (targetPrecedence | 0))) {
      ((this.ops).Pop()).Reduce(this.constraints);
    }
  };

  function ConstraintBuilder_Resolve () {
    if (!this.get_IsResolvable()) {
      throw $S00().Construct("A partial expression may not be resolved");
    }

    while (!(this.ops).get_Empty()) {
      var constraintOperator = (this.ops).Pop();
      constraintOperator.Reduce(this.constraints);
    }
    return (this.constraints).Pop();
  };

  function ConstraintBuilder_SetTopOperatorRightContext (rightContext) {
    var leftPrecedence = (((this.ops).get_Top()).get_LeftPrecedence() | 0);
    ((this.ops).get_Top()).set_RightContext(rightContext);
    if ((((this.ops).get_Top()).get_LeftPrecedence() | 0) > leftPrecedence) {
      var constraintOperator = (this.ops).Pop();
      this.ReduceOperatorStack(constraintOperator.get_LeftPrecedence());
      (this.ops).Push(constraintOperator);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ConstraintBuilder", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConstraintBuilder__ctor
    );

    $.Method({Static:false, Public:true }, "Append", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")), 
      ConstraintBuilder_Append$00
    );

    $.Method({Static:false, Public:true }, "Append", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ConstraintBuilder_Append$01
    );

    $.Method({Static:false, Public:true }, "get_IsResolvable", 
      JSIL.MethodSignature.Return($.Boolean), 
      ConstraintBuilder_get_IsResolvable
    );

    $.Method({Static:false, Public:false}, "ReduceOperatorStack", 
      JSIL.MethodSignature.Action($.Int32), 
      ConstraintBuilder_ReduceOperatorStack
    );

    $.Method({Static:false, Public:true }, "Resolve", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ConstraintBuilder_Resolve
    );

    $.Method({Static:false, Public:false}, "SetTopOperatorRightContext", 
      JSIL.MethodSignature.Action($.Object), 
      ConstraintBuilder_SetTopOperatorRightContext
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "ops", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder+OperatorStack")); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "constraints", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack")); 
    $.Field({Static:false, Public:false}, "lastPushed", $.Object); 
    $.Property({Static:false, Public:true }, "IsResolvable", $.Boolean);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ConstraintBuilder+OperatorStack */ 

(function OperatorStack$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0D.System.Collections.Generic.Stack$b1.Of($asm0B.NUnit.Framework.Constraints.ConstraintOperator))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.TypeRef("System.Collections.Generic.Stack`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")]), null))) ();
  };

  function OperatorStack__ctor (builder) {
    this.stack = $S00().Construct();
  };

  function OperatorStack_get_Empty () {
    return (((this.stack).get_Count() | 0) === 0);
  };

  function OperatorStack_get_Top () {
    return $T01().prototype.Peek.call(this.stack);
  };

  function OperatorStack_Pop () {
    return $T01().prototype.Pop.call(this.stack);
  };

  function OperatorStack_Push (op) {
    $T01().prototype.Push.call(this.stack, op);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ConstraintBuilder+OperatorStack", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")), 
      OperatorStack__ctor
    );

    $.Method({Static:false, Public:true }, "get_Empty", 
      JSIL.MethodSignature.Return($.Boolean), 
      OperatorStack_get_Empty
    );

    $.Method({Static:false, Public:true }, "get_Top", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")), 
      OperatorStack_get_Top
    );

    $.Method({Static:false, Public:true }, "Pop", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")), 
      OperatorStack_Pop
    );

    $.Method({Static:false, Public:true }, "Push", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")), 
      OperatorStack_Push
    );

    $.Field({Static:false, Public:false}, "stack", $asm0D.TypeRef("System.Collections.Generic.Stack`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")])); 
    $.Property({Static:false, Public:true }, "Empty", $.Boolean);

    $.Property({Static:false, Public:true }, "Top", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack */ 

(function ConstraintStack$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0D.System.Collections.Generic.Stack$b1.Of($asm0B.NUnit.Framework.Constraints.Constraint))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0D.TypeRef("System.Collections.Generic.Stack`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), null))) ();
  };

  function ConstraintStack__ctor (builder) {
    this.stack = $S00().Construct();
    this.builder = builder;
  };

  function ConstraintStack_get_Empty () {
    return (((this.stack).get_Count() | 0) === 0);
  };

  function ConstraintStack_get_Top () {
    return $T01().prototype.Peek.call(this.stack);
  };

  function ConstraintStack_Pop () {
    var constraint = $T01().prototype.Pop.call(this.stack);
    constraint.SetBuilder(null);
    return constraint;
  };

  function ConstraintStack_Push (constraint) {
    $T01().prototype.Push.call(this.stack, constraint);
    constraint.SetBuilder(this.builder);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")), 
      ConstraintStack__ctor
    );

    $.Method({Static:false, Public:true }, "get_Empty", 
      JSIL.MethodSignature.Return($.Boolean), 
      ConstraintStack_get_Empty
    );

    $.Method({Static:false, Public:true }, "get_Top", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ConstraintStack_get_Top
    );

    $.Method({Static:false, Public:true }, "Pop", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ConstraintStack_Pop
    );

    $.Method({Static:false, Public:true }, "Push", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ConstraintStack_Push
    );

    $.Field({Static:false, Public:false}, "stack", $asm0D.TypeRef("System.Collections.Generic.Stack`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")])); 
    $.Field({Static:false, Public:false}, "builder", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")); 
    $.Property({Static:false, Public:true }, "Empty", $.Boolean);

    $.Property({Static:false, Public:true }, "Top", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ConstraintExpressionBase */ 

(function ConstraintExpressionBase$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SelfResolvingOperator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ResolvableConstraintExpression)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")))) ();
  };

  function ConstraintExpressionBase__ctor$00 () {
    this.builder = new ($T00())();
  };

  function ConstraintExpressionBase__ctor$01 (builder) {
    this.builder = builder;
  };

  function ConstraintExpressionBase_Append$02 (op) {
    $S00().CallVirtual("Append", null, this.builder, op);
    return $T02().$Cast(this);
  };

  function ConstraintExpressionBase_Append$03 (op) {
    $S00().CallVirtual("Append", null, this.builder, op);
    return $S01().Construct(this.builder);
  };

  function ConstraintExpressionBase_Append$04 (constraint) {
    $S02().CallVirtual("Append", null, this.builder, constraint);
    return constraint;
  };

  function ConstraintExpressionBase_toString () {
    return ((this.builder).Resolve()).toString();
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ConstraintExpressionBase", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConstraintExpressionBase__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")), 
      ConstraintExpressionBase__ctor$01
    );

    $.Method({Static:false, Public:true }, "Append", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")]), 
      ConstraintExpressionBase_Append$02
    );

    $.Method({Static:false, Public:true }, "Append", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.SelfResolvingOperator")]), 
      ConstraintExpressionBase_Append$03
    );

    $.Method({Static:false, Public:true }, "Append", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      ConstraintExpressionBase_Append$04
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      ConstraintExpressionBase_toString
    );

    $.Field({Static:false, Public:false}, "builder", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ConstraintExpression */ 

(function ConstraintExpression$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpressionBase)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AssignableFromConstraint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AssignableToConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.GreaterThanOrEqualConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.LessThanOrEqualConstraint)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AttributeOperator)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionContainsConstraint)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ContainsConstraint)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubstringConstraint)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EndsWithConstraint)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionEquivalentConstraint)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExactCountOperator)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AllOperator)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinarySerializableConstraint)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyConstraint)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FalseConstraint)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NaNConstraint)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.LessThanConstraint)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotOperator)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NoneOperator)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NullConstraint)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOrderedConstraint)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.GreaterThanConstraint)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SomeOperator)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TrueConstraint)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.UniqueItemsConstraint)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.WithOperator)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.XmlSerializableConstraint)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.InstanceOfTypeConstraint)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.RegexConstraint)) ();
  };
  var $T26 = function () {
    return ($T26 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PropOperator)) ();
  };
  var $T27 = function () {
    return ($T27 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SameAsConstraint)) ();
  };
  var $T28 = function () {
    return ($T28 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SamePathConstraint)) ();
  };
  var $T29 = function () {
    return ($T29 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SamePathOrUnderConstraint)) ();
  };
  var $T2A = function () {
    return ($T2A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StartsWithConstraint)) ();
  };
  var $T2B = function () {
    return ($T2B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubPathConstraint)) ();
  };
  var $T2C = function () {
    return ($T2C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionSubsetConstraint)) ();
  };
  var $T2D = function () {
    return ($T2D = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExactTypeConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.SelfResolvingOperator")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };

  function ConstraintExpression__ctor$00 () {
    $T00().prototype._ctor.call(this);
  };

  function ConstraintExpression__ctor$01 (builder) {
    $T00().prototype._ctor.call(this, builder);
  };

  function ConstraintExpression_AssignableFrom (expectedType) {
    return $T03().$Cast($S00().CallVirtual("Append", null, this, new ($T03())(expectedType)));
  };

  function ConstraintExpression_AssignableFrom$b1 (T) {
    return $T03().$Cast($S00().CallVirtual("Append", null, this, new ($T03())(T)));
  };

  function ConstraintExpression_AssignableTo (expectedType) {
    return $T04().$Cast($S00().CallVirtual("Append", null, this, new ($T04())(expectedType)));
  };

  function ConstraintExpression_AssignableTo$b1 (T) {
    return $T04().$Cast($S00().CallVirtual("Append", null, this, new ($T04())(T)));
  };

  function ConstraintExpression_AtLeast (expected) {
    return $T06().$Cast($S00().CallVirtual("Append", null, this, new ($T06())(expected)));
  };

  function ConstraintExpression_AtMost (expected) {
    return $T07().$Cast($S00().CallVirtual("Append", null, this, new ($T07())(expected)));
  };

  function ConstraintExpression_Attribute (expectedType) {
    return $S01().CallVirtual("Append", null, this, new ($T08())(expectedType));
  };

  function ConstraintExpression_Attribute$b1 (T) {
    return this.Attribute(T);
  };

  function ConstraintExpression_Contains$02 (expected) {
    return $T09().$Cast($S00().CallVirtual("Append", null, this, new ($T09())(expected)));
  };

  function ConstraintExpression_Contains$03 (expected) {
    return $T0B().$Cast($S00().CallVirtual("Append", null, this, new ($T0B())(expected)));
  };

  function ConstraintExpression_ContainsSubstring (expected) {
    return $T0C().$Cast($S00().CallVirtual("Append", null, this, new ($T0C())(expected)));
  };

  function ConstraintExpression_EndsWith (expected) {
    return $T0D().$Cast($S00().CallVirtual("Append", null, this, new ($T0D())(expected)));
  };

  function ConstraintExpression_EqualTo (expected) {
    return $T0E().$Cast($S00().CallVirtual("Append", null, this, new ($T0E())(expected)));
  };

  function ConstraintExpression_EquivalentTo (expected) {
    return $T10().$Cast($S00().CallVirtual("Append", null, this, new ($T10())(expected)));
  };

  function ConstraintExpression_Exactly (expectedCount) {
    return $S02().CallVirtual("Append", null, this, new ($T12())(expectedCount));
  };

  function ConstraintExpression_get_All () {
    return $S02().CallVirtual("Append", null, this, new ($T13())());
  };

  function ConstraintExpression_get_BinarySerializable () {
    return $T14().$Cast($S00().CallVirtual("Append", null, this, new ($T14())()));
  };

  function ConstraintExpression_get_Count () {
    return this.Property("Count");
  };

  function ConstraintExpression_get_Empty () {
    return $T15().$Cast($S00().CallVirtual("Append", null, this, new ($T15())()));
  };

  function ConstraintExpression_get_False () {
    return $T16().$Cast($S00().CallVirtual("Append", null, this, new ($T16())()));
  };

  function ConstraintExpression_get_InnerException () {
    return this.Property("InnerException");
  };

  function ConstraintExpression_get_Length () {
    return this.Property("Length");
  };

  function ConstraintExpression_get_Message () {
    return this.Property("Message");
  };

  function ConstraintExpression_get_NaN () {
    return $T17().$Cast($S00().CallVirtual("Append", null, this, new ($T17())()));
  };

  function ConstraintExpression_get_Negative () {
    return $T18().$Cast($S00().CallVirtual("Append", null, this, new ($T18())(0)));
  };

  function ConstraintExpression_get_No () {
    return $S02().CallVirtual("Append", null, this, new ($T19())());
  };

  function ConstraintExpression_get_None () {
    return $S02().CallVirtual("Append", null, this, new ($T1A())());
  };

  function ConstraintExpression_get_Not () {
    return $S02().CallVirtual("Append", null, this, new ($T19())());
  };

  function ConstraintExpression_get_Null () {
    return $T1B().$Cast($S00().CallVirtual("Append", null, this, new ($T1B())()));
  };

  function ConstraintExpression_get_Ordered () {
    return $T1C().$Cast($S00().CallVirtual("Append", null, this, new ($T1C())()));
  };

  function ConstraintExpression_get_Positive () {
    return $T1D().$Cast($S00().CallVirtual("Append", null, this, new ($T1D())(0)));
  };

  function ConstraintExpression_get_Some () {
    return $S02().CallVirtual("Append", null, this, new ($T1E())());
  };

  function ConstraintExpression_get_True () {
    return $T1F().$Cast($S00().CallVirtual("Append", null, this, new ($T1F())()));
  };

  function ConstraintExpression_get_Unique () {
    return $T20().$Cast($S00().CallVirtual("Append", null, this, new ($T20())()));
  };

  function ConstraintExpression_get_With () {
    return $S02().CallVirtual("Append", null, this, new ($T21())());
  };

  function ConstraintExpression_get_XmlSerializable () {
    return $T22().$Cast($S00().CallVirtual("Append", null, this, new ($T22())()));
  };

  function ConstraintExpression_GreaterThan (expected) {
    return $T1D().$Cast($S00().CallVirtual("Append", null, this, new ($T1D())(expected)));
  };

  function ConstraintExpression_GreaterThanOrEqualTo (expected) {
    return $T06().$Cast($S00().CallVirtual("Append", null, this, new ($T06())(expected)));
  };

  function ConstraintExpression_InRange$b1 (T, from, to) {
    return $asm0B.NUnit.Framework.Constraints.RangeConstraint$b1.Of(T).$Cast($S00().CallVirtual("Append", null, this, new ($asm0B.NUnit.Framework.Constraints.RangeConstraint$b1.Of(T)) (JSIL.CloneParameter(T, from), JSIL.CloneParameter(T, to))));
  };

  function ConstraintExpression_InstanceOf (expectedType) {
    return $T23().$Cast($S00().CallVirtual("Append", null, this, new ($T23())(expectedType)));
  };

  function ConstraintExpression_InstanceOf$b1 (T) {
    return $T23().$Cast($S00().CallVirtual("Append", null, this, new ($T23())(T)));
  };

  function ConstraintExpression_InstanceOfType (expectedType) {
    return $T23().$Cast($S00().CallVirtual("Append", null, this, new ($T23())(expectedType)));
  };

  function ConstraintExpression_InstanceOfType$b1 (T) {
    return $T23().$Cast($S00().CallVirtual("Append", null, this, new ($T23())(T)));
  };

  function ConstraintExpression_LessThan (expected) {
    return $T18().$Cast($S00().CallVirtual("Append", null, this, new ($T18())(expected)));
  };

  function ConstraintExpression_LessThanOrEqualTo (expected) {
    return $T07().$Cast($S00().CallVirtual("Append", null, this, new ($T07())(expected)));
  };

  function ConstraintExpression_Matches$04 (constraint) {
    return $S00().CallVirtual("Append", null, this, $IM00().Call(constraint, null));
  };

  function ConstraintExpression_Matches$b1 (T, predicate) {
    return $S00().CallVirtual("Append", null, this, new ($asm0B.NUnit.Framework.Constraints.PredicateConstraint$b1.Of(T)) (predicate));
  };

  function ConstraintExpression_Matches$05 (pattern) {
    return $T25().$Cast($S00().CallVirtual("Append", null, this, new ($T25())(pattern)));
  };

  function ConstraintExpression_Member (expected) {
    return $T09().$Cast($S00().CallVirtual("Append", null, this, new ($T09())(expected)));
  };

  function ConstraintExpression_Property (name) {
    return $S01().CallVirtual("Append", null, this, new ($T26())(name));
  };

  function ConstraintExpression_SameAs (expected) {
    return $T27().$Cast($S00().CallVirtual("Append", null, this, new ($T27())(expected)));
  };

  function ConstraintExpression_SamePath (expected) {
    return $T28().$Cast($S00().CallVirtual("Append", null, this, new ($T28())(expected)));
  };

  function ConstraintExpression_SamePathOrUnder (expected) {
    return $T29().$Cast($S00().CallVirtual("Append", null, this, new ($T29())(expected)));
  };

  function ConstraintExpression_StartsWith (expected) {
    return $T2A().$Cast($S00().CallVirtual("Append", null, this, new ($T2A())(expected)));
  };

  function ConstraintExpression_StringContaining (expected) {
    return $T0C().$Cast($S00().CallVirtual("Append", null, this, new ($T0C())(expected)));
  };

  function ConstraintExpression_StringEnding (expected) {
    return $T0D().$Cast($S00().CallVirtual("Append", null, this, new ($T0D())(expected)));
  };

  function ConstraintExpression_StringMatching (pattern) {
    return $T25().$Cast($S00().CallVirtual("Append", null, this, new ($T25())(pattern)));
  };

  function ConstraintExpression_StringStarting (expected) {
    return $T2A().$Cast($S00().CallVirtual("Append", null, this, new ($T2A())(expected)));
  };

  function ConstraintExpression_SubPath (expected) {
    return $T2B().$Cast($S00().CallVirtual("Append", null, this, new ($T2B())(expected)));
  };

  function ConstraintExpression_SubsetOf (expected) {
    return $T2C().$Cast($S00().CallVirtual("Append", null, this, new ($T2C())(expected)));
  };

  function ConstraintExpression_TypeOf (expectedType) {
    return $T2D().$Cast($S00().CallVirtual("Append", null, this, new ($T2D())(expectedType)));
  };

  function ConstraintExpression_TypeOf$b1 (T) {
    return $T2D().$Cast($S00().CallVirtual("Append", null, this, new ($T2D())(T)));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpressionBase"), 
      Name: "NUnit.Framework.Constraints.ConstraintExpression", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConstraintExpression__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")), 
      ConstraintExpression__ctor$01
    );

    $.Method({Static:false, Public:true }, "AssignableFrom", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableFromConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintExpression_AssignableFrom
    );

    $.Method({Static:false, Public:true }, "AssignableFrom", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableFromConstraint"), null, ["T"]), 
      ConstraintExpression_AssignableFrom$b1
    );

    $.Method({Static:false, Public:true }, "AssignableTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableToConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintExpression_AssignableTo
    );

    $.Method({Static:false, Public:true }, "AssignableTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.AssignableToConstraint"), null, ["T"]), 
      ConstraintExpression_AssignableTo$b1
    );

    $.Method({Static:false, Public:true }, "AtLeast", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanOrEqualConstraint"), [$.Object]), 
      ConstraintExpression_AtLeast
    );

    $.Method({Static:false, Public:true }, "AtMost", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanOrEqualConstraint"), [$.Object]), 
      ConstraintExpression_AtMost
    );

    $.Method({Static:false, Public:true }, "Attribute", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintExpression_Attribute
    );

    $.Method({Static:false, Public:true }, "Attribute", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), null, ["T"]), 
      ConstraintExpression_Attribute$b1
    );

    $.Method({Static:false, Public:true }, "Contains", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionContainsConstraint"), [$.Object]), 
      ConstraintExpression_Contains$02
    );

    $.Method({Static:false, Public:true }, "Contains", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ContainsConstraint"), [$.String]), 
      ConstraintExpression_Contains$03
    );

    $.Method({Static:false, Public:true }, "ContainsSubstring", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      ConstraintExpression_ContainsSubstring
    );

    $.Method({Static:false, Public:true }, "EndsWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      ConstraintExpression_EndsWith
    );

    $.Method({Static:false, Public:true }, "EqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualConstraint"), [$.Object]), 
      ConstraintExpression_EqualTo
    );

    $.Method({Static:false, Public:true }, "EquivalentTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionEquivalentConstraint"), [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      ConstraintExpression_EquivalentTo
    );

    $.Method({Static:false, Public:true }, "Exactly", 
      new JSIL.MethodSignature($.Type, [$.Int32]), 
      ConstraintExpression_Exactly
    );

    $.Method({Static:false, Public:true }, "get_All", 
      JSIL.MethodSignature.Return($.Type), 
      ConstraintExpression_get_All
    );

    $.Method({Static:false, Public:true }, "get_BinarySerializable", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.BinarySerializableConstraint")), 
      ConstraintExpression_get_BinarySerializable
    );

    $.Method({Static:false, Public:true }, "get_Count", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintExpression_get_Count
    );

    $.Method({Static:false, Public:true }, "get_Empty", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.EmptyConstraint")), 
      ConstraintExpression_get_Empty
    );

    $.Method({Static:false, Public:true }, "get_False", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.FalseConstraint")), 
      ConstraintExpression_get_False
    );

    $.Method({Static:false, Public:true }, "get_InnerException", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintExpression_get_InnerException
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintExpression_get_Length
    );

    $.Method({Static:false, Public:true }, "get_Message", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression")), 
      ConstraintExpression_get_Message
    );

    $.Method({Static:false, Public:true }, "get_NaN", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.NaNConstraint")), 
      ConstraintExpression_get_NaN
    );

    $.Method({Static:false, Public:true }, "get_Negative", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint")), 
      ConstraintExpression_get_Negative
    );

    $.Method({Static:false, Public:true }, "get_No", 
      JSIL.MethodSignature.Return($.Type), 
      ConstraintExpression_get_No
    );

    $.Method({Static:false, Public:true }, "get_None", 
      JSIL.MethodSignature.Return($.Type), 
      ConstraintExpression_get_None
    );

    $.Method({Static:false, Public:true }, "get_Not", 
      JSIL.MethodSignature.Return($.Type), 
      ConstraintExpression_get_Not
    );

    $.Method({Static:false, Public:true }, "get_Null", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.NullConstraint")), 
      ConstraintExpression_get_Null
    );

    $.Method({Static:false, Public:true }, "get_Ordered", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOrderedConstraint")), 
      ConstraintExpression_get_Ordered
    );

    $.Method({Static:false, Public:true }, "get_Positive", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint")), 
      ConstraintExpression_get_Positive
    );

    $.Method({Static:false, Public:true }, "get_Some", 
      JSIL.MethodSignature.Return($.Type), 
      ConstraintExpression_get_Some
    );

    $.Method({Static:false, Public:true }, "get_True", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.TrueConstraint")), 
      ConstraintExpression_get_True
    );

    $.Method({Static:false, Public:true }, "get_Unique", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.UniqueItemsConstraint")), 
      ConstraintExpression_get_Unique
    );

    $.Method({Static:false, Public:true }, "get_With", 
      JSIL.MethodSignature.Return($.Type), 
      ConstraintExpression_get_With
    );

    $.Method({Static:false, Public:true }, "get_XmlSerializable", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.XmlSerializableConstraint")), 
      ConstraintExpression_get_XmlSerializable
    );

    $.Method({Static:false, Public:true }, "GreaterThan", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint"), [$.Object]), 
      ConstraintExpression_GreaterThan
    );

    $.Method({Static:false, Public:true }, "GreaterThanOrEqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanOrEqualConstraint"), [$.Object]), 
      ConstraintExpression_GreaterThanOrEqualTo
    );

    $.Method({Static:false, Public:true }, "InRange", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RangeConstraint`1", ["!!0"]), ["!!0", "!!0"], ["T"]), 
      ConstraintExpression_InRange$b1
    );

    $.Method({Static:false, Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintExpression_InstanceOf
    );

    $.Method({Static:false, Public:true }, "InstanceOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), null, ["T"]), 
      ConstraintExpression_InstanceOf$b1
    );

    $.Method({Static:false, Public:true }, "InstanceOfType", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintExpression_InstanceOfType
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use InstanceOf(expectedType)"]; });

    $.Method({Static:false, Public:true }, "InstanceOfType", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.InstanceOfTypeConstraint"), null, ["T"]), 
      ConstraintExpression_InstanceOfType$b1
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Use InstanceOf<T>()"]; });

    $.Method({Static:false, Public:true }, "LessThan", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint"), [$.Object]), 
      ConstraintExpression_LessThan
    );

    $.Method({Static:false, Public:true }, "LessThanOrEqualTo", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.LessThanOrEqualConstraint"), [$.Object]), 
      ConstraintExpression_LessThanOrEqualTo
    );

    $.Method({Static:false, Public:true }, "Matches", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      ConstraintExpression_Matches$04
    );

    $.Method({Static:false, Public:true }, "Matches", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0A.TypeRef("System.Predicate`1", ["!!0"])], ["T"]), 
      ConstraintExpression_Matches$b1
    );

    $.Method({Static:false, Public:true }, "Matches", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      ConstraintExpression_Matches$05
    );

    $.Method({Static:false, Public:true }, "Member", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionContainsConstraint"), [$.Object]), 
      ConstraintExpression_Member
    );

    $.Method({Static:false, Public:true }, "Property", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"), [$.String]), 
      ConstraintExpression_Property
    );

    $.Method({Static:false, Public:true }, "SameAs", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SameAsConstraint"), [$.Object]), 
      ConstraintExpression_SameAs
    );

    $.Method({Static:false, Public:true }, "SamePath", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SamePathConstraint"), [$.String]), 
      ConstraintExpression_SamePath
    );

    $.Method({Static:false, Public:true }, "SamePathOrUnder", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SamePathOrUnderConstraint"), [$.String]), 
      ConstraintExpression_SamePathOrUnder
    );

    $.Method({Static:false, Public:true }, "StartsWith", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      ConstraintExpression_StartsWith
    );

    $.Method({Static:false, Public:true }, "StringContaining", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubstringConstraint"), [$.String]), 
      ConstraintExpression_StringContaining
    );

    $.Method({Static:false, Public:true }, "StringEnding", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EndsWithConstraint"), [$.String]), 
      ConstraintExpression_StringEnding
    );

    $.Method({Static:false, Public:true }, "StringMatching", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.RegexConstraint"), [$.String]), 
      ConstraintExpression_StringMatching
    );

    $.Method({Static:false, Public:true }, "StringStarting", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.StartsWithConstraint"), [$.String]), 
      ConstraintExpression_StringStarting
    );

    $.Method({Static:false, Public:true }, "SubPath", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.SubPathConstraint"), [$.String]), 
      ConstraintExpression_SubPath
    );

    $.Method({Static:false, Public:true }, "SubsetOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionSubsetConstraint"), [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      ConstraintExpression_SubsetOf
    );

    $.Method({Static:false, Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), [$asm0A.TypeRef("System.Type")]), 
      ConstraintExpression_TypeOf
    );

    $.Method({Static:false, Public:true }, "TypeOf", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), null, ["T"]), 
      ConstraintExpression_TypeOf$b1
    );

    $.Property({Static:false, Public:true }, "Not", $.Type);

    $.Property({Static:false, Public:true }, "No", $.Type);

    $.Property({Static:false, Public:true }, "All", $.Type);

    $.Property({Static:false, Public:true }, "Some", $.Type);

    $.Property({Static:false, Public:true }, "None", $.Type);

    $.Property({Static:false, Public:true }, "Length", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "Count", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "Message", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "InnerException", $asm0B.TypeRef("NUnit.Framework.Constraints.ResolvableConstraintExpression"));

    $.Property({Static:false, Public:true }, "With", $.Type);

    $.Property({Static:false, Public:true }, "Null", $asm0B.TypeRef("NUnit.Framework.Constraints.NullConstraint"));

    $.Property({Static:false, Public:true }, "True", $asm0B.TypeRef("NUnit.Framework.Constraints.TrueConstraint"));

    $.Property({Static:false, Public:true }, "False", $asm0B.TypeRef("NUnit.Framework.Constraints.FalseConstraint"));

    $.Property({Static:false, Public:true }, "Positive", $asm0B.TypeRef("NUnit.Framework.Constraints.GreaterThanConstraint"));

    $.Property({Static:false, Public:true }, "Negative", $asm0B.TypeRef("NUnit.Framework.Constraints.LessThanConstraint"));

    $.Property({Static:false, Public:true }, "NaN", $asm0B.TypeRef("NUnit.Framework.Constraints.NaNConstraint"));

    $.Property({Static:false, Public:true }, "Empty", $asm0B.TypeRef("NUnit.Framework.Constraints.EmptyConstraint"));

    $.Property({Static:false, Public:true }, "Unique", $asm0B.TypeRef("NUnit.Framework.Constraints.UniqueItemsConstraint"));

    $.Property({Static:false, Public:true }, "BinarySerializable", $asm0B.TypeRef("NUnit.Framework.Constraints.BinarySerializableConstraint"));

    $.Property({Static:false, Public:true }, "XmlSerializable", $asm0B.TypeRef("NUnit.Framework.Constraints.XmlSerializableConstraint"));

    $.Property({Static:false, Public:true }, "Ordered", $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOrderedConstraint"));

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ContainsConstraint */ 

(function ContainsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.Generic.List$b1.Of($asm0B.NUnit.Framework.Constraints.EqualityAdapter))) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StringConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SubstringConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionItemsEqualConstraint)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionContainsConstraint)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.Collections.IEqualityComparer)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.Generic.List`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")]), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.CollectionItemsEqualConstraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.IComparer")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.IEqualityComparer")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", ["!!0"])], ["T"]))) ();
  };

  function ContainsConstraint__ctor (expected) {
    this.equalityAdapters = $S00().Construct();
    $T02().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function ContainsConstraint_AddAdapter (adapter) {
    (this.equalityAdapters).Add(adapter);
    return this;
  };

  function ContainsConstraint_get_IgnoreCase () {
    this.ignoreCase = true;
    return this;
  };

  function ContainsConstraint_get_RealConstraint () {
    var $temp00;
    if (this.realConstraint === null) {
      if ($T04().$Is(this.actual)) {
        var stringConstraint = new ($T06())($T04().$Cast(this.expected));
        if (this.ignoreCase) {
          stringConstraint = stringConstraint.get_IgnoreCase();
        }
        this.realConstraint = stringConstraint;
      } else {
        var collectionItemsEqualConstraint = new ($T08())(this.expected);

        for (var a$0 = this.equalityAdapters._items, i$0 = 0, l$0 = (this.equalityAdapters._size | 0); i$0 < l$0; ($temp00 = i$0, 
            i$0 = ((i$0 + 1) | 0), 
            $temp00)) {
          var current = a$0[i$0];
          collectionItemsEqualConstraint = $S01().CallVirtual("Using", null, collectionItemsEqualConstraint, current);
        }
        this.realConstraint = collectionItemsEqualConstraint;
      }
    }
    return this.realConstraint;
  };

  function ContainsConstraint_Matches (actual) {
    this.actual = actual;
    return $S02().CallVirtual("Matches", null, this.get_RealConstraint(), actual);
  };

  function ContainsConstraint_set_RealConstraint (value) {
    this.realConstraint = value;
  };

  function ContainsConstraint_Using$00 (comparer) {
    return this.AddAdapter($S03().CallStatic($T03(), "For", null, comparer));
  };

  function ContainsConstraint_Using$b1$01 (T, comparer) {
    return this.AddAdapter($S04().CallStatic($T03(), "For$b1", [T], comparer));
  };

  function ContainsConstraint_Using$b1$02 (T, comparer) {
    return this.AddAdapter($S05().CallStatic($T03(), "For$b1", [T], comparer));
  };

  function ContainsConstraint_Using$03 (comparer) {
    return this.AddAdapter($S06().CallStatic($T03(), "For", null, comparer));
  };

  function ContainsConstraint_Using$b1$04 (T, comparer) {
    return this.AddAdapter($S07().CallStatic($T03(), "For$b1", [T], comparer));
  };

  function ContainsConstraint_WriteDescriptionTo (writer) {
    (this.get_RealConstraint()).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.ContainsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      ContainsConstraint__ctor
    );

    $.Method({Static:false, Public:false}, "AddAdapter", 
      new JSIL.MethodSignature($.Type, [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")]), 
      ContainsConstraint_AddAdapter
    );

    $.Method({Static:false, Public:true }, "get_IgnoreCase", 
      JSIL.MethodSignature.Return($.Type), 
      ContainsConstraint_get_IgnoreCase
    );

    $.Method({Static:false, Public:false}, "get_RealConstraint", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ContainsConstraint_get_RealConstraint
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      ContainsConstraint_Matches
    );

    $.Method({Static:false, Public:false}, "set_RealConstraint", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ContainsConstraint_set_RealConstraint
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      ContainsConstraint_Using$00
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]), 
      ContainsConstraint_Using$b1$01
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]), 
      ContainsConstraint_Using$b1$02
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IEqualityComparer")]), 
      ContainsConstraint_Using$03
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", ["!!0"])], ["T"]), 
      ContainsConstraint_Using$b1$04
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ContainsConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expected", $.Object); 
    $.Field({Static:false, Public:false}, "realConstraint", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")); 
    $.Field({Static:false, Public:false}, "ignoreCase", $.Boolean); 
    $.Field({Static:false, Public:false}, "equalityAdapters", $asm0A.TypeRef("System.Collections.Generic.List`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")])); 
    $.Property({Static:false, Public:false}, "RealConstraint", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"));

    $.Property({Static:false, Public:true }, "IgnoreCase", $.Type);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.DelayedConstraint */ 

(function DelayedConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Threading.Thread)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.AsyncInvocationRegion"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.Int32")))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function DelayedConstraint__ctor$00 (baseConstraint, delayInMilliseconds) {
    $thisType.prototype._ctor.call(this, baseConstraint, delayInMilliseconds, 0);
  };

  function DelayedConstraint__ctor$01 (baseConstraint, delayInMilliseconds, pollingInterval) {
    $T02().prototype._ctor.call(this, baseConstraint);
    if ((delayInMilliseconds | 0) < 0) {
      throw $S00().Construct("Cannot check a condition in the past", "delayInMilliseconds");
    }
    this.delayInMilliseconds = (delayInMilliseconds | 0);
    this.pollingInterval = (pollingInterval | 0);
  };

  function DelayedConstraint_GetStringRepresentation () {
    return $T04().Format("<after {0} {1}>", this.delayInMilliseconds, this.baseConstraint);
  };

  function DelayedConstraint_InvokeDelegate$b1 (T, del) {
    if ($S01().CallStatic($T06(), "IsAsyncOperation", null, del)) {
      var asyncInvocationRegion = $S02().CallStatic($T06(), "Create", null, del);
      try {
        var result = asyncInvocationRegion.WaitForPendingOperationsToComplete(JSIL.CloneParameter(T, del()));
        return result;
      } finally {
        if (asyncInvocationRegion !== null) {
          $IM00().Call(asyncInvocationRegion, null);
        }
      }
    }
    result = JSIL.CloneParameter(T, del());
    return result;
  };

  function DelayedConstraint_Matches (actual) {

    for (var num = (this.delayInMilliseconds | 0); ((this.pollingInterval | 0) > 0) && ((this.pollingInterval | 0) < num); ) {
      num = ((num - (this.pollingInterval | 0)) | 0);
      $S03().CallStatic($T09(), "Sleep", null, this.pollingInterval);
      this.actual = actual;
      if ($S04().CallVirtual("Matches", null, this.baseConstraint, actual)) {
        var result = true;
        return result;
      }
    }
    if (num > 0) {
      $S03().CallStatic($T09(), "Sleep", null, num);
    }
    this.actual = actual;
    result = $S04().CallVirtual("Matches", null, this.baseConstraint, actual);
    return result;
  };

  function DelayedConstraint_Matches$b1$02 (T, del, $exception) {

    for (var num = (this.delayInMilliseconds | 0); ((this.pollingInterval | 0) > 0) && ((this.pollingInterval | 0) < num); ) {
      num = ((num - (this.pollingInterval | 0)) | 0);
      $S03().CallStatic($T09(), "Sleep", null, this.pollingInterval);
      this.actual = $thisType.InvokeDelegate$b1(T)(del);
      try {
        if ($S04().CallVirtual("Matches", null, this.baseConstraint, this.actual)) {
          var result = true;
          return result;
        }
      } catch ($exception) {
      }
    }
    if (num > 0) {
      $S03().CallStatic($T09(), "Sleep", null, num);
    }
    this.actual = $thisType.InvokeDelegate$b1(T)(del);
    result = $S04().CallVirtual("Matches", null, this.baseConstraint, this.actual);
    return result;
  };

  function DelayedConstraint_Matches$b1$03 (T, /* ref */ actual, $exception) {

    for (var num = (this.delayInMilliseconds | 0); ((this.pollingInterval | 0) > 0) && ((this.pollingInterval | 0) < num); ) {
      num = ((num - (this.pollingInterval | 0)) | 0);
      $S03().CallStatic($T09(), "Sleep", null, this.pollingInterval);
      this.actual = JSIL.CloneParameter(T, actual.get());
      try {
        if ($S04().CallVirtual("Matches", null, this.baseConstraint, JSIL.CloneParameter(T, actual.get()))) {
          var result = true;
          return result;
        }
      } catch ($exception) {
      }
    }
    if (num > 0) {
      $S03().CallStatic($T09(), "Sleep", null, num);
    }
    this.actual = JSIL.CloneParameter(T, actual.get());
    result = $S04().CallVirtual("Matches", null, this.baseConstraint, JSIL.CloneParameter(T, actual.get()));
    return result;
  };

  function DelayedConstraint_WriteActualValueTo (writer) {
    (this.baseConstraint).WriteActualValueTo(writer);
  };

  function DelayedConstraint_WriteDescriptionTo (writer) {
    (this.baseConstraint).WriteDescriptionTo(writer);
    $S05().CallVirtual("Write", null, writer, $T04().Format(" after {0} millisecond delay", this.delayInMilliseconds));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.DelayedConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $.Int32]), 
      DelayedConstraint__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $.Int32, 
          $.Int32
        ]), 
      DelayedConstraint__ctor$01
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      DelayedConstraint_GetStringRepresentation
    );

    $.Method({Static:true , Public:false}, "InvokeDelegate", 
      new JSIL.MethodSignature($.Object, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"])], ["T"]), 
      DelayedConstraint_InvokeDelegate$b1
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      DelayedConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"])], ["T"]), 
      DelayedConstraint_Matches$b1$02
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", ["!!0"])], ["T"]), 
      DelayedConstraint_Matches$b1$03
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      DelayedConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      DelayedConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "delayInMilliseconds", $.Int32); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "pollingInterval", $.Int32); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EmptyCollectionConstraint */ 

(function EmptyCollectionConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionConstraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function EmptyCollectionConstraint__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function EmptyCollectionConstraint_doMatch (collection) {
    return $T00().IsEmpty(collection);
  };

  function EmptyCollectionConstraint_WriteDescriptionTo (writer) {
    $S00().CallVirtual("Write", null, writer, "<empty>");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionConstraint"), 
      Name: "NUnit.Framework.Constraints.EmptyCollectionConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EmptyCollectionConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "doMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      EmptyCollectionConstraint_doMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EmptyCollectionConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EmptyConstraint */ 

(function EmptyConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyStringConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.IO.DirectoryInfo)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyDirectoryConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EmptyCollectionConstraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };

  function EmptyConstraint__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function EmptyConstraint_get_RealConstraint () {
    if ($T01().$Is(this.actual)) {
      var result = new ($T02())();
    } else if ($T03().$Is(this.actual)) {
      result = new ($T04())();
    } else {
      result = new ($T05())();
    }
    return result;
  };

  function EmptyConstraint_Matches (actual) {
    this.actual = actual;
    if (actual === null) {
      throw $S00().Construct("The actual value must be a non-null string, IEnumerable or DirectoryInfo", "actual");
    }
    return $S01().CallVirtual("Matches", null, this.get_RealConstraint(), actual);
  };

  function EmptyConstraint_WriteDescriptionTo (writer) {
    (this.get_RealConstraint()).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.EmptyConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EmptyConstraint__ctor
    );

    $.Method({Static:false, Public:false}, "get_RealConstraint", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      EmptyConstraint_get_RealConstraint
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      EmptyConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EmptyConstraint_WriteDescriptionTo
    );

    $.Property({Static:false, Public:false}, "RealConstraint", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"));

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EmptyDirectoryConstraint */ 

(function EmptyDirectoryConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.IO.DirectoryInfo)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize(System.Array.Of($asm0A.System.IO.FileInfo))) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize(System.Array.Of($asm0A.System.IO.DirectoryInfo))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object"), 
        $asm0A.TypeRef("System.Object")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function EmptyDirectoryConstraint__ctor () {
    this.files = 0;
    this.subdirs = 0;
    $T00().prototype._ctor.call(this);
  };

  function EmptyDirectoryConstraint_Matches (actual) {
    this.actual = actual;
    var directoryInfo = $T02().$As(actual);
    if (directoryInfo === null) {
      throw $S00().Construct("The actual value must be a DirectoryInfo", "actual");
    }
    this.files = (directoryInfo.GetFiles().length | 0);
    this.subdirs = (directoryInfo.GetDirectories().length | 0);
    return (((this.files | 0) === 0) && ((this.subdirs | 0) === 0));
  };

  function EmptyDirectoryConstraint_WriteActualValueTo (writer) {
    var directoryInfo = $T02().$As(this.actual);
    if (directoryInfo === null) {
      $T00().prototype.WriteActualValueTo.call(this, writer);
    } else {
      writer.WriteActualValue(directoryInfo);
      $S01().CallVirtual("Write", null, writer, " with {0} files and {1} directories", this.files, this.subdirs);
    }
  };

  function EmptyDirectoryConstraint_WriteDescriptionTo (writer) {
    $S02().CallVirtual("Write", null, writer, "An empty directory");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.EmptyDirectoryConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EmptyDirectoryConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      EmptyDirectoryConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EmptyDirectoryConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EmptyDirectoryConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "files", $.Int32); 
    $.Field({Static:false, Public:false}, "subdirs", $.Int32); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EmptyStringConstraint */ 

(function EmptyStringConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function EmptyStringConstraint__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function EmptyStringConstraint_Matches (actual) {
    this.actual = actual;
    return $T02().$As(actual) == $T02().Empty;
  };

  function EmptyStringConstraint_WriteDescriptionTo (writer) {
    $S00().CallVirtual("Write", null, writer, "<empty>");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.EmptyStringConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EmptyStringConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      EmptyStringConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EmptyStringConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.StringConstraint */ 

(function StringConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function StringConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function StringConstraint_get_IgnoreCase () {
    this.caseInsensitive = true;
    return this;
  };

  function StringConstraint_Matches$00 (actual) {
    this.actual = actual;
    var text = $T00().$As(actual);
    return ((text !== null) && $S00().CallVirtual("Matches", null, this, text));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.StringConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      StringConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "get_IgnoreCase", 
      JSIL.MethodSignature.Return($.Type), 
      StringConstraint_get_IgnoreCase
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      StringConstraint_Matches$00
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expected", $.String); 
    $.Field({Static:false, Public:false}, "caseInsensitive", $.Boolean); 
    $.Property({Static:false, Public:true }, "IgnoreCase", $.Type);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EndsWithConstraint */ 

(function EndsWithConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StringConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function EndsWithConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
  };

  function EndsWithConstraint_Matches$00 (actual) {
    if (this.caseInsensitive) {
      var result = (System.String.EndsWith(actual.toLowerCase(), this.expected.toLowerCase()));
    } else {
      result = (System.String.EndsWith(actual, this.expected));
    }
    return result;
  };

  function EndsWithConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("String ending with");
    writer.WriteExpectedValue(this.expected);
    if (this.caseInsensitive) {
      writer.WriteModifier("ignoring case");
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.StringConstraint"), 
      Name: "NUnit.Framework.Constraints.EndsWithConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      EndsWithConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      EndsWithConstraint_Matches$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EndsWithConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualConstraint */ 

(function EqualConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Tolerance)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NUnitEqualityComparer)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Collections.Generic.ICollection$b1.Of($asm0B.NUnit.Framework.Constraints.FailurePoint))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FailurePoint)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Collections.Generic.IList$b1.Of($asm0B.NUnit.Framework.Constraints.FailurePoint))) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.IO.Stream)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.System.Array)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize(System.Array.Of($asm0A.System.Int32))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MsgUtils)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0A.System.Collections.IList)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0A.System.Collections.Generic.ICollection$b1.Of($asm0B.NUnit.Framework.Constraints.EqualityAdapter))) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter)) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0A.System.Collections.IEqualityComparer)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ToleranceMode)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualConstraint"), [$asm0A.TypeRef("System.Collections.IComparer")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.IComparer")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.IEqualityComparer")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", ["!!0"])], ["T"]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.InvalidOperationException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.Generic.ICollection$b1.Of($asm0B.NUnit.Framework.Constraints.FailurePoint).get_Count)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.Generic.IList$b1.Of($asm0B.NUnit.Framework.Constraints.FailurePoint).get_Item)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.ICollection.get_Count)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.Collections.IList.get_Item)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM07 = function () {
    return ($IM07 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };
  var $IM08 = function () {
    return ($IM08 = JSIL.Memoize($asm0A.System.Collections.Generic.ICollection$b1.Of($asm0B.NUnit.Framework.Constraints.EqualityAdapter).Add)) ();
  };

  function EqualConstraint__ctor (expected) {
    this.tolerance = $T01().get_Empty();
    this.clipStrings = true;
    this.comparer = new ($T02())();
    $T03().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function EqualConstraint_Comparer (comparer) {
    return $S00().CallVirtual("Using", null, this, comparer);
  };

  function EqualConstraint_DisplayCollectionDifferences (writer, expected, actual, depth) {
    this.DisplayTypesAndSizes(writer, expected, actual, depth);
    if (($IM00().Call((this.comparer).get_FailurePoints(), null) | 0) > (depth | 0)) {
      var failurePoint = $IM01().Call((this.comparer).get_FailurePoints(), null, depth);
      this.DisplayFailurePoint(
        writer, 
        expected, 
        actual, 
        failurePoint, 
        depth
      );
      if (!(!failurePoint.ExpectedHasData || !failurePoint.ActualHasData)) {
        this.DisplayDifferences(writer, failurePoint.ExpectedValue, failurePoint.ActualValue, depth = (((depth | 0) + 1) | 0));
      } else if (failurePoint.ActualHasData) {
        $S01().CallVirtual("Write", null, writer, "  Extra:    ");
        writer.WriteCollectionElements(actual, failurePoint.Position, 3);
      } else {
        $S01().CallVirtual("Write", null, writer, "  Missing:  ");
        writer.WriteCollectionElements(expected, failurePoint.Position, 3);
      }
    }
  };

  function EqualConstraint_DisplayDifferences (writer, expected, actual, depth) {
    if (!(($T0C().$As(expected) === null) || !$T0C().$Is(actual))) {
      this.DisplayStringDifferences(writer, $T0C().$Cast(expected), $T0C().$Cast(actual));
    } else if (!(($T06().$As(expected) === null) || !$T06().$Is(actual))) {
      this.DisplayCollectionDifferences(writer, $T06().$Cast(expected), $T06().$Cast(actual), depth);
    } else if (!(($T0D().$As(expected) === null) || !$T0D().$Is(actual))) {
      this.DisplayEnumerableDifferences(writer, $T0D().$Cast(expected), $T0D().$Cast(actual), depth);
    } else if (!(($T0E().$As(expected) === null) || !$T0E().$Is(actual))) {
      this.DisplayStreamDifferences(writer, $T0E().$Cast(expected), $T0E().$Cast(actual), depth);
    } else if (this.tolerance !== null) {
      writer.DisplayDifferences(expected, actual, this.tolerance);
    } else {
      writer.DisplayDifferences(expected, actual);
    }
  };

  function EqualConstraint_DisplayEnumerableDifferences (writer, expected, actual, depth) {
    this.DisplayTypesAndSizes(writer, expected, actual, depth);
    if (($IM00().Call((this.comparer).get_FailurePoints(), null) | 0) > (depth | 0)) {
      var failurePoint = $IM01().Call((this.comparer).get_FailurePoints(), null, depth);
      this.DisplayFailurePoint(
        writer, 
        expected, 
        actual, 
        failurePoint, 
        depth
      );
      if (!(!failurePoint.ExpectedHasData || !failurePoint.ActualHasData)) {
        this.DisplayDifferences(writer, failurePoint.ExpectedValue, failurePoint.ActualValue, depth = (((depth | 0) + 1) | 0));
      }
    }
  };

  function EqualConstraint_DisplayFailurePoint (writer, expected, actual, failurePoint, indent) {
    var array = $T0F().$As(expected);
    var array2 = $T0F().$As(actual);
    var num = ((
      (array !== null)
         ? array.get_Rank()
         : 1)
     | 0);
    var num2 = ((
      (array2 !== null)
         ? array2.get_Rank()
         : 1)
     | 0);
    var flag = num === num2;
    if (!((array === null) || (array2 === null))) {

      for (var num3 = 1; (num3 < num) && flag; num3 = ((num3 + 1) | 0)) {
        if ((array.GetLength(num3) | 0) !== (array2.GetLength(num3) | 0)) {
          flag = false;
        }
      }
    }
    var arrayIndicesFromCollectionIndex = $T12().GetArrayIndicesFromCollectionIndex(expected, failurePoint.Position);
    if (flag) {
      writer.WriteMessageLine(indent, $thisType.ValuesDiffer_1, JSIL.Array.New($T00(), [$T12().GetArrayIndicesAsString(arrayIndicesFromCollectionIndex)]));
    } else {
      var arrayIndicesFromCollectionIndex2 = $T12().GetArrayIndicesFromCollectionIndex(actual, failurePoint.Position);
      writer.WriteMessageLine(indent, $thisType.ValuesDiffer_2, JSIL.Array.New($T00(), [$T12().GetArrayIndicesAsString(arrayIndicesFromCollectionIndex), $T12().GetArrayIndicesAsString(arrayIndicesFromCollectionIndex2)]));
    }
  };

  function EqualConstraint_DisplayStreamDifferences (writer, expected, actual, depth) {
    if (!$T13().op_Inequality(
        expected.get_Length(), 
        actual.get_Length()
      )) {
      var failurePoint = $IM01().Call((this.comparer).get_FailurePoints(), null, depth);
      var num = $T13().FromNumber(failurePoint.Position);
      writer.WriteMessageLine($thisType.StreamsDiffer_1, JSIL.Array.New($T00(), [expected.get_Length(), num]));
    } else {
      writer.WriteMessageLine($thisType.StreamsDiffer_2, JSIL.Array.New($T00(), [expected.get_Length(), actual.get_Length()]));
    }
  };

  function EqualConstraint_DisplayStringDifferences (writer, expected, actual) {
    var num = ($T12().FindMismatchPosition(expected, actual, 0, (this.comparer).get_IgnoreCase()) | 0);
    if ((expected.length | 0) === (actual.length | 0)) {
      writer.WriteMessageLine($thisType.StringsDiffer_1, JSIL.Array.New($T00(), [expected.length, num]));
    } else {
      writer.WriteMessageLine($thisType.StringsDiffer_2, JSIL.Array.New($T00(), [expected.length, actual.length, num]));
    }
    writer.DisplayStringDifferences(
      expected, 
      actual, 
      num, 
      (this.comparer).get_IgnoreCase(), 
      this.clipStrings
    );
  };

  function EqualConstraint_DisplayTypesAndSizes (writer, expected, actual, indent) {
    var text = $T12().GetTypeRepresentation(expected);
    if (!(($T06().$As(expected) === null) || $T0F().$Is(expected))) {
      text = (JSIL.ConcatString(text, $T0C().Format(" with {0} elements", $IM02().Call($T06().$Cast(expected), null))));
    }
    var text2 = $T12().GetTypeRepresentation(actual);
    if (!(($T06().$As(actual) === null) || $T0F().$Is(actual))) {
      text2 = (JSIL.ConcatString(text2, $T0C().Format(" with {0} elements", $IM02().Call($T06().$Cast(actual), null))));
    }
    if (text == text2) {
      writer.WriteMessageLine(indent, $thisType.CollectionType_1, JSIL.Array.New($T00(), [text]));
    } else {
      writer.WriteMessageLine(indent, $thisType.CollectionType_2, JSIL.Array.New($T00(), [text, text2]));
    }
  };

  function EqualConstraint_get_AsCollection () {
    (this.comparer).set_CompareAsCollection(true);
    return this;
  };

  function EqualConstraint_get_Days () {
    this.tolerance = (this.tolerance).get_Days();
    return this;
  };

  function EqualConstraint_get_Hours () {
    this.tolerance = (this.tolerance).get_Hours();
    return this;
  };

  function EqualConstraint_get_IgnoreCase () {
    (this.comparer).set_IgnoreCase(true);
    return this;
  };

  function EqualConstraint_get_Milliseconds () {
    this.tolerance = (this.tolerance).get_Milliseconds();
    return this;
  };

  function EqualConstraint_get_Minutes () {
    this.tolerance = (this.tolerance).get_Minutes();
    return this;
  };

  function EqualConstraint_get_NoClip () {
    this.clipStrings = false;
    return this;
  };

  function EqualConstraint_get_Percent () {
    this.tolerance = (this.tolerance).get_Percent();
    return this;
  };

  function EqualConstraint_get_Seconds () {
    this.tolerance = (this.tolerance).get_Seconds();
    return this;
  };

  function EqualConstraint_get_Ticks () {
    this.tolerance = (this.tolerance).get_Ticks();
    return this;
  };

  function EqualConstraint_get_Ulps () {
    this.tolerance = (this.tolerance).get_Ulps();
    return this;
  };

  function EqualConstraint_GetValueFromCollection (collection, index) {
    var array = $T0F().$As(collection);
    if (!((array === null) || ((array.get_Rank() | 0) <= 1))) {
      var result = (array.Get.apply(array, $T12().GetArrayIndicesFromCollectionIndex(array, index)));
    } else if ($T14().$Is(collection)) {
      result = $IM03().Call($T14().$Cast(collection), null, index);
    } else {
      var enumerator = $IM04().Call(collection, null);
      try {

        while ($IM05().Call(enumerator, null)) {
          var current = $IM06().Call(enumerator, null);
          if ((index = (((index | 0) - 1) | 0)) < 0) {
            result = current;
            return result;
          }
        }
      } finally {
        var disposable = $T16().$As(enumerator);
        if (disposable !== null) {
          $IM07().Call(disposable, null);
        }
      }
      result = null;
    }
    return result;
  };

  function EqualConstraint_Matches (actual) {
    this.actual = actual;
    return (this.comparer).AreEqual(this.expected, actual, /* ref */ new JSIL.MemberReference(this, "tolerance"));
  };

  function EqualConstraint_Using$00 (comparer) {
    $IM08().Call((this.comparer).get_ExternalComparers(), null, $S02().CallStatic($T18(), "For", null, comparer));
    return this;
  };

  function EqualConstraint_Using$b1$01 (T, comparer) {
    $IM08().Call((this.comparer).get_ExternalComparers(), null, $S03().CallStatic($T18(), "For$b1", [T], comparer));
    return this;
  };

  function EqualConstraint_Using$b1$02 (T, comparer) {
    $IM08().Call((this.comparer).get_ExternalComparers(), null, $S04().CallStatic($T18(), "For$b1", [T], comparer));
    return this;
  };

  function EqualConstraint_Using$03 (comparer) {
    $IM08().Call((this.comparer).get_ExternalComparers(), null, $S05().CallStatic($T18(), "For", null, comparer));
    return this;
  };

  function EqualConstraint_Using$b1$04 (T, comparer) {
    $IM08().Call((this.comparer).get_ExternalComparers(), null, $S06().CallStatic($T18(), "For$b1", [T], comparer));
    return this;
  };

  function EqualConstraint_Within (amount) {
    if (!(this.tolerance).get_IsEmpty()) {
      throw $S07().Construct("Within modifier may appear only once in a constraint expression");
    }
    this.tolerance = $S08().Construct(amount);
    return this;
  };

  function EqualConstraint_WriteDescriptionTo (writer) {
    writer.WriteExpectedValue(this.expected);
    if (!((this.tolerance === null) || (this.tolerance).get_IsEmpty())) {
      writer.WriteConnector("+/-");
      writer.WriteExpectedValue((this.tolerance).get_Value());
      if ((this.tolerance).get_Mode() !== $T1C().Linear) {
        $S09().CallVirtual("Write", null, writer, " {0}", (this.tolerance).get_Mode());
      }
    }
    if ((this.comparer).get_IgnoreCase()) {
      writer.WriteModifier("ignoring case");
    }
  };

  function EqualConstraint_WriteMessageTo (writer) {
    this.DisplayDifferences(writer, this.expected, this.actual, 0);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.EqualConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      EqualConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "Comparer", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      EqualConstraint_Comparer
    )
      .Attribute($asm0A.TypeRef("System.ObsoleteAttribute"), function () { return ["Replace with 'Using'"]; });

    $.Method({Static:false, Public:false}, "DisplayCollectionDifferences", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), $asm0A.TypeRef("System.Collections.ICollection"), 
          $asm0A.TypeRef("System.Collections.ICollection"), $.Int32
        ]), 
      EqualConstraint_DisplayCollectionDifferences
    );

    $.Method({Static:false, Public:false}, "DisplayDifferences", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), $.Object, 
          $.Object, $.Int32
        ]), 
      EqualConstraint_DisplayDifferences
    );

    $.Method({Static:false, Public:false}, "DisplayEnumerableDifferences", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.Int32
        ]), 
      EqualConstraint_DisplayEnumerableDifferences
    );

    $.Method({Static:false, Public:false}, "DisplayFailurePoint", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0B.TypeRef("NUnit.Framework.Constraints.FailurePoint"), 
          $.Int32
        ]), 
      EqualConstraint_DisplayFailurePoint
    );

    $.Method({Static:false, Public:false}, "DisplayStreamDifferences", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), $asm0A.TypeRef("System.IO.Stream"), 
          $asm0A.TypeRef("System.IO.Stream"), $.Int32
        ]), 
      EqualConstraint_DisplayStreamDifferences
    );

    $.Method({Static:false, Public:false}, "DisplayStringDifferences", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), $.String, 
          $.String
        ]), 
      EqualConstraint_DisplayStringDifferences
    );

    $.Method({Static:false, Public:false}, "DisplayTypesAndSizes", 
      new JSIL.MethodSignature(null, [
          $asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $asm0A.TypeRef("System.Collections.IEnumerable"), $.Int32
        ]), 
      EqualConstraint_DisplayTypesAndSizes
    );

    $.Method({Static:false, Public:true }, "get_AsCollection", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_AsCollection
    );

    $.Method({Static:false, Public:true }, "get_Days", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Days
    );

    $.Method({Static:false, Public:true }, "get_Hours", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Hours
    );

    $.Method({Static:false, Public:true }, "get_IgnoreCase", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_IgnoreCase
    );

    $.Method({Static:false, Public:true }, "get_Milliseconds", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Milliseconds
    );

    $.Method({Static:false, Public:true }, "get_Minutes", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Minutes
    );

    $.Method({Static:false, Public:true }, "get_NoClip", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_NoClip
    );

    $.Method({Static:false, Public:true }, "get_Percent", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Percent
    );

    $.Method({Static:false, Public:true }, "get_Seconds", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Seconds
    );

    $.Method({Static:false, Public:true }, "get_Ticks", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Ticks
    );

    $.Method({Static:false, Public:true }, "get_Ulps", 
      JSIL.MethodSignature.Return($.Type), 
      EqualConstraint_get_Ulps
    );

    $.Method({Static:true , Public:false}, "GetValueFromCollection", 
      new JSIL.MethodSignature($.Object, [$asm0A.TypeRef("System.Collections.ICollection"), $.Int32]), 
      EqualConstraint_GetValueFromCollection
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      EqualConstraint_Matches
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      EqualConstraint_Using$00
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]), 
      EqualConstraint_Using$b1$01
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]), 
      EqualConstraint_Using$b1$02
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IEqualityComparer")]), 
      EqualConstraint_Using$03
    );

    $.Method({Static:false, Public:true }, "Using", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", ["!!0"])], ["T"]), 
      EqualConstraint_Using$b1$04
    );

    $.Method({Static:false, Public:true }, "Within", 
      new JSIL.MethodSignature($.Type, [$.Object]), 
      EqualConstraint_Within
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EqualConstraint_WriteDescriptionTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteMessageTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      EqualConstraint_WriteMessageTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expected", $.Object); 
    $.Field({Static:false, Public:false}, "tolerance", $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")); 
    $.Field({Static:false, Public:false}, "clipStrings", $.Boolean); 
    $.Field({Static:false, Public:false}, "comparer", $asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer")); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "StringsDiffer_1", $.String, "String lengths are both {0}. Strings differ at index {1}."); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "StringsDiffer_2", $.String, "Expected string length {0} but was {1}. Strings differ at index {2}."); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "StreamsDiffer_1", $.String, "Stream lengths are both {0}. Streams differ at offset {1}."); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "StreamsDiffer_2", $.String, "Expected Stream length {0} but was {1}."); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "CollectionType_1", $.String, "Expected and actual are both {0}"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "CollectionType_2", $.String, "Expected is {0}, actual is {1}"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "ValuesDiffer_1", $.String, "Values differ at index {0}"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "ValuesDiffer_2", $.String, "Values differ at expected index {0}, actual index {1}"); 
    function EqualConstraint__cctor () {
      $thisType.StringsDiffer_1 = "String lengths are both {0}. Strings differ at index {1}.";
      $thisType.StringsDiffer_2 = "Expected string length {0} but was {1}. Strings differ at index {2}.";
      $thisType.StreamsDiffer_1 = "Stream lengths are both {0}. Streams differ at offset {1}.";
      $thisType.StreamsDiffer_2 = "Expected Stream length {0} but was {1}.";
      $thisType.CollectionType_1 = "Expected and actual are both {0}";
      $thisType.CollectionType_2 = "Expected is {0}, actual is {1}";
      $thisType.ValuesDiffer_1 = "Values differ at index {0}";
      $thisType.ValuesDiffer_2 = "Values differ at expected index {0}, actual index {1}";
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      EqualConstraint__cctor
    );

    $.Property({Static:false, Public:true }, "IgnoreCase", $.Type);

    $.Property({Static:false, Public:true }, "NoClip", $.Type);

    $.Property({Static:false, Public:true }, "AsCollection", $.Type);

    $.Property({Static:false, Public:true }, "Ulps", $.Type);

    $.Property({Static:false, Public:true }, "Percent", $.Type);

    $.Property({Static:false, Public:true }, "Days", $.Type);

    $.Property({Static:false, Public:true }, "Hours", $.Type);

    $.Property({Static:false, Public:true }, "Minutes", $.Type);

    $.Property({Static:false, Public:true }, "Seconds", $.Type);

    $.Property({Static:false, Public:true }, "Milliseconds", $.Type);

    $.Property({Static:false, Public:true }, "Ticks", $.Type);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapter */ 

(function EqualityAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter_ComparerAdapter)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Collections.IEqualityComparer)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter_EqualityComparerAdapter)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Type)) ();
  };

  function EqualityAdapter__ctor () {
  };

  function EqualityAdapter_CanCompare (x, y) {
    return (!(($T01().$As(x) === null) || 
        !$T01().$Is(y)) || (($T02().$As(x) === null) && 
        !$T02().$Is(y)));
  };

  function EqualityAdapter_For$00 (comparer) {
    return new ($T04())(comparer);
  };

  function EqualityAdapter_For$01 (comparer) {
    return new ($T06())(comparer);
  };

  function EqualityAdapter_For$b1$02 (T, comparer) {
    return new ($asm0B.NUnit.Framework.Constraints.EqualityAdapter_EqualityComparerAdapter$b1.Of(T)) (comparer);
  };

  function EqualityAdapter_For$b1$03 (T, comparer) {
    return new ($asm0B.NUnit.Framework.Constraints.EqualityAdapter_ComparerAdapter$b1.Of(T)) (comparer);
  };

  function EqualityAdapter_For$b1$04 (T, comparer) {
    return new ($asm0B.NUnit.Framework.Constraints.EqualityAdapter_ComparisonAdapter$b1.Of(T)) (comparer);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.EqualityAdapter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      EqualityAdapter__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "CanCompare", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      EqualityAdapter_CanCompare
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IComparer")]), 
      EqualityAdapter_For$00
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.IEqualityComparer")]), 
      EqualityAdapter_For$01
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", ["!!0"])], ["T"]), 
      EqualityAdapter_For$b1$02
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", ["!!0"])], ["T"]), 
      EqualityAdapter_For$b1$03
    );

    $.Method({Static:true , Public:true }, "For", 
      new JSIL.MethodSignature($.Type, [$asm0A.TypeRef("System.Comparison`1", ["!!0"])], ["T"]), 
      EqualityAdapter_For$b1$04
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapter+ComparerAdapter */ 

(function ComparerAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IComparer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IComparer.Compare)) ();
  };

  function ComparerAdapter__ctor (comparer) {
    $T01().prototype._ctor.call(this);
    this.comparer = comparer;
  };

  function ComparerAdapter_AreEqual (x, y) {
    return (($IM00().Call(this.comparer, null, x, y) | 0) === 0);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), 
      Name: "NUnit.Framework.Constraints.EqualityAdapter+ComparerAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IComparer")), 
      ComparerAdapter__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      ComparerAdapter_AreEqual
    );

    $.Field({Static:false, Public:false}, "comparer", $asm0A.TypeRef("System.Collections.IComparer")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapter+EqualityComparerAdapter */ 

(function EqualityComparerAdapter$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.IEqualityComparer)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEqualityComparer.Equals)) ();
  };

  function EqualityComparerAdapter__ctor (comparer) {
    $T01().prototype._ctor.call(this);
    this.comparer = comparer;
  };

  function EqualityComparerAdapter_AreEqual (x, y) {
    return $IM00().Call(this.comparer, null, x, y);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), 
      Name: "NUnit.Framework.Constraints.EqualityAdapter+EqualityComparerAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Collections.IEqualityComparer")), 
      EqualityComparerAdapter__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      EqualityComparerAdapter_AreEqual
    );

    $.Field({Static:false, Public:false}, "comparer", $asm0A.TypeRef("System.Collections.IEqualityComparer")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapter+GenericEqualityAdapter`1 */ 

(function GenericEqualityAdapter$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function GenericEqualityAdapter$b1__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function GenericEqualityAdapter$b1_CanCompare (x, y) {
    return ($thisType.T.get(this).IsAssignableFrom(JSIL.GetType(x)) && $thisType.T.get(this).IsAssignableFrom(JSIL.GetType(y)));
  };

  function GenericEqualityAdapter$b1_ThrowIfNotCompatible (x, y) {
    if (!$thisType.T.get(this).IsAssignableFrom(JSIL.GetType(x))) {
      throw $S00().Construct(JSIL.ConcatString("Cannot compare ", x.toString()));
    }
    if (!$thisType.T.get(this).IsAssignableFrom(JSIL.GetType(y))) {
      throw $S00().Construct(JSIL.ConcatString("Cannot compare ", y.toString()));
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), 
      Name: "NUnit.Framework.Constraints.EqualityAdapter+GenericEqualityAdapter`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      GenericEqualityAdapter$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "CanCompare", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      GenericEqualityAdapter$b1_CanCompare
    );

    $.Method({Static:false, Public:false}, "ThrowIfNotCompatible", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      GenericEqualityAdapter$b1_ThrowIfNotCompatible
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapter+EqualityComparerAdapter`1 */ 

(function EqualityComparerAdapter$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };

  function EqualityComparerAdapter$b1__ctor (comparer) {
    $asm0B.NUnit.Framework.Constraints.EqualityAdapter_GenericEqualityAdapter$b1.Of($thisType.T.get(this)).prototype._ctor.call(this);
    this.comparer = comparer;
  };

  function EqualityComparerAdapter$b1_AreEqual (x, y) {
    var $im00 = $asm0A.System.Collections.Generic.IEqualityComparer$b1.Of($thisType.T.get(this)).Equals;
    $asm0B.NUnit.Framework.Constraints.EqualityAdapter_GenericEqualityAdapter$b1.Of($thisType.T.get(this)).prototype.ThrowIfNotCompatible.call(this, x, y);
    return $im00.Call(this.comparer, null, JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(x)), JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(y)));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter+GenericEqualityAdapter`1", [new JSIL.GenericParameter("T", "NUnit.Framework.Constraints.EqualityAdapter+EqualityComparerAdapter`1")]), 
      Name: "NUnit.Framework.Constraints.EqualityAdapter+EqualityComparerAdapter`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", [$.GenericParameter("T")])]), 
      EqualityComparerAdapter$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      EqualityComparerAdapter$b1_AreEqual
    );

    $.Field({Static:false, Public:false}, "comparer", $asm0A.TypeRef("System.Collections.Generic.IEqualityComparer`1", [$.GenericParameter("T")])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapter+ComparerAdapter`1 */ 

(function ComparerAdapter$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };

  function ComparerAdapter$b1__ctor (comparer) {
    $asm0B.NUnit.Framework.Constraints.EqualityAdapter_GenericEqualityAdapter$b1.Of($thisType.T.get(this)).prototype._ctor.call(this);
    this.comparer = comparer;
  };

  function ComparerAdapter$b1_AreEqual (x, y) {
    var $im00 = $asm0A.System.Collections.Generic.IComparer$b1.Of($thisType.T.get(this)).Compare;
    $asm0B.NUnit.Framework.Constraints.EqualityAdapter_GenericEqualityAdapter$b1.Of($thisType.T.get(this)).prototype.ThrowIfNotCompatible.call(this, x, y);
    return (($im00.Call(this.comparer, null, JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(x)), JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(y))) | 0) === 0);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter+GenericEqualityAdapter`1", [new JSIL.GenericParameter("T", "NUnit.Framework.Constraints.EqualityAdapter+ComparerAdapter`1")]), 
      Name: "NUnit.Framework.Constraints.EqualityAdapter+ComparerAdapter`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")])]), 
      ComparerAdapter$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      ComparerAdapter$b1_AreEqual
    );

    $.Field({Static:false, Public:false}, "comparer", $asm0A.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapter+ComparisonAdapter`1 */ 

(function ComparisonAdapter$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };

  function ComparisonAdapter$b1__ctor (comparer) {
    $asm0B.NUnit.Framework.Constraints.EqualityAdapter_GenericEqualityAdapter$b1.Of($thisType.T.get(this)).prototype._ctor.call(this);
    this.comparer = comparer;
  };

  function ComparisonAdapter$b1_AreEqual (x, y) {
    $asm0B.NUnit.Framework.Constraints.EqualityAdapter_GenericEqualityAdapter$b1.Of($thisType.T.get(this)).prototype.ThrowIfNotCompatible.call(this, x, y);
    return ((this.comparer(JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(x)), JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(y))) | 0) === 0);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter+GenericEqualityAdapter`1", [new JSIL.GenericParameter("T", "NUnit.Framework.Constraints.EqualityAdapter+ComparisonAdapter`1")]), 
      Name: "NUnit.Framework.Constraints.EqualityAdapter+ComparisonAdapter`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Comparison`1", [$.GenericParameter("T")])]), 
      ComparisonAdapter$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      ComparisonAdapter$b1_AreEqual
    );

    $.Field({Static:false, Public:false}, "comparer", $asm0A.TypeRef("System.Comparison`1", [$.GenericParameter("T")])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.EqualityAdapterList */ 

(function EqualityAdapterList$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.Generic.List$b1.Of($asm0B.NUnit.Framework.Constraints.EqualityAdapter))) ();
  };

  function EqualityAdapterList__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Collections.Generic.List`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")]), 
      Name: "NUnit.Framework.Constraints.EqualityAdapterList", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      EqualityAdapterList__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ExactCountConstraint */ 

(function ExactCountConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function ExactCountConstraint__ctor (expectedCount, itemConstraint) {
    $T02().prototype._ctor.call(this, itemConstraint);
    this.set_DisplayName("one");
    this.expectedCount = (expectedCount | 0);
  };

  function ExactCountConstraint_Matches (actual) {
    this.actual = actual;
    if (!$T04().$Is(actual)) {
      throw $S00().Construct("The actual value must be an IEnumerable", "actual");
    }
    var num = 0;
    var enumerator = $IM00().Call($T04().$Cast(actual), null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        if ($S01().CallVirtual("Matches", null, this.baseConstraint, current)) {
          num = ((num + 1) | 0);
        }
      }
    } finally {
      var disposable = $T07().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    return (num === (this.expectedCount | 0));
  };

  function ExactCountConstraint_WriteDescriptionTo (writer) {
    switch (this.expectedCount) {
      case 0: 
        writer.WritePredicate("no item");
        break;

      case 1: 
        writer.WritePredicate("exactly one item");
        break;

      default: 
        writer.WritePredicate(("exactly " + (this.expectedCount).toString() + " items"));
        break;

    }
    (this.baseConstraint).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.ExactCountConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int32, $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      ExactCountConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      ExactCountConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ExactCountConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "expectedCount", $.Int32); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ExactTypeConstraint */ 

(function ExactTypeConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TypeConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function ExactTypeConstraint__ctor (type) {
    $T01().prototype._ctor.call(this, type);
    this.set_DisplayName("typeof");
  };

  function ExactTypeConstraint_Matches (actual) {
    this.actual = actual;
    return ((actual !== null) && (JSIL.GetType(actual) === this.expectedType));
  };

  function ExactTypeConstraint_WriteDescriptionTo (writer) {
    writer.WriteExpectedValue(this.expectedType);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.TypeConstraint"), 
      Name: "NUnit.Framework.Constraints.ExactTypeConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      ExactTypeConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      ExactTypeConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ExactTypeConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ExceptionTypeConstraint */ 

(function ExceptionTypeConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExactTypeConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TypeConstraint)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function ExceptionTypeConstraint__ctor (type) {
    $T01().prototype._ctor.call(this, type);
  };

  function ExceptionTypeConstraint_WriteActualValueTo (writer) {
    var ex = $T03().$As(this.actual);
    $T04().prototype.WriteActualValueTo.call(this, writer);
    if (ex !== null) {
      $S00().CallVirtual("WriteLine", null, writer, " ({0})", ex.get_Message());
      $S01().CallVirtual("Write", null, writer, ex.get_StackTrace());
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ExactTypeConstraint"), 
      Name: "NUnit.Framework.Constraints.ExceptionTypeConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      ExceptionTypeConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ExceptionTypeConstraint_WriteActualValueTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.FailurePoint */ 

(function FailurePoint$Members () {
  var $, $thisType;
  function FailurePoint__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.FailurePoint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      FailurePoint__ctor
    );

    $.Field({Static:false, Public:true }, "Position", $.Int32); 
    $.Field({Static:false, Public:true }, "ExpectedValue", $.Object); 
    $.Field({Static:false, Public:true }, "ActualValue", $.Object); 
    $.Field({Static:false, Public:true }, "ExpectedHasData", $.Boolean); 
    $.Field({Static:false, Public:true }, "ActualHasData", $.Boolean); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.FailurePointList */ 

(function FailurePointList$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.Generic.List$b1.Of($asm0B.NUnit.Framework.Constraints.FailurePoint))) ();
  };

  function FailurePointList__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Collections.Generic.List`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.FailurePoint")]), 
      Name: "NUnit.Framework.Constraints.FailurePointList", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      FailurePointList__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.FalseConstraint */ 

(function FalseConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BasicConstraint)) ();
  };

  function FalseConstraint__ctor () {
    $T00().prototype._ctor.call(this, false, "False");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.BasicConstraint"), 
      Name: "NUnit.Framework.Constraints.FalseConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      FalseConstraint__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.FloatingPointNumerics */ 

(function FloatingPointNumerics$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FloatingPointNumerics_FloatIntUnion)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.UInt32)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FloatingPointNumerics_DoubleLongUnion)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.UInt64)) ();
  };

  function FloatingPointNumerics__ctor () {
  };

  function FloatingPointNumerics_AreAlmostEqualUlps$00 (left, right, maxUlps) {
    var floatIntUnion = new ($T02())();
    var floatIntUnion2 = new ($T02())();
    floatIntUnion.Float = +left;
    floatIntUnion2.Float = +right;
    var num = (floatIntUnion.UInt >>> 0) >>> 31;
    var num2 = (floatIntUnion2.UInt >>> 0) >>> 31;
    var num3 = ((2147483648 - (floatIntUnion.UInt >>> 0)) >>> 0) & num;
    floatIntUnion.UInt = num3 | ((floatIntUnion.UInt >>> 0) & (~num >>> 0));
    var num4 = ((2147483648 - (floatIntUnion2.UInt >>> 0)) >>> 0) & num2;
    floatIntUnion2.UInt = num4 | ((floatIntUnion2.UInt >>> 0) & (~num2 >>> 0));
    return ((Math.abs((((floatIntUnion.Int | 0) - (floatIntUnion2.Int | 0)) | 0))) <= (maxUlps | 0));
  };

  function FloatingPointNumerics_AreAlmostEqualUlps$01 (left, right, maxUlps) {
    var doubleLongUnion = new ($T07())();
    var doubleLongUnion2 = new ($T07())();
    doubleLongUnion.Double = +left;
    doubleLongUnion2.Double = +right;
    var num = $T08().op_RightShift(doubleLongUnion.ULong, 63);
    var num2 = $T08().op_RightShift(doubleLongUnion2.ULong, 63);
    var num3 = $T08().op_BitwiseAnd($T08().op_Subtraction($T08().Create(0, 0, 32768), doubleLongUnion.ULong), num);
    doubleLongUnion.ULong = $T08().op_BitwiseOr(num3, $T08().op_BitwiseAnd(doubleLongUnion.ULong, $T08().op_OnesComplement(num)));
    var num4 = $T08().op_BitwiseAnd($T08().op_Subtraction($T08().Create(0, 0, 32768), doubleLongUnion2.ULong), num2);
    doubleLongUnion2.ULong = $T08().op_BitwiseOr(num4, $T08().op_BitwiseAnd(doubleLongUnion2.ULong, $T08().op_OnesComplement(num2)));
    return $T06().op_LessThanOrEqual(Math.abs($T06().op_Subtraction(doubleLongUnion.Long, doubleLongUnion2.Long)), maxUlps);
  };

  function FloatingPointNumerics_ReinterpretAsDouble (value) {
    var doubleLongUnion = new ($T07())();
    doubleLongUnion.Long = value;
    return doubleLongUnion.Double;
  };

  function FloatingPointNumerics_ReinterpretAsFloat (value) {
    var floatIntUnion = new ($T02())();
    floatIntUnion.Int = (value | 0);
    return floatIntUnion.Float;
  };

  function FloatingPointNumerics_ReinterpretAsInt (value) {
    var floatIntUnion = new ($T02())();
    floatIntUnion.Float = +value;
    return floatIntUnion.Int;
  };

  function FloatingPointNumerics_ReinterpretAsLong (value) {
    var doubleLongUnion = new ($T07())();
    doubleLongUnion.Double = +value;
    return doubleLongUnion.Long;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.FloatingPointNumerics", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      FloatingPointNumerics__ctor
    );

    $.Method({Static:true , Public:true }, "AreAlmostEqualUlps", 
      new JSIL.MethodSignature($.Boolean, [
          $.Single, $.Single, 
          $.Int32
        ]), 
      FloatingPointNumerics_AreAlmostEqualUlps$00
    );

    $.Method({Static:true , Public:true }, "AreAlmostEqualUlps", 
      new JSIL.MethodSignature($.Boolean, [
          $.Double, $.Double, 
          $.Int64
        ]), 
      FloatingPointNumerics_AreAlmostEqualUlps$01
    );

    $.Method({Static:true , Public:true }, "ReinterpretAsDouble", 
      new JSIL.MethodSignature($.Double, [$.Int64]), 
      FloatingPointNumerics_ReinterpretAsDouble
    );

    $.Method({Static:true , Public:true }, "ReinterpretAsFloat", 
      new JSIL.MethodSignature($.Single, [$.Int32]), 
      FloatingPointNumerics_ReinterpretAsFloat
    );

    $.Method({Static:true , Public:true }, "ReinterpretAsInt", 
      new JSIL.MethodSignature($.Int32, [$.Single]), 
      FloatingPointNumerics_ReinterpretAsInt
    );

    $.Method({Static:true , Public:true }, "ReinterpretAsLong", 
      new JSIL.MethodSignature($.Int64, [$.Double]), 
      FloatingPointNumerics_ReinterpretAsLong
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct NUnit.Framework.Constraints.FloatingPointNumerics+FloatIntUnion */ 

(function FloatIntUnion$Members () {
  var $, $thisType;
  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.ValueType"), 
      Name: "NUnit.Framework.Constraints.FloatingPointNumerics+FloatIntUnion", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Field({Static:false, Public:true }, "Float", $.Single); 
    $.Field({Static:false, Public:true }, "Int", $.Int32); 
    $.Field({Static:false, Public:true }, "UInt", $.UInt32); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct NUnit.Framework.Constraints.FloatingPointNumerics+DoubleLongUnion */ 

(function DoubleLongUnion$Members () {
  var $, $thisType;
  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.ValueType"), 
      Name: "NUnit.Framework.Constraints.FloatingPointNumerics+DoubleLongUnion", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Field({Static:false, Public:true }, "Double", $.Double); 
    $.Field({Static:false, Public:true }, "Long", $.Int64); 
    $.Field({Static:false, Public:true }, "ULong", $.UInt64); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.GreaterThanConstraint */ 

(function GreaterThanConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function GreaterThanConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function GreaterThanConstraint_Matches (actual) {
    this.actual = actual;
    if (!((this.expected !== null) && (actual !== null))) {
      throw $S00().Construct("Cannot compare using a null reference");
    }
    return (((this.comparer).Compare(actual, this.expected) | 0) > 0);
  };

  function GreaterThanConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("greater than");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonConstraint"), 
      Name: "NUnit.Framework.Constraints.GreaterThanConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      GreaterThanConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      GreaterThanConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      GreaterThanConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "expected", $.Object); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.GreaterThanOrEqualConstraint */ 

(function GreaterThanOrEqualConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function GreaterThanOrEqualConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function GreaterThanOrEqualConstraint_Matches (actual) {
    this.actual = actual;
    if (!((this.expected !== null) && (actual !== null))) {
      throw $S00().Construct("Cannot compare using a null reference");
    }
    return (((this.comparer).Compare(actual, this.expected) | 0) >= 0);
  };

  function GreaterThanOrEqualConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("greater than or equal to");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonConstraint"), 
      Name: "NUnit.Framework.Constraints.GreaterThanOrEqualConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      GreaterThanOrEqualConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      GreaterThanOrEqualConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      GreaterThanOrEqualConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "expected", $.Object); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.InstanceOfTypeConstraint */ 

(function InstanceOfTypeConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.TypeConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function InstanceOfTypeConstraint__ctor (type) {
    $T01().prototype._ctor.call(this, type);
    this.set_DisplayName("instanceof");
  };

  function InstanceOfTypeConstraint_Matches (actual) {
    this.actual = actual;
    return ((actual !== null) && (this.expectedType).IsInstanceOfType(actual));
  };

  function InstanceOfTypeConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("instance of");
    writer.WriteExpectedValue(this.expectedType);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.TypeConstraint"), 
      Name: "NUnit.Framework.Constraints.InstanceOfTypeConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      InstanceOfTypeConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      InstanceOfTypeConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      InstanceOfTypeConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.LessThanConstraint */ 

(function LessThanConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function LessThanConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function LessThanConstraint_Matches (actual) {
    this.actual = actual;
    if (!((this.expected !== null) && (actual !== null))) {
      throw $S00().Construct("Cannot compare using a null reference");
    }
    return (((this.comparer).Compare(actual, this.expected) | 0) < 0);
  };

  function LessThanConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("less than");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonConstraint"), 
      Name: "NUnit.Framework.Constraints.LessThanConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      LessThanConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      LessThanConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      LessThanConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "expected", $.Object); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.LessThanOrEqualConstraint */ 

(function LessThanOrEqualConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };

  function LessThanOrEqualConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function LessThanOrEqualConstraint_Matches (actual) {
    this.actual = actual;
    if (!((this.expected !== null) && (actual !== null))) {
      throw $S00().Construct("Cannot compare using a null reference");
    }
    return (((this.comparer).Compare(actual, this.expected) | 0) <= 0);
  };

  function LessThanOrEqualConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("less than or equal to");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonConstraint"), 
      Name: "NUnit.Framework.Constraints.LessThanOrEqualConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      LessThanOrEqualConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      LessThanOrEqualConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      LessThanOrEqualConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "expected", $.Object); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.MsgUtils */ 

(function MsgUtils$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Math)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Text.StringBuilder)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Char)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm0A.System.Int32))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Array)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Text.StringBuilder"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Text.StringBuilder"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Text.StringBuilder"), [$asm0A.TypeRef("System.Char")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Text.StringBuilder"), [$asm0A.TypeRef("System.Int32")]))) ();
  };

  function MsgUtils__ctor () {
  };

  function MsgUtils_ClipExpectedAndActual (/* ref */ expected, /* ref */ actual, maxDisplayLength, mismatch) {
    var num = ($T02().Max(expected.get().length, actual.get().length) | 0);
    if (num > (maxDisplayLength | 0)) {
      var num2 = (((maxDisplayLength | 0) - ("...".length | 0)) | 0);
      var num3 = ((num - num2) | 0);
      if (num3 > (mismatch | 0)) {
        num3 = ($T02().Max(0, (((mismatch | 0) - ((num2 / 2) | 0)) | 0)) | 0);
      }
      expected.set($thisType.ClipString(expected.get(), maxDisplayLength, num3));
      actual.set($thisType.ClipString(actual.get(), maxDisplayLength, num3));
    }
  };

  function MsgUtils_ClipString (s, maxStringLength, clipStart) {
    var num = (maxStringLength | 0);
    var stringBuilder = $S00().Construct();
    if ((clipStart | 0) > 0) {
      num = ((num - ("...".length | 0)) | 0);
      $S01().CallVirtual("Append", null, stringBuilder, "...");
    }
    if ((((s.length | 0) - (clipStart | 0)) | 0) > num) {
      num = ((num - ("...".length | 0)) | 0);
      $S01().CallVirtual("Append", null, stringBuilder, s.substr(clipStart, num));
      $S01().CallVirtual("Append", null, stringBuilder, "...");
    } else if ((clipStart | 0) > 0) {
      $S01().CallVirtual("Append", null, stringBuilder, s.substr(clipStart));
    } else {
      $S01().CallVirtual("Append", null, stringBuilder, s);
    }
    return stringBuilder.toString();
  };

  function MsgUtils_EscapeControlChars (s) {
    if (s !== null) {
      var stringBuilder = $S00().Construct();
      var text = s;

      for (var i = 0; i < (text.length | 0); i = ((i + 1) | 0)) {

        var $label0 = 0;
      $labelgroup0: 
        while (true) {
          switch ($label0) {
            case 0: /* $entry0 */ 
              var c = (text[i]);
              var c2 = c;
              if ((c2.charCodeAt(0) | 0) <= (("\\").charCodeAt(0) | 0)) {
                switch (c2) {
                  case "\x00": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\0");
                    break;

                  case "\x01": 
                  case "\x02": 
                  case "\x03": 
                  case "\x04": 
                  case "\x05": 
                  case "\x06": 
                    $label0 = 1 /* goto IL_140 */ ;
                    continue $labelgroup0;

                  case "\x07": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\a");
                    break;

                  case "\x08": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\b");
                    break;

                  case "\t": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\t");
                    break;

                  case "\n": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\n");
                    break;

                  case "\x0b": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\v");
                    break;

                  case "\x0c": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\f");
                    break;

                  case "\r": 
                    $S01().CallVirtual("Append", null, stringBuilder, "\\r");
                    break;

                  default: 
                    if ((c2.charCodeAt(0) | 0) !== (("\\").charCodeAt(0) | 0)) {
                      $label0 = 1 /* goto IL_140 */ ;
                      continue $labelgroup0;
                    }
                    $S01().CallVirtual("Append", null, stringBuilder, "\\\\");
                    break;

                }
              } else {
                if ((c2.charCodeAt(0) | 0) !== (("\x85").charCodeAt(0) | 0)) {
                  switch (c2) {
                    case "\u2028": 
                    case "\u2029": 
                      break;

                    default: 
                      $label0 = 1 /* goto IL_140 */ ;
                      continue $labelgroup0;

                  }
                }
                $S01().CallVirtual("Append", null, stringBuilder, $T00().Format("\\x{0:X4}", c.charCodeAt(0)));
              }
              break $labelgroup0;

            case 1: /* IL_140 */ 
              $S02().CallVirtual("Append", null, stringBuilder, c);
              break $labelgroup0;

          }
        }
        /* Original label IL_14A */ 
      }
      s = stringBuilder.toString();
    }
    return s;
  };

  function MsgUtils_FindMismatchPosition (expected, actual, istart, ignoreCase) {
    var num = ($T02().Min(expected.length, actual.length) | 0);
    var text = (
      ignoreCase
         ? expected.toLowerCase()
         : expected)
    ;
    var text2 = (
      ignoreCase
         ? actual.toLowerCase()
         : actual)
    ;

    for (var i = (istart | 0); i < num; i = ((i + 1) | 0)) {
      if (((text[i]).charCodeAt(0) | 0) !== ((text2[i]).charCodeAt(0) | 0)) {
        var result = i;
        return result;
      }
    }
    if ((expected.length | 0) !== (actual.length | 0)) {
      result = num;
      return result;
    }
    result = -1;
    return result;
  };

  function MsgUtils_GetArrayIndicesAsString (indices) {
    var stringBuilder = $S00().Construct();
    $S02().CallVirtual("Append", null, stringBuilder, "[");

    for (var i = 0; i < (indices.length | 0); i = ((i + 1) | 0)) {
      if (i > 0) {
        $S02().CallVirtual("Append", null, stringBuilder, ",");
      }
      $S01().CallVirtual("Append", null, stringBuilder, (indices[i]).toString());
    }
    $S02().CallVirtual("Append", null, stringBuilder, "]");
    return stringBuilder.toString();
  };

  function MsgUtils_GetArrayIndicesFromCollectionIndex (collection, index) {
    var array = $T09().$As(collection);
    var num = ((
      (array === null)
         ? 1
         : array.get_Rank())
     | 0);
    var array2 = JSIL.Array.New($T01(), num);
    var num2 = num;

    while ((num2 = ((num2 - 1) | 0)) > 0) {
      var length = (array.GetLength(num2) | 0);
      array2[num2] = (((index | 0) % length) | 0);
      index = (((index | 0) / length) | 0);
    }
    array2[0] = (index | 0);
    return array2;
  };

  function MsgUtils_GetTypeRepresentation (obj) {
    var array = $T09().$As(obj);
    if (array === null) {
      var result = $T00().Format("<{0}>", JSIL.GetType(obj));
    } else {
      var stringBuilder = $S00().Construct();
      var type = JSIL.GetType(array);
      var num = 0;

      while (type.get_IsArray()) {
        type = type.GetElementType();
        num = ((num + 1) | 0);
      }
      $S01().CallVirtual("Append", null, stringBuilder, type.toString());
      $S02().CallVirtual("Append", null, stringBuilder, "[");

      for (var i = 0; i < (array.get_Rank() | 0); i = ((i + 1) | 0)) {
        if (i > 0) {
          $S02().CallVirtual("Append", null, stringBuilder, ",");
        }
        $S03().CallVirtual("Append", null, stringBuilder, array.GetLength(i));
      }
      $S02().CallVirtual("Append", null, stringBuilder, "]");

      while ((num = ((num - 1) | 0)) > 0) {
        $S01().CallVirtual("Append", null, stringBuilder, "[]");
      }
      result = $T00().Format("<{0}>", stringBuilder.toString());
    }
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.MsgUtils", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      MsgUtils__ctor
    );

    $.Method({Static:true , Public:true }, "ClipExpectedAndActual", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.String]), $jsilcore.TypeRef("JSIL.Reference", [$.String]), 
          $.Int32, $.Int32
        ]), 
      MsgUtils_ClipExpectedAndActual
    );

    $.Method({Static:true , Public:true }, "ClipString", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.Int32
        ]), 
      MsgUtils_ClipString
    );

    $.Method({Static:true , Public:true }, "EscapeControlChars", 
      new JSIL.MethodSignature($.String, [$.String]), 
      MsgUtils_EscapeControlChars
    );

    $.Method({Static:true , Public:true }, "FindMismatchPosition", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $.Int32, $.Boolean
        ]), 
      MsgUtils_FindMismatchPosition
    );

    $.Method({Static:true , Public:true }, "GetArrayIndicesAsString", 
      new JSIL.MethodSignature($.String, [$jsilcore.TypeRef("System.Array", [$.Int32])]), 
      MsgUtils_GetArrayIndicesAsString
    );

    $.Method({Static:true , Public:true }, "GetArrayIndicesFromCollectionIndex", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Int32]), [$asm0A.TypeRef("System.Collections.IEnumerable"), $.Int32]), 
      MsgUtils_GetArrayIndicesFromCollectionIndex
    );

    $.Method({Static:true , Public:true }, "GetTypeRepresentation", 
      new JSIL.MethodSignature($.String, [$.Object]), 
      MsgUtils_GetTypeRepresentation
    );

    $.Constant({Static:true , Public:false}, "ELLIPSIS", "..."); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NaNConstraint */ 

(function NaNConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Single)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function NaNConstraint__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function NaNConstraint_Matches (actual) {
    this.actual = actual;
    return (($T02().$Is(actual) && 
        (isNaN($T02().$Cast(actual)))) || ($T03().$Is(actual) && 
        (isNaN($T03().$Cast(actual)))));
  };

  function NaNConstraint_WriteDescriptionTo (writer) {
    $S00().CallVirtual("Write", null, writer, "NaN");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.NaNConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NaNConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      NaNConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      NaNConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NoItemConstraint */ 

(function NoItemConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function NoItemConstraint__ctor (itemConstraint) {
    $T01().prototype._ctor.call(this, itemConstraint);
    this.set_DisplayName("none");
  };

  function NoItemConstraint_Matches (actual) {
    this.actual = actual;
    if (!$T03().$Is(actual)) {
      throw $S00().Construct("The actual value must be an IEnumerable", "actual");
    }
    var enumerator = $IM00().Call($T03().$Cast(actual), null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        if ($S01().CallVirtual("Matches", null, this.baseConstraint, current)) {
          var result = false;
          return result;
        }
      }
    } finally {
      var disposable = $T07().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    result = true;
    return result;
  };

  function NoItemConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("no item");
    (this.baseConstraint).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.NoItemConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      NoItemConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      NoItemConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      NoItemConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NotConstraint */ 

(function NotConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };

  function NotConstraint__ctor (baseConstraint) {
    $T01().prototype._ctor.call(this, baseConstraint);
  };

  function NotConstraint_Matches (actual) {
    this.actual = actual;
    return !$S00().CallVirtual("Matches", null, this.baseConstraint, actual);
  };

  function NotConstraint_WriteActualValueTo (writer) {
    (this.baseConstraint).WriteActualValueTo(writer);
  };

  function NotConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("not");
    (this.baseConstraint).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.NotConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      NotConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      NotConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      NotConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      NotConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NullConstraint */ 

(function NullConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BasicConstraint)) ();
  };

  function NullConstraint__ctor () {
    $T00().prototype._ctor.call(this, null, "null");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.BasicConstraint"), 
      Name: "NUnit.Framework.Constraints.NullConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NullConstraint__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NullOrEmptyStringConstraint */ 

(function NullOrEmptyStringConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function NullOrEmptyStringConstraint__ctor () {
    $T00().prototype._ctor.call(this);
    this.set_DisplayName("nullorempty");
  };

  function NullOrEmptyStringConstraint_Matches (actual) {
    this.actual = actual;
    if (actual === null) {
      var result = true;
    } else {
      var text = $T03().$As(actual);
      if (text === null) {
        throw $S00().Construct("Actual value must be a string", "actual");
      }
      result = (text == $T03().Empty);
    }
    return result;
  };

  function NullOrEmptyStringConstraint_WriteDescriptionTo (writer) {
    $S01().CallVirtual("Write", null, writer, "null or empty string");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.NullOrEmptyStringConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NullOrEmptyStringConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      NullOrEmptyStringConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      NullOrEmptyStringConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.Numerics */ 

(function Numerics$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Tolerance)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Double)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Convert)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Single)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ToleranceMode)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Decimal)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.UInt64)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.UInt32)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.GlobalSettings)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.Math)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FloatingPointNumerics)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0A.System.Byte)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0A.System.SByte)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0A.System.Int16)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0A.System.UInt16)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Double"), $asm0A.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Double"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Single"), $asm0A.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Single"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.InvalidOperationException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
        $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Decimal"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.UInt64"), $asm0A.TypeRef("System.UInt64"), 
        $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.UInt64"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Int64"), $asm0A.TypeRef("System.Int64"), 
        $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
      ]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int64"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.UInt32"), $asm0A.TypeRef("System.UInt32"), 
        $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.UInt32"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Int32"), $asm0A.TypeRef("System.Int32"), 
        $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
      ]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S10 = function () {
    return ($S10 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Double"), $asm0A.TypeRef("System.Double"), 
        $asm0A.TypeRef("System.Int64")
      ]))) ();
  };
  var $S11 = function () {
    return ($S11 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S12 = function () {
    return ($S12 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Single"), $asm0A.TypeRef("System.Single"), 
        $asm0A.TypeRef("System.Int32")
      ]))) ();
  };
  var $S13 = function () {
    return ($S13 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Double"), [$asm0A.TypeRef("System.Decimal")]))) ();
  };
  var $S14 = function () {
    return ($S14 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S15 = function () {
    return ($S15 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [$asm0A.TypeRef("System.UInt64")]))) ();
  };
  var $S16 = function () {
    return ($S16 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [$asm0A.TypeRef("System.Int64")]))) ();
  };

  function Numerics__ctor () {
  };

  function Numerics_AreEqual$00 (expected, actual, /* ref */ tolerance) {
    if (!(!$T02().$Is(expected) && !$T02().$Is(actual))) {
      var result = $S00().CallStatic($thisType, "AreEqual", null, 
        $S01().CallStatic($T04(), "ToDouble", null, expected), 
        $S01().CallStatic($T04(), "ToDouble", null, actual), 
        /* ref */ tolerance
      );
    } else if (!(!$T05().$Is(expected) && !$T05().$Is(actual))) {
      result = $S02().CallStatic($thisType, "AreEqual", null, 
        $S03().CallStatic($T04(), "ToSingle", null, expected), 
        $S03().CallStatic($T04(), "ToSingle", null, actual), 
        /* ref */ tolerance
      );
    } else {
      if ((tolerance.get()).get_Mode() === $T06().Ulps) {
        throw $S04().Construct("Ulps may only be specified for floating point arguments");
      }
      if (!(!$T08().$Is(expected) && !$T08().$Is(actual))) {
        result = $S05().CallStatic($thisType, "AreEqual", null, 
          $S06().CallStatic($T04(), "ToDecimal", null, expected), 
          $S06().CallStatic($T04(), "ToDecimal", null, actual), 
          tolerance.get()
        );
      } else if (!(!$T09().$Is(expected) && !$T09().$Is(actual))) {
        result = $S07().CallStatic($thisType, "AreEqual", null, 
          $S08().CallStatic($T04(), "ToUInt64", null, expected), 
          $S08().CallStatic($T04(), "ToUInt64", null, actual), 
          tolerance.get()
        );
      } else if (!(!$T0A().$Is(expected) && !$T0A().$Is(actual))) {
        result = $S09().CallStatic($thisType, "AreEqual", null, 
          $S0A().CallStatic($T04(), "ToInt64", null, expected), 
          $S0A().CallStatic($T04(), "ToInt64", null, actual), 
          tolerance.get()
        );
      } else if (!(!$T0B().$Is(expected) && !$T0B().$Is(actual))) {
        result = $S0B().CallStatic($thisType, "AreEqual", null, 
          $S0C().CallStatic($T04(), "ToUInt32", null, expected), 
          $S0C().CallStatic($T04(), "ToUInt32", null, actual), 
          tolerance.get()
        );
      } else {
        result = $S0D().CallStatic($thisType, "AreEqual", null, 
          $S0E().CallStatic($T04(), "ToInt32", null, expected), 
          $S0E().CallStatic($T04(), "ToInt32", null, actual), 
          tolerance.get()
        );
      }
    }
    return result;
  };

  function Numerics_AreEqual$01 (expected, actual, /* ref */ tolerance) {
    if (!(!(isNaN(expected)) || !(isNaN(actual)))) {
      var result = true;
    } else if (!(!($T02().IsInfinity(expected) || 
          (isNaN(expected))) && !(isNaN(actual)))) {
      result = ((expected === actual));
    } else {
      if (!(!(tolerance.get()).get_IsEmpty() || (+$T0C().DefaultFloatingPointTolerance <= 0))) {
        tolerance.set($S0F().Construct($T0C().DefaultFloatingPointTolerance));
      }
      switch (((tolerance.get()).get_Mode()).valueOf()) {
        case 0: 
          result = ((expected === actual));
          break;

        case 1: 
          result = (Math.abs((+expected - +actual))) <= +$S01().CallStatic($T04(), "ToDouble", null, (tolerance.get()).get_Value());
          break;

        case 2: 
          if (+expected === 0) {
            result = ((expected === actual));
          } else {
            var num = (Math.abs(+(((+expected - +actual) / +expected))));
            result = num <= +((+$S01().CallStatic($T04(), "ToDouble", null, (tolerance.get()).get_Value()) / 100));
          }
          break;

        case 3: 
          result = $S10().CallStatic($T0E(), "AreAlmostEqualUlps", null, expected, actual, $S0A().CallStatic($T04(), "ToInt64", null, (tolerance.get()).get_Value()));
          break;

        default: 
          throw $S11().Construct("Unknown tolerance mode specified", "mode");

      }
    }
    return result;
  };

  function Numerics_AreEqual$02 (expected, actual, /* ref */ tolerance) {
    if (!(!(isNaN(expected)) || !(isNaN(actual)))) {
      var result = true;
    } else if (!(!($T05().IsInfinity(expected) || 
          (isNaN(expected))) && !(isNaN(actual)))) {
      result = ((expected === actual));
    } else {
      if (!(!(tolerance.get()).get_IsEmpty() || (+$T0C().DefaultFloatingPointTolerance <= 0))) {
        tolerance.set($S0F().Construct($T0C().DefaultFloatingPointTolerance));
      }
      switch (((tolerance.get()).get_Mode()).valueOf()) {
        case 0: 
          result = ((expected === actual));
          break;

        case 1: 
          result = (Math.abs((+expected - +actual))) <= +$S01().CallStatic($T04(), "ToDouble", null, (tolerance.get()).get_Value());
          break;

        case 2: 
          if (+expected === 0) {
            result = ((expected === actual));
          } else {
            var num = (Math.abs(+(((+expected - +actual) / +expected))));
            result = num <= +((+$S03().CallStatic($T04(), "ToSingle", null, (tolerance.get()).get_Value()) / 100));
          }
          break;

        case 3: 
          result = $S12().CallStatic($T0E(), "AreAlmostEqualUlps", null, expected, actual, $S0E().CallStatic($T04(), "ToInt32", null, (tolerance.get()).get_Value()));
          break;

        default: 
          throw $S11().Construct("Unknown tolerance mode specified", "mode");

      }
    }
    return result;
  };

  function Numerics_AreEqual$03 (expected, actual, tolerance) {
    switch ((tolerance.get_Mode()).valueOf()) {
      case 0: 
        var result = ((expected === actual));
        break;

      case 1: 
        var num = $S06().CallStatic($T04(), "ToDecimal", null, tolerance.get_Value());
        if ($T08().op_GreaterThan(num, 0)) {
          result = $T08().op_LessThanOrEqual(Math.abs($T08().op_Subtraction(expected, actual)), num);
        } else {
          result = ((expected === actual));
        }
        break;

      case 2: 
        if ($T08().op_Equality(expected, 0)) {
          result = ((expected === actual));
        } else {
          var num2 = (Math.abs(+((+$S13().CallStatic($T08(), "op_Explicit", null, $T08().op_Subtraction(expected, actual)) / +$S13().CallStatic($T08(), "op_Explicit", null, expected)))));
          result = num2 <= +((+$S01().CallStatic($T04(), "ToDouble", null, tolerance.get_Value()) / 100));
        }
        break;

      default: 
        throw $S11().Construct("Unknown tolerance mode specified", "mode");

    }
    return result;
  };

  function Numerics_AreEqual$04 (expected, actual, tolerance) {
    switch ((tolerance.get_Mode()).valueOf()) {
      case 0: 
        var result = expected.Equals(actual);
        break;

      case 1: 
        var num = $S08().CallStatic($T04(), "ToUInt64", null, tolerance.get_Value());
        if (!$T09().op_LessThanOrEqual(num, $T09().Create(0, 0, 0))) {
          var num2 = (
            $T09().op_GreaterThanOrEqual(expected, actual)
               ? $T09().op_Subtraction(expected, actual)
               : $T09().op_Subtraction(actual, expected))
          ;
          result = $T09().op_LessThanOrEqual(num2, num);
        } else {
          result = expected.Equals(actual);
        }
        break;

      case 2: 
        if (!$T09().op_Inequality(expected, $T09().Create(0, 0, 0))) {
          result = expected.Equals(actual);
        } else {
          var num3 = $T09().op_Subtraction(
            $T0D().Max(expected, actual), 
            $T0D().Min(expected, actual)
          );
          var num4 = (Math.abs(+((+num3.ToNumber(-1, false) / +expected.ToNumber(-1, false)))));
          result = num4 <= +((+$S01().CallStatic($T04(), "ToDouble", null, tolerance.get_Value()) / 100));
        }
        break;

      default: 
        throw $S11().Construct("Unknown tolerance mode specified", "mode");

    }
    return result;
  };

  function Numerics_AreEqual$05 (expected, actual, tolerance) {
    switch ((tolerance.get_Mode()).valueOf()) {
      case 0: 
        var result = expected.Equals(actual);
        break;

      case 1: 
        var num = $S0A().CallStatic($T04(), "ToInt64", null, tolerance.get_Value());
        if (!$T0A().op_LessThanOrEqual(num, $T0A().Create(0, 0, 0))) {
          result = $T0A().op_LessThanOrEqual(Math.abs($T0A().op_Subtraction(expected, actual)), num);
        } else {
          result = expected.Equals(actual);
        }
        break;

      case 2: 
        if (!$T0A().op_Inequality(expected, $T0A().Create(0, 0, 0))) {
          result = expected.Equals(actual);
        } else {
          var num2 = (Math.abs(+((+($T0A().op_Subtraction(expected, actual)).ToNumber(-1, false) / +expected.ToNumber(-1, false)))));
          result = num2 <= +((+$S01().CallStatic($T04(), "ToDouble", null, tolerance.get_Value()) / 100));
        }
        break;

      default: 
        throw $S11().Construct("Unknown tolerance mode specified", "mode");

    }
    return result;
  };

  function Numerics_AreEqual$06 (expected, actual, tolerance) {
    switch ((tolerance.get_Mode()).valueOf()) {
      case 0: 
        var result = ((expected === actual));
        break;

      case 1: 
        var num = ($S0C().CallStatic($T04(), "ToUInt32", null, tolerance.get_Value()) >>> 0);
        if (num > 0) {
          var num2 = ((
            ((expected >>> 0) >= (actual >>> 0))
               ? (((expected >>> 0) - (actual >>> 0)) >>> 0)
               : (((actual >>> 0) - (expected >>> 0)) >>> 0))
           >>> 0);
          result = num2 <= num;
        } else {
          result = ((expected === actual));
        }
        break;

      case 2: 
        if ((expected >>> 0) === 0) {
          result = ((expected === actual));
        } else {
          var num3 = ((($T0D().Max(expected, actual) >>> 0) - ($T0D().Min(expected, actual) >>> 0)) >>> 0);
          var num4 = (Math.abs(+((+num3 / +expected))));
          result = num4 <= +((+$S01().CallStatic($T04(), "ToDouble", null, tolerance.get_Value()) / 100));
        }
        break;

      default: 
        throw $S11().Construct("Unknown tolerance mode specified", "mode");

    }
    return result;
  };

  function Numerics_AreEqual$07 (expected, actual, tolerance) {
    switch ((tolerance.get_Mode()).valueOf()) {
      case 0: 
        var result = ((expected === actual));
        break;

      case 1: 
        var num = ($S0E().CallStatic($T04(), "ToInt32", null, tolerance.get_Value()) | 0);
        if (num > 0) {
          result = (Math.abs((((expected | 0) - (actual | 0)) | 0))) <= num;
        } else {
          result = ((expected === actual));
        }
        break;

      case 2: 
        if ((expected | 0) === 0) {
          result = ((expected === actual));
        } else {
          var num2 = (Math.abs(+((+((expected | 0) - (actual | 0)) / +expected))));
          result = num2 <= +((+$S01().CallStatic($T04(), "ToDouble", null, tolerance.get_Value()) / 100));
        }
        break;

      default: 
        throw $S11().Construct("Unknown tolerance mode specified", "mode");

    }
    return result;
  };

  function Numerics_Compare (expected, actual) {
    if (!($thisType.IsNumericType(expected) && $thisType.IsNumericType(actual))) {
      throw $S14().Construct("Both arguments must be numeric");
    }
    if (!(!$thisType.IsFloatingPointNumeric(expected) && !$thisType.IsFloatingPointNumeric(actual))) {
      var result = (JSIL.CompareValues($S01().CallStatic($T04(), "ToDouble", null, expected), $S01().CallStatic($T04(), "ToDouble", null, actual)));
    } else if (!(!$T08().$Is(expected) && !$T08().$Is(actual))) {
      result = (JSIL.CompareValues($S06().CallStatic($T04(), "ToDecimal", null, expected), $S06().CallStatic($T04(), "ToDecimal", null, actual)));
    } else if (!(!$T09().$Is(expected) && !$T09().$Is(actual))) {
      result = ($S15().CallVirtual("CompareTo", null, $S08().CallStatic($T04(), "ToUInt64", null, expected), $S08().CallStatic($T04(), "ToUInt64", null, actual)) | 0);
    } else if (!(!$T0A().$Is(expected) && !$T0A().$Is(actual))) {
      result = ($S16().CallVirtual("CompareTo", null, $S0A().CallStatic($T04(), "ToInt64", null, expected), $S0A().CallStatic($T04(), "ToInt64", null, actual)) | 0);
    } else if (!(!$T0B().$Is(expected) && !$T0B().$Is(actual))) {
      result = (JSIL.CompareValues($S0C().CallStatic($T04(), "ToUInt32", null, expected), $S0C().CallStatic($T04(), "ToUInt32", null, actual)));
    } else {
      result = (JSIL.CompareValues($S0E().CallStatic($T04(), "ToInt32", null, expected), $S0E().CallStatic($T04(), "ToInt32", null, actual)));
    }
    return result;
  };

  function Numerics_IsFixedPointNumeric (obj) {
    if (null !== obj) {
      if ($T11().$Is(obj)) {
        var result = true;
        return result;
      }
      if ($T12().$Is(obj)) {
        result = true;
        return result;
      }
      if ($T08().$Is(obj)) {
        result = true;
        return result;
      }
      if ($T10().$Is(obj)) {
        result = true;
        return result;
      }
      if ($T0B().$Is(obj)) {
        result = true;
        return result;
      }
      if ($T0A().$Is(obj)) {
        result = true;
        return result;
      }
      if ($T09().$Is(obj)) {
        result = true;
        return result;
      }
      if ($T13().$Is(obj)) {
        result = true;
        return result;
      }
      if ($T14().$Is(obj)) {
        result = true;
        return result;
      }
    }
    result = false;
    return result;
  };

  function Numerics_IsFloatingPointNumeric (obj) {
    if (null !== obj) {
      if ($T02().$Is(obj)) {
        var result = true;
        return result;
      }
      if ($T05().$Is(obj)) {
        result = true;
        return result;
      }
    }
    result = false;
    return result;
  };

  function Numerics_IsNumericType (obj) {
    return ($thisType.IsFloatingPointNumeric(obj) || $thisType.IsFixedPointNumeric(obj));
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.Numerics", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      Numerics__ctor
    );

    $.Method({Static:true , Public:true }, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.Object, $.Object, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      Numerics_AreEqual$00
    );

    $.Method({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      Numerics_AreEqual$01
    );

    $.Method({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      Numerics_AreEqual$02
    );

    $.Method({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0A.TypeRef("System.Decimal"), $asm0A.TypeRef("System.Decimal"), 
          $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
        ]), 
      Numerics_AreEqual$03
    );

    $.Method({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.UInt64, $.UInt64, 
          $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
        ]), 
      Numerics_AreEqual$04
    );

    $.Method({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int64, $.Int64, 
          $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
        ]), 
      Numerics_AreEqual$05
    );

    $.Method({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.UInt32, $.UInt32, 
          $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
        ]), 
      Numerics_AreEqual$06
    );

    $.Method({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int32, $.Int32, 
          $asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")
        ]), 
      Numerics_AreEqual$07
    );

    $.Method({Static:true , Public:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$.Object, $.Object]), 
      Numerics_Compare
    );

    $.Method({Static:true , Public:true }, "IsFixedPointNumeric", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      Numerics_IsFixedPointNumeric
    );

    $.Method({Static:true , Public:true }, "IsFloatingPointNumeric", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      Numerics_IsFloatingPointNumeric
    );

    $.Method({Static:true , Public:true }, "IsNumericType", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      Numerics_IsNumericType
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NUnitComparer */ 

(function NUnitComparer$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Numerics)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.IComparable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Reflection.MethodInfo)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Reflection.MethodBase)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Reflection.MethodInfo"), [$asm0A.TypeRef("System.String"), $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Type")])]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.IComparable.CompareTo)) ();
  };

  function NUnitComparer__ctor () {
  };

  function NUnitComparer_Compare (x, y) {
    if (x === null) {
      var result = ((
        (y === null)
           ? 0
           : -1)
       | 0);
    } else if (y === null) {
      result = 1;
    } else if (!(!$T02().IsNumericType(x) || !$T02().IsNumericType(y))) {
      result = ($T02().Compare(x, y) | 0);
    } else if ($T03().$Is(x)) {
      result = ($IM00().Call($T03().$Cast(x), null, y) | 0);
    } else if ($T03().$Is(y)) {
      result = (-$IM00().Call($T03().$Cast(y), null, x) | 0);
    } else {
      var method = $S00().CallVirtual("GetMethod", null, JSIL.GetType(x), "CompareTo", JSIL.Array.New($T05(), [JSIL.GetType(y)]));
      if (method !== null) {
        result = $T01().$Cast(method.Invoke(x, JSIL.Array.New($T00(), [y])));
      } else {
        method = $S00().CallVirtual("GetMethod", null, JSIL.GetType(y), "CompareTo", JSIL.Array.New($T05(), [JSIL.GetType(x)]));
        if (method === null) {
          throw $S01().Construct("Neither value implements IComparable or IComparable<T>");
        }
        result = (-$T01().$Cast(method.Invoke(y, JSIL.Array.New($T00(), [x]))) | 0);
      }
    }
    return result;
  };

  function NUnitComparer_get_Default () {
    return new $thisType();
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.NUnitComparer", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NUnitComparer__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$.Object, $.Object]), 
      NUnitComparer_Compare
    );

    $.Method({Static:true , Public:true }, "get_Default", 
      JSIL.MethodSignature.Return($.Type), 
      NUnitComparer_get_Default
    );

    $.Property({Static:true , Public:true }, "Default", $.Type);

    $.ImplementInterfaces(
      /* 0 */ $asm0A.TypeRef("System.Collections.IComparer")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NUnitComparer`1 */ 

(function NUnitComparer$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Numerics)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.IComparable)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.IComparable.CompareTo)) ();
  };

  function NUnitComparer$b1__ctor () {
  };

  function NUnitComparer$b1_Compare (x, y) {
    var $im00 = $asm0A.System.IComparable$b1.Of($thisType.T.get(this)).CompareTo;
    if (x === null) {
      var result = ((
        (y === null)
           ? 0
           : -1)
       | 0);
    } else if (y === null) {
      result = 1;
    } else if (!(!$T01().IsNumericType(x) || !$T01().IsNumericType(y))) {
      result = ($T01().Compare(JSIL.CloneParameter($thisType.T.get(this), x), JSIL.CloneParameter($thisType.T.get(this), y)) | 0);
    } else if ($asm0A.System.IComparable$b1.Of($thisType.T.get(this)).$Is(x)) {
      result = ($im00.Call($asm0A.System.IComparable$b1.Of($thisType.T.get(this)).$Cast(x), null, JSIL.CloneParameter($thisType.T.get(this), y)) | 0);
    } else {
      if (!$T02().$Is(x)) {
        throw $S00().Construct("Neither value implements IComparable or IComparable<T>");
      }
      result = ($IM00().Call($T02().$Cast(x), null, JSIL.CloneParameter($thisType.T.get(this), y)) | 0);
    }
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.NUnitComparer`1", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NUnitComparer$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$.GenericParameter("T"), $.GenericParameter("T")]), 
      NUnitComparer$b1_Compare
    );

    $.ImplementInterfaces(
      /* 0 */ $asm0A.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface NUnit.Framework.INUnitEqualityComparer */ 

JSIL.MakeInterface(
  "NUnit.Framework.INUnitEqualityComparer", true, [], function ($) {
    $.Method({}, "AreEqual", new JSIL.MethodSignature($.Boolean, [
          $.Object, $.Object, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]));
  }, []);

/* class NUnit.Framework.Constraints.NUnitEqualityComparer */ 

(function NUnitEqualityComparer$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapterList)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Tolerance)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FailurePointList)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NUnitEqualityComparer_RecursionDetector)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Array)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Char)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Collections.IDictionary)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.Collections.ICollection)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionTally)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm0A.System.Collections.DictionaryEntry)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm0A.System.IO.DirectoryInfo)) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm0A.System.IO.FileSystemInfo)) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm0A.System.DateTime)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SamePathConstraint)) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.FailurePoint)) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm0A.System.Collections.Generic.List$b1.Of($asm0B.NUnit.Framework.Constraints.FailurePoint))) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize(System.Array.Of($asm0A.System.Type))) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm0A.System.IEquatable$b1)) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualityAdapter)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm0A.System.Reflection.MethodInfo)) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm0A.System.Reflection.MethodBase)) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm0A.System.Collections.Generic.KeyValuePair$b2)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm0A.System.Reflection.PropertyInfo)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm0A.System.IO.Stream)) ();
  };
  var $T21 = function () {
    return ($T21 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Numerics)) ();
  };
  var $T22 = function () {
    return ($T22 = JSIL.Memoize($asm0A.System.TimeSpan)) ();
  };
  var $T23 = function () {
    return ($T23 = JSIL.Memoize($asm0A.System.DateTimeOffset)) ();
  };
  var $T24 = function () {
    return ($T24 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T25 = function () {
    return ($T25 = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T26 = function () {
    return ($T26 = JSIL.Memoize(System.Array.Of($asm0A.System.Byte))) ();
  };
  var $T27 = function () {
    return ($T27 = JSIL.Memoize($asm0A.System.Byte)) ();
  };
  var $T28 = function () {
    return ($T28 = JSIL.Memoize($asm0A.System.IO.BinaryReader)) ();
  };
  var $T29 = function () {
    return ($T29 = JSIL.Memoize($asm0A.System.IO.SeekOrigin)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Collections.IEnumerable")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [
        $asm0A.TypeRef("System.Object"), $asm0A.TypeRef("System.Object"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.TimeSpan"), [$asm0A.TypeRef("System.DateTime"), $asm0A.TypeRef("System.DateTime")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.TimeSpan"), [$asm0A.TypeRef("System.DateTimeOffset"), $asm0A.TypeRef("System.DateTimeOffset")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.IO.BinaryReader"), [$asm0A.TypeRef("System.IO.Stream")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [
        $jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Byte")]), $asm0A.TypeRef("System.Int32"), 
        $asm0A.TypeRef("System.Int32")
      ]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.ICollection.get_Count)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IDictionary.get_Keys)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM04 = function () {
    return ($IM04 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM05 = function () {
    return ($IM05 = JSIL.Memoize($asm0A.System.Collections.IDictionary.get_Item)) ();
  };
  var $IM06 = function () {
    return ($IM06 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function NUnitEqualityComparer__ctor () {
    this.externalComparers = new ($T00())();
  };

  function NUnitEqualityComparer_AreEqual (expected, actual, /* ref */ tolerance) {
    this.failurePoints = new ($T03())();
    this.recursionDetector = new ($T04())();
    return this.ObjectsEqual(expected, actual, /* ref */ tolerance);
  };

  function NUnitEqualityComparer_ArraysEqual (expected, actual, /* ref */ tolerance) {
    var rank = (expected.get_Rank() | 0);
    if (rank !== (actual.get_Rank() | 0)) {
      var result = false;
    } else {

      for (var i = 1; i < rank; i = ((i + 1) | 0)) {
        if ((expected.GetLength(i) | 0) !== (actual.GetLength(i) | 0)) {
          result = false;
          return result;
        }
      }
      result = this.EnumerablesEqual(expected, actual, /* ref */ tolerance);
    }
    return result;
  };

  function NUnitEqualityComparer_CharsEqual (x, y) {
    var c = (
      this.caseInsensitive
         ? x.toLowerCase()
         : x)
    ;
    var c2 = (
      this.caseInsensitive
         ? y.toLowerCase()
         : y)
    ;
    return ((c.charCodeAt(0) | 0) === (c2.charCodeAt(0) | 0));
  };

  function NUnitEqualityComparer_DictionariesEqual (expected, actual, /* ref */ tolerance) {
    if (($IM00().Call(expected, null) | 0) !== ($IM00().Call(actual, null) | 0)) {
      var result = false;
    } else {
      var collectionTally = new ($T0B())(this, $IM01().Call(expected, null));
      if (!($S00().CallVirtual("TryRemove", null, collectionTally, $IM01().Call(actual, null)) && ((collectionTally.get_Count() | 0) <= 0))) {
        result = false;
      } else {
        var enumerator = $IM02().Call($IM01().Call(expected, null), null);
        try {

          while ($IM03().Call(enumerator, null)) {
            var current = $IM04().Call(enumerator, null);
            if (!this.ObjectsEqual(
                $IM05().Call(expected, null, current), 
                $IM05().Call(actual, null, current), 
                /* ref */ tolerance
              )) {
              result = false;
              return result;
            }
          }
        } finally {
          var disposable = $T0E().$As(enumerator);
          if (disposable !== null) {
            $IM06().Call(disposable, null);
          }
        }
        result = true;
      }
    }
    return result;
  };

  function NUnitEqualityComparer_DictionaryEntriesEqual (x, y, /* ref */ tolerance) {
    var tolerance2 = new JSIL.BoxedVariable($S01().Construct(0));
    return (this.AreEqual(
        x.get_Key(), 
        y.get_Key(), 
        /* ref */ tolerance2
      ) && this.AreEqual(
        x.get_Value(), 
        y.get_Value(), 
        /* ref */ tolerance
      ));
  };

  function NUnitEqualityComparer_DirectoriesEqual (expected, actual) {
    return (!((expected.get_Attributes() !== actual.get_Attributes()) || 
        $T12().op_Inequality(
          expected.get_CreationTime().MemberwiseClone(), 
          actual.get_CreationTime().MemberwiseClone()
        )) && 
      !$T12().op_Inequality(
        expected.get_LastAccessTime().MemberwiseClone(), 
        actual.get_LastAccessTime().MemberwiseClone()
      ) && $S02().CallVirtual("Matches", null, (new ($T14())(expected.get_FullName())), actual.get_FullName()));
  };

  function NUnitEqualityComparer_EnumerablesEqual (expected, actual, /* ref */ tolerance) {
    if ((this.recursionDetector).CheckRecursion(expected, actual)) {
      var result = false;
    } else {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var enumerator = $IM02().Call(expected, null);
            var enumerator2 = $IM02().Call(actual, null);
            var num = 0;

          $loop0: 
            while (true) {
              var flag = $IM03().Call(enumerator, null);
              var flag2 = $IM03().Call(enumerator2, null);
              if (!(flag || flag2)) {
                break $loop0;
              }
              if (!((flag === flag2) && this.ObjectsEqual(
                    $IM04().Call(enumerator, null), 
                    $IM04().Call(enumerator2, null), 
                    /* ref */ tolerance
                  ))) {
                $label0 = 1 /* goto Block_5 */ ;
                continue $labelgroup0;
              }
              num = ((num + 1) | 0);
            }
            result = true;
            return result;

            $label0 = 1 /* goto Block_5 */ ;
            continue $labelgroup0;
          case 1: /* Block_5 */ 
            var failurePoint = new ($T15())();
            failurePoint.Position = num;
            failurePoint.ExpectedHasData = flag;
            if (flag) {
              failurePoint.ExpectedValue = $IM04().Call(enumerator, null);
            }
            failurePoint.ActualHasData = flag2;
            if (flag2) {
              failurePoint.ActualValue = $IM04().Call(enumerator2, null);
            }
            (this.failurePoints).Insert(0, failurePoint);
            result = false;

            break $labelgroup0;
        }
      }
    }
    return result;
  };

  function NUnitEqualityComparer_FirstImplementsIEquatableOfSecond (first, second) {
    var equatableGenericArguments = $thisType.GetEquatableGenericArguments(first);
    var array = equatableGenericArguments;

    for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
      var type = array[i];
      if (type.Equals(second)) {
        var result = true;
        return result;
      }
    }
    result = false;
    return result;
  };

  function NUnitEqualityComparer_get_CompareAsCollection () {
    return this.compareAsCollection;
  };

  function NUnitEqualityComparer_get_Default () {
    return new $thisType();
  };

  function NUnitEqualityComparer_get_ExternalComparers () {
    return this.externalComparers;
  };

  function NUnitEqualityComparer_get_FailurePoints () {
    return this.failurePoints;
  };

  function NUnitEqualityComparer_get_IgnoreCase () {
    return this.caseInsensitive;
  };

  function NUnitEqualityComparer_GetEquatableGenericArguments (type) {
    var interfaces = type.GetInterfaces();

    for (var i = 0; i < (interfaces.length | 0); i = ((i + 1) | 0)) {
      var type2 = interfaces[i];
      if (!(!type2.get_IsGenericType() || !(type2.GetGenericTypeDefinition()).Equals($T19().__Type__))) {
        var result = type2.GetGenericArguments();
        return result;
      }
    }
    result = JSIL.Array.New($T17(), 0);
    return result;
  };

  function NUnitEqualityComparer_GetExternalComparer (x, y) {
    var $temp00;

    for (var a$0 = this.externalComparers._items, i$0 = 0, l$0 = (this.externalComparers._size | 0); i$0 < l$0; ($temp00 = i$0, 
        i$0 = ((i$0 + 1) | 0), 
        $temp00)) {
      var current = a$0[i$0];
      if (current.CanCompare(x, y)) {
        var result = current;
        return result;
      }
    }
    result = null;
    return result;
  };

  function NUnitEqualityComparer_InvokeFirstIEquatableEqualsSecond (first, second) {
    var method = ($T19().__Type__.MakeGenericType(JSIL.Array.New($T17(), [JSIL.GetType(second)]))).GetMethod("Equals");
    return $T07().$Cast(method.Invoke(first, JSIL.Array.New($T01(), [second])));
  };

  function NUnitEqualityComparer_ObjectsEqual (expected, actual, /* ref */ tolerance) {
    var tolerance2 = new JSIL.BoxedVariable(null);
    if (!((expected !== null) || (actual !== null))) {
      var result = true;
    } else if (!((expected !== null) && (actual !== null))) {
      result = false;
    } else if (expected === actual) {
      result = true;
    } else {
      var type = JSIL.GetType(expected);
      var type2 = JSIL.GetType(actual);
      var externalComparer = this.GetExternalComparer(expected, actual);
      if (externalComparer !== null) {
        result = externalComparer.AreEqual(expected, actual);
      } else if (!(!type.get_IsArray() || 
          !type2.get_IsArray() || this.compareAsCollection)) {
        result = this.ArraysEqual($T05().$Cast(expected), $T05().$Cast(actual), /* ref */ tolerance);
      } else if (!(($T09().$As(expected) === null) || !$T09().$Is(actual))) {
        result = this.DictionariesEqual($T09().$Cast(expected), $T09().$Cast(actual), /* ref */ tolerance);
      } else if (!(!$T0F().$Is(expected) || !$T0F().$Is(actual))) {
        result = this.DictionaryEntriesEqual($T0F().$Cast(expected).MemberwiseClone(), $T0F().$Cast(actual).MemberwiseClone(), /* ref */ tolerance);
      } else if (!(!type.get_IsGenericType() || 
          (type.GetGenericTypeDefinition() !== $T1D().__Type__) || 
          !type2.get_IsGenericType() || (type2.GetGenericTypeDefinition() !== $T1D().__Type__))) {
        tolerance2.set($S01().Construct(0));
        var value = (type.GetProperty("Key")).GetValue(expected, null);
        var value2 = (type2.GetProperty("Key")).GetValue(actual, null);
        var value3 = (type.GetProperty("Value")).GetValue(expected, null);
        var value4 = (type2.GetProperty("Value")).GetValue(actual, null);
        result = this.AreEqual(value, value2, /* ref */ tolerance2) && 
        this.AreEqual(value3, value4, /* ref */ tolerance);
      } else if (!(($T0D().$As(expected) === null) || 
          ($T0D().$As(actual) === null) || (($T1F().$As(expected) !== null) && 
            $T1F().$Is(actual)))) {
        result = this.EnumerablesEqual($T0D().$Cast(expected), $T0D().$Cast(actual), /* ref */ tolerance);
      } else if (!(($T1F().$As(expected) === null) || !$T1F().$Is(actual))) {
        result = this.StringsEqual($T1F().$Cast(expected), $T1F().$Cast(actual));
      } else if (!(($T20().$As(expected) === null) || !$T20().$Is(actual))) {
        result = this.StreamsEqual($T20().$Cast(expected), $T20().$Cast(actual));
      } else if (!(!$T08().$Is(expected) || !$T08().$Is(actual))) {
        result = this.CharsEqual($T08().$Cast(expected), $T08().$Cast(actual));
      } else if (!(($T10().$As(expected) === null) || !$T10().$Is(actual))) {
        result = $thisType.DirectoriesEqual($T10().$Cast(expected), $T10().$Cast(actual));
      } else if (!(!$T21().IsNumericType(expected) || !$T21().IsNumericType(actual))) {
        result = $S03().CallStatic($T21(), "AreEqual", null, expected, actual, /* ref */ tolerance);
      } else {
        if (!((tolerance.get() === null) || !$T22().$Is((tolerance.get()).get_Value()))) {
          var t = $T22().$Cast((tolerance.get()).get_Value()).MemberwiseClone();
          if (!(!$T12().$Is(expected) || !$T12().$Is(actual))) {
            result = $T22().op_LessThanOrEqual(($S04().CallStatic($T12(), "op_Subtraction", null, $T12().$Cast(expected), $T12().$Cast(actual)).MemberwiseClone()).Duration().MemberwiseClone(), t.MemberwiseClone());
            return result;
          }
          if (!(!$T23().$Is(expected) || !$T23().$Is(actual))) {
            result = $T22().op_LessThanOrEqual(($S05().CallStatic($T23(), "op_Subtraction", null, $T23().$Cast(expected).MemberwiseClone(), $T23().$Cast(actual).MemberwiseClone()).MemberwiseClone()).Duration().MemberwiseClone(), t.MemberwiseClone());
            return result;
          }
          if (!(!$T22().$Is(expected) || !$T22().$Is(actual))) {
            result = $T22().op_LessThanOrEqual(($T22().op_Subtraction($T22().$Cast(expected), $T22().$Cast(actual)).MemberwiseClone()).Duration().MemberwiseClone(), t.MemberwiseClone());
            return result;
          }
        }
        if ($thisType.FirstImplementsIEquatableOfSecond(type, type2)) {
          result = $thisType.InvokeFirstIEquatableEqualsSecond(expected, actual);
        } else if ($thisType.FirstImplementsIEquatableOfSecond(type2, type)) {
          result = $thisType.InvokeFirstIEquatableEqualsSecond(actual, expected);
        } else {
          result = expected.Object_Equals(actual);
        }
      }
    }
    return result;
  };

  function NUnitEqualityComparer_set_CompareAsCollection (value) {
    this.compareAsCollection = value;
  };

  function NUnitEqualityComparer_set_IgnoreCase (value) {
    this.caseInsensitive = value;
  };

  function NUnitEqualityComparer_StreamsEqual (expected, actual) {
    if (expected === actual) {
      var result = true;
    } else {
      if (!expected.get_CanRead()) {
        throw $S06().Construct("Stream is not readable", "expected");
      }
      if (!actual.get_CanRead()) {
        throw $S06().Construct("Stream is not readable", "actual");
      }
      if (!expected.get_CanSeek()) {
        throw $S06().Construct("Stream is not seekable", "expected");
      }
      if (!actual.get_CanSeek()) {
        throw $S06().Construct("Stream is not seekable", "actual");
      }
      if (!$T25().op_Equality(
          expected.get_Length(), 
          actual.get_Length()
        )) {
        result = false;
      } else {
        var array = JSIL.Array.New($T27(), $thisType.BUFFER_SIZE);
        var array2 = JSIL.Array.New($T27(), $thisType.BUFFER_SIZE);
        var binaryReader = $S07().Construct(expected);
        var binaryReader2 = $S07().Construct(actual);
        var position = expected.get_Position();
        var position2 = actual.get_Position();
        try {
          (binaryReader.get_BaseStream()).Seek($T25().Create(0, 0, 0), $T29().Begin);
          (binaryReader2.get_BaseStream()).Seek($T25().Create(0, 0, 0), $T29().Begin);

          for (var num = $T25().Create(0, 0, 0); $T25().op_LessThan(num, expected.get_Length()); num = $T25().op_Addition(num, $T25().FromNumber($thisType.BUFFER_SIZE))) {
            $S08().CallVirtual("Read", null, binaryReader, array, 0, $thisType.BUFFER_SIZE);
            $S08().CallVirtual("Read", null, binaryReader2, array2, 0, $thisType.BUFFER_SIZE);

            for (var i = 0; i < ($thisType.BUFFER_SIZE | 0); i = ((i + 1) | 0)) {
              if ((array[i] | 0) !== (array2[i] | 0)) {
                var failurePoint = new ($T15())();
                failurePoint.Position = (((num.ToNumber(4294967295, true) | 0) + i) | 0);
                (this.failurePoints).Insert(0, failurePoint);
                result = false;
                return result;
              }
            }
          }
        } finally {
          expected.set_Position(position);
          actual.set_Position(position2);
        }
        result = true;
      }
    }
    return result;
  };

  function NUnitEqualityComparer_StringsEqual (expected, actual) {
    var text = (
      this.caseInsensitive
         ? expected.toLowerCase()
         : expected)
    ;
    var value = (
      this.caseInsensitive
         ? actual.toLowerCase()
         : actual)
    ;
    return text == value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.NUnitEqualityComparer", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NUnitEqualityComparer__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.Object, $.Object, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      NUnitEqualityComparer_AreEqual
    );

    $.Method({Static:false, Public:false}, "ArraysEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0A.TypeRef("System.Array"), $asm0A.TypeRef("System.Array"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      NUnitEqualityComparer_ArraysEqual
    );

    $.Method({Static:false, Public:false}, "CharsEqual", 
      new JSIL.MethodSignature($.Boolean, [$.Char, $.Char]), 
      NUnitEqualityComparer_CharsEqual
    );

    $.Method({Static:false, Public:false}, "DictionariesEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0A.TypeRef("System.Collections.IDictionary"), $asm0A.TypeRef("System.Collections.IDictionary"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      NUnitEqualityComparer_DictionariesEqual
    );

    $.Method({Static:false, Public:false}, "DictionaryEntriesEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0A.TypeRef("System.Collections.DictionaryEntry"), $asm0A.TypeRef("System.Collections.DictionaryEntry"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      NUnitEqualityComparer_DictionaryEntriesEqual
    );

    $.Method({Static:true , Public:false}, "DirectoriesEqual", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.IO.DirectoryInfo"), $asm0A.TypeRef("System.IO.DirectoryInfo")]), 
      NUnitEqualityComparer_DirectoriesEqual
    );

    $.Method({Static:false, Public:false}, "EnumerablesEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      NUnitEqualityComparer_EnumerablesEqual
    );

    $.Method({Static:true , Public:false}, "FirstImplementsIEquatableOfSecond", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Type"), $asm0A.TypeRef("System.Type")]), 
      NUnitEqualityComparer_FirstImplementsIEquatableOfSecond
    );

    $.Method({Static:false, Public:true }, "get_CompareAsCollection", 
      JSIL.MethodSignature.Return($.Boolean), 
      NUnitEqualityComparer_get_CompareAsCollection
    );

    $.Method({Static:true , Public:true }, "get_Default", 
      JSIL.MethodSignature.Return($.Type), 
      NUnitEqualityComparer_get_Default
    );

    $.Method({Static:false, Public:true }, "get_ExternalComparers", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.Generic.IList`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")])), 
      NUnitEqualityComparer_get_ExternalComparers
    );

    $.Method({Static:false, Public:true }, "get_FailurePoints", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Collections.Generic.IList`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.FailurePoint")])), 
      NUnitEqualityComparer_get_FailurePoints
    );

    $.Method({Static:false, Public:true }, "get_IgnoreCase", 
      JSIL.MethodSignature.Return($.Boolean), 
      NUnitEqualityComparer_get_IgnoreCase
    );

    $.Method({Static:true , Public:false}, "GetEquatableGenericArguments", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm0A.TypeRef("System.Type")]), [$asm0A.TypeRef("System.Type")]), 
      NUnitEqualityComparer_GetEquatableGenericArguments
    );

    $.Method({Static:false, Public:false}, "GetExternalComparer", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter"), [$.Object, $.Object]), 
      NUnitEqualityComparer_GetExternalComparer
    );

    $.Method({Static:true , Public:false}, "InvokeFirstIEquatableEqualsSecond", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object]), 
      NUnitEqualityComparer_InvokeFirstIEquatableEqualsSecond
    );

    $.Method({Static:false, Public:false}, "ObjectsEqual", 
      new JSIL.MethodSignature($.Boolean, [
          $.Object, $.Object, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]), 
      NUnitEqualityComparer_ObjectsEqual
    );

    $.Method({Static:false, Public:true }, "set_CompareAsCollection", 
      JSIL.MethodSignature.Action($.Boolean), 
      NUnitEqualityComparer_set_CompareAsCollection
    );

    $.Method({Static:false, Public:true }, "set_IgnoreCase", 
      JSIL.MethodSignature.Action($.Boolean), 
      NUnitEqualityComparer_set_IgnoreCase
    );

    $.Method({Static:false, Public:false}, "StreamsEqual", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.IO.Stream")]), 
      NUnitEqualityComparer_StreamsEqual
    );

    $.Method({Static:false, Public:false}, "StringsEqual", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String]), 
      NUnitEqualityComparer_StringsEqual
    );

    $.Field({Static:false, Public:false}, "caseInsensitive", $.Boolean); 
    $.Field({Static:false, Public:false}, "compareAsCollection", $.Boolean); 
    $.Field({Static:false, Public:false}, "externalComparers", $asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapterList")); 
    $.Field({Static:false, Public:false}, "failurePoints", $asm0B.TypeRef("NUnit.Framework.Constraints.FailurePointList")); 
    $.Field({Static:false, Public:false}, "recursionDetector", $asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector")); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "BUFFER_SIZE", $.Int32, 4096); 
    function NUnitEqualityComparer__cctor () {
      $thisType.BUFFER_SIZE = 4096;
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      NUnitEqualityComparer__cctor
    );

    $.Property({Static:true , Public:true }, "Default", $.Type);

    $.Property({Static:false, Public:true }, "IgnoreCase", $.Boolean);

    $.Property({Static:false, Public:true }, "CompareAsCollection", $.Boolean);

    $.Property({Static:false, Public:true }, "ExternalComparers", $asm0A.TypeRef("System.Collections.Generic.IList`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.EqualityAdapter")]));

    $.Property({Static:false, Public:true }, "FailurePoints", $asm0A.TypeRef("System.Collections.Generic.IList`1", [$asm0B.TypeRef("NUnit.Framework.Constraints.FailurePoint")]));

    $.ImplementInterfaces(
      /* 0 */ $asm0B.TypeRef("NUnit.Framework.INUnitEqualityComparer")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector */ 

(function RecursionDetector$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Collections.Generic.Dictionary$b2.Of($asm0B.NUnit.Framework.Constraints.NUnitEqualityComparer_RecursionDetector_UnorderedReferencePair, $asm0A.System.Object))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NUnitEqualityComparer_RecursionDetector_UnorderedReferencePair)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector+UnorderedReferencePair"), $asm0A.TypeRef("System.Object")]), null))) ();
  };

  function RecursionDetector__ctor () {
    this.table = $S00().Construct();
  };

  function RecursionDetector_CheckRecursion (expected, actual) {
    var unorderedReferencePair = new ($T02())(expected, actual);
    if (this.ContainsPair(unorderedReferencePair)) {
      var result = true;
    } else {
      (this.table).Add(unorderedReferencePair, null);
      result = false;
    }
    return result;
  };

  function RecursionDetector_ContainsPair (pair) {
    return (this.table).ContainsKey(pair);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      RecursionDetector__ctor
    );

    $.Method({Static:false, Public:true }, "CheckRecursion", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable"), $asm0A.TypeRef("System.Collections.IEnumerable")]), 
      RecursionDetector_CheckRecursion
    );

    $.Method({Static:false, Public:false}, "ContainsPair", 
      new JSIL.MethodSignature($.Boolean, [$asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector+UnorderedReferencePair")]), 
      RecursionDetector_ContainsPair
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "table", $asm0A.TypeRef("System.Collections.Generic.Dictionary`2", [$asm0B.TypeRef("NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector+UnorderedReferencePair"), $.Object])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector+UnorderedReferencePair */ 

(function UnorderedReferencePair$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };

  function UnorderedReferencePair__ctor (first, second) {
    this.first = first;
    this.second = second;
  };

  function UnorderedReferencePair_Equals$00 (other) {
    return (((this.first === other.first) && 
        (this.second === other.second)) || ((this.first === other.second) && 
        (this.second === other.first)));
  };

  function UnorderedReferencePair_Object_Equals (obj) {
    return ((null !== obj) && 
      ($thisType.$As(obj) !== null) && this.Equals($thisType.$Cast(obj)));
  };

  function UnorderedReferencePair_GetHashCode () {
    return (Math.imul((
          (this.first !== null)
             ? (this.first).GetHashCode()
             : 0)
        , 397) ^ Math.imul((
          (this.second !== null)
             ? (this.second).GetHashCode()
             : 0)
        , 397));
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.NUnitEqualityComparer+RecursionDetector+UnorderedReferencePair", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      UnorderedReferencePair__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      UnorderedReferencePair_Equals$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      UnorderedReferencePair_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      UnorderedReferencePair_GetHashCode
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "first", $.Object); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "second", $.Object); 
    $.ImplementInterfaces(
      /* 0 */ $asm0A.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.OrConstraint */ 

(function OrConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinaryConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };

  function OrConstraint__ctor (left, right) {
    $T01().prototype._ctor.call(this, left, right);
  };

  function OrConstraint_Matches (actual) {
    this.actual = actual;
    return ($S00().CallVirtual("Matches", null, this.left, actual) || $S00().CallVirtual("Matches", null, this.right, actual));
  };

  function OrConstraint_WriteDescriptionTo (writer) {
    (this.left).WriteDescriptionTo(writer);
    writer.WriteConnector("or");
    (this.right).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.BinaryConstraint"), 
      Name: "NUnit.Framework.Constraints.OrConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      OrConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      OrConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      OrConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.PathConstraint */ 

(function PathConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Char)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.IO.Path)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize(System.Array.Of($asm0A.System.String))) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm0A.System.Char))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.Boolean")
      ]))) ();
  };

  function PathConstraint__ctor (expectedPath) {
    this.caseInsensitive = ($T02().DirectorySeparatorChar.charCodeAt(0) | 0) === (("\\").charCodeAt(0) | 0);
    $T03().prototype._ctor.call(this, expectedPath);
    this.expectedPath = expectedPath;
  };

  function PathConstraint_Canonicalize (path) {
    if (($T02().DirectorySeparatorChar.charCodeAt(0) | 0) !== ($T02().AltDirectorySeparatorChar.charCodeAt(0) | 0)) {
      path = (System.String.Replace(path, $T02().AltDirectorySeparatorChar, $T02().DirectorySeparatorChar));
    }
    var text = "";
    var text2 = path;

  $loop0: 
    for (var i = 0; i < (text2.length | 0); i = ((i + 1) | 0)) {
      var c = (text2[i]);
      if (((c.charCodeAt(0) | 0) !== (("\\").charCodeAt(0) | 0)) && ((c.charCodeAt(0) | 0) !== (("/").charCodeAt(0) | 0))) {
        break $loop0;
      }
      text = (JSIL.ConcatString(text, $T02().DirectorySeparatorChar));
    }
    var array = (JSIL.SplitString(path, $thisType.DirectorySeparatorChars));
    var num = 0;
    var flag = false;
    var array2 = array;

    for (i = 0; i < (array2.length | 0); i = ((i + 1) | 0)) {

      var $label0 = 0;
    $labelgroup0: 
      while (true) {
        switch ($label0) {
          case 0: /* $entry0 */ 
            var text3 = array2[i];
            var text4 = text3;
            if (text4 === null) {
              $label0 = 1 /* goto IL_F5 */ ;
              continue $labelgroup0;
            }
            if (!((text4 == "") || (text4 == "."))) {
              if (!(text4 == "..")) {
                $label0 = 1 /* goto IL_F5 */ ;
                continue $labelgroup0;
              }
              flag = true;
              if (num > 0) {
                num = ((num - 1) | 0);
              }
            } else {
              flag = true;
            }
            break $labelgroup0;

          case 1: /* IL_F5 */ 
            if (flag) {
              array[num] = text3;
            }
            num = ((num + 1) | 0);
            break $labelgroup0;

        }
      }
      /* Original label IL_10B */ 
    }
    return JSIL.ConcatString(text, $T01().Join($T02().DirectorySeparatorChar.toString(), array, 0, num));
  };

  function PathConstraint_get_IgnoreCase () {
    this.caseInsensitive = true;
    return this;
  };

  function PathConstraint_get_RespectCase () {
    this.caseInsensitive = false;
    return this;
  };

  function PathConstraint_GetStringRepresentation () {
    return $T01().Format("<{0} \"{1}\" {2}>", this.get_DisplayName(), this.expectedPath, (
        this.caseInsensitive
           ? "ignorecase"
           : "respectcase")
    );
  };

  function PathConstraint_IsSubPath (path1, path2, ignoreCase) {
    var length = (path1.length | 0);
    var length2 = (path2.length | 0);
    return ((length < length2) && 
      (($S00().CallStatic($T01(), "Compare", null, path1, path2.substr(0, length), ignoreCase) | 0) === 0) && ((((path2[((length - 1) | 0)]).charCodeAt(0) | 0) === ($T02().DirectorySeparatorChar.charCodeAt(0) | 0)) || 
        ((length2 > length) && 
          (((path2[length]).charCodeAt(0) | 0) === ($T02().DirectorySeparatorChar.charCodeAt(0) | 0)))));
  };

  function PathConstraint_Matches (actual) {
    this.actual = actual;
    var text = $T01().$As(actual);
    return ((text !== null) && this.IsMatch(this.expectedPath, text));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.PathConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      PathConstraint__ctor
    );

    $.Method({Static:true , Public:false}, "Canonicalize", 
      new JSIL.MethodSignature($.String, [$.String]), 
      PathConstraint_Canonicalize
    );

    $.Method({Static:false, Public:true }, "get_IgnoreCase", 
      JSIL.MethodSignature.Return($.Type), 
      PathConstraint_get_IgnoreCase
    );

    $.Method({Static:false, Public:true }, "get_RespectCase", 
      JSIL.MethodSignature.Return($.Type), 
      PathConstraint_get_RespectCase
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      PathConstraint_GetStringRepresentation
    );

    $.Method({Static:true , Public:false}, "IsSubPath", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $.Boolean
        ]), 
      PathConstraint_IsSubPath
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      PathConstraint_Matches
    );

    $.Constant({Static:true , Public:false}, "WindowsDirectorySeparatorChar", "\\"); 
    $.Constant({Static:true , Public:false}, "NonWindowsDirectorySeparatorChar", "/"); 
    $.Field({Static:true , Public:false, ReadOnly:true }, "DirectorySeparatorChars", $jsilcore.TypeRef("System.Array", [$.Char])); 
    $.Field({Static:false, Public:false}, "expectedPath", $.String); 
    $.Field({Static:false, Public:false}, "caseInsensitive", $.Boolean); 
    function PathConstraint__cctor () {
      $thisType.DirectorySeparatorChars = JSIL.Array.New($T00(), ["\\", "/"]);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      PathConstraint__cctor
    );

    $.Property({Static:false, Public:true }, "IgnoreCase", $.Type);

    $.Property({Static:false, Public:true }, "RespectCase", $.Type);

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.PredicateConstraint`1 */ 

(function PredicateConstraint$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Delegate)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function PredicateConstraint$b1__ctor (predicate) {
    $T00().prototype._ctor.call(this);
    this.predicate = predicate;
  };

  function PredicateConstraint$b1_Matches (actual) {
    this.actual = actual;
    if (!$thisType.T.get(this).$Is(actual)) {
      throw $S00().Construct(JSIL.ConcatString("The actual value is not of type ", $thisType.T.get(this).get_Name()), "actual");
    }
    return this.predicate(JSIL.CloneParameter($thisType.T.get(this), $thisType.T.get(this).$Cast(actual)));
  };

  function PredicateConstraint$b1_WriteDescriptionTo (writer) {
    writer.WritePredicate("value matching");
    $S01().CallVirtual("Write", null, writer, (
        System.String.StartsWith(((this.predicate).get_Method()).get_Name(), "<")
           ? "lambda expression"
           : ((this.predicate).get_Method()).get_Name())
    );
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.PredicateConstraint`1", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Predicate`1", [$.GenericParameter("T")])]), 
      PredicateConstraint$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      PredicateConstraint$b1_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      PredicateConstraint$b1_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "predicate", $asm0A.TypeRef("System.Predicate`1", [$.GenericParameter("T")])); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.PropertyConstraint */ 

(function PropertyConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Guard)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Reflection.PropertyInfo)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Reflection.BindingFlags)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.EqualConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Reflection.PropertyInfo"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Reflection.BindingFlags")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };

  function PropertyConstraint__ctor (name, baseConstraint) {
    $T02().prototype._ctor.call(this, baseConstraint);
    this.$name = name;
  };

  function PropertyConstraint_GetStringRepresentation () {
    return $T00().Format("<property {0} {1}>", this.$name, this.baseConstraint);
  };

  function PropertyConstraint_Matches (actual) {
    this.actual = actual;
    $T04().ArgumentNotNull(actual, "actual");
    var type = $T05().$As(actual);
    if (type === null) {
      type = JSIL.GetType(actual);
    }
    var property = $S00().CallVirtual("GetProperty", null, type, this.$name, $T07().$Flags("GetProperty", "Instance", "NonPublic", "Public"));
    if (property === null) {
      throw $S01().Construct($T00().Format("Property {0} was not found", this.$name), "name");
    }
    this.propValue = property.GetValue(actual, null);
    return $S02().CallVirtual("Matches", null, this.baseConstraint, this.propValue);
  };

  function PropertyConstraint_WriteActualValueTo (writer) {
    writer.WriteActualValue(this.propValue);
  };

  function PropertyConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate(JSIL.ConcatString("property ", this.$name));
    if (this.baseConstraint !== null) {
      if ($T0A().$Is(this.baseConstraint)) {
        writer.WritePredicate("equal to");
      }
      (this.baseConstraint).WriteDescriptionTo(writer);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.PropertyConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      PropertyConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      PropertyConstraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      PropertyConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      PropertyConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      PropertyConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "$name", $.String); 
    $.Field({Static:false, Public:false}, "propValue", $.Object); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.PropertyExistsConstraint */ 

(function PropertyExistsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Guard)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Reflection.PropertyInfo)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Reflection.BindingFlags)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Reflection.PropertyInfo"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Reflection.BindingFlags")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function PropertyExistsConstraint__ctor (name) {
    $T01().prototype._ctor.call(this, name);
    this.$name = name;
  };

  function PropertyExistsConstraint_GetStringRepresentation () {
    return $T00().Format("<propertyexists {0}>", this.$name);
  };

  function PropertyExistsConstraint_Matches (actual) {
    this.actual = actual;
    $T03().ArgumentNotNull(actual, "actual");
    this.actualType = $T04().$As(actual);
    if (this.actualType === null) {
      this.actualType = JSIL.GetType(actual);
    }
    var property = $S00().CallVirtual("GetProperty", null, this.actualType, this.$name, $T06().$Flags("GetProperty", "Instance", "NonPublic", "Public"));
    return (property !== null);
  };

  function PropertyExistsConstraint_WriteActualValueTo (writer) {
    writer.WriteActualValue(this.actualType);
  };

  function PropertyExistsConstraint_WriteDescriptionTo (writer) {
    $S01().CallVirtual("Write", null, writer, JSIL.ConcatString("property ", this.$name));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.PropertyExistsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      PropertyExistsConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      PropertyExistsConstraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      PropertyExistsConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      PropertyExistsConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      PropertyExistsConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "$name", $.String); 
    $.Field({Static:false, Public:false}, "actualType", $asm0A.TypeRef("System.Type")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.RangeConstraint`1 */ 

(function RangeConstraint$b1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonConstraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ComparisonAdapter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object"), 
        $asm0A.TypeRef("System.Object")
      ]))) ();
  };

  function RangeConstraint$b1__ctor (from, to) {
    var $im00 = $asm0A.System.IComparable$b1.Of($thisType.T.get(this)).CompareTo;
    $T00().prototype._ctor.call(this, JSIL.CloneParameter($thisType.T.get(this), from), JSIL.CloneParameter($thisType.T.get(this), to));
    if (($im00.Call(from, null, JSIL.CloneParameter($thisType.T.get(this), to)) | 0) > 0) {
      throw $S00().Construct("from must be less than to");
    }
    this.from = JSIL.CloneParameter($thisType.T.get(this), from);
    this.to = JSIL.CloneParameter($thisType.T.get(this), to);
  };

  function RangeConstraint$b1_Matches (actual) {
    this.actual = actual;
    if (!(!((this.from === null) || 
          (this.to === null)) && (actual !== null))) {
      throw $S01().Construct("Cannot compare using a null reference", "actual");
    }
    return ((((this.comparer).Compare(JSIL.CloneParameter($thisType.T.get(this), this.from), actual) | 0) <= 0) && (((this.comparer).Compare(JSIL.CloneParameter($thisType.T.get(this), this.to), actual) | 0) >= 0));
  };

  function RangeConstraint$b1_WriteDescriptionTo (writer) {
    $S02().CallVirtual("Write", null, writer, "in range ({0},{1})", JSIL.CloneParameter($thisType.T.get(this), this.from), JSIL.CloneParameter($thisType.T.get(this), this.to));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ComparisonConstraint"), 
      Name: "NUnit.Framework.Constraints.RangeConstraint`1", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.GenericParameter("T"), $.GenericParameter("T")]), 
      RangeConstraint$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      RangeConstraint$b1_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      RangeConstraint$b1_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "from", $.GenericParameter("T")); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "to", $.GenericParameter("T")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.RegexConstraint */ 

(function RegexConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StringConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0D.System.Text.RegularExpressions.Regex)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0D.System.Text.RegularExpressions.RegexOptions)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function RegexConstraint__ctor (pattern) {
    $T01().prototype._ctor.call(this, pattern);
  };

  function RegexConstraint_Matches$00 (actual) {
    return $T02().IsMatch(actual, this.expected, (
        this.caseInsensitive
           ? $T03().IgnoreCase
           : $T03().None)
    );
  };

  function RegexConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("String matching");
    writer.WriteExpectedValue(this.expected);
    if (this.caseInsensitive) {
      writer.WriteModifier("ignoring case");
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.StringConstraint"), 
      Name: "NUnit.Framework.Constraints.RegexConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      RegexConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      RegexConstraint_Matches$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      RegexConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ResolvableConstraintExpression */ 

(function ResolvableConstraintExpression$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpression)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintExpressionBase)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AndOperator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.OrOperator)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NullConstraint)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AndConstraint)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.OrConstraint)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), [$asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };

  function ResolvableConstraintExpression__ctor$00 () {
    $T00().prototype._ctor.call(this);
  };

  function ResolvableConstraintExpression__ctor$01 (builder) {
    $T00().prototype._ctor.call(this, builder);
  };

  function ResolvableConstraintExpression_get_And () {
    return $S00().CallVirtual("Append", null, this, new ($T03())());
  };

  function ResolvableConstraintExpression_get_Or () {
    return $S00().CallVirtual("Append", null, this, new ($T04())());
  };

  function ResolvableConstraintExpression_NUnit_Framework_Constraints_IResolveConstraint_Resolve () {
    return (this.builder).Resolve();
  };

  function ResolvableConstraintExpression_op_BitwiseAnd$02 (left, right) {
    return $thisType.OperatorAndImplementation(left, right);
  };

  function ResolvableConstraintExpression_op_BitwiseAnd$03 (left, right) {
    return $thisType.OperatorAndImplementation(left, right);
  };

  function ResolvableConstraintExpression_op_BitwiseAnd$04 (left, right) {
    return $thisType.OperatorAndImplementation(left, right);
  };

  function ResolvableConstraintExpression_op_BitwiseOr$05 (left, right) {
    return $thisType.OperatorOrImplementation(left, right);
  };

  function ResolvableConstraintExpression_op_BitwiseOr$06 (left, right) {
    return $thisType.OperatorOrImplementation(left, right);
  };

  function ResolvableConstraintExpression_op_BitwiseOr$07 (left, right) {
    return $thisType.OperatorOrImplementation(left, right);
  };

  function ResolvableConstraintExpression_op_LogicalNot (constraint) {
    return new ($T06())((
        (constraint === null)
           ? new ($T07())()
           : $IM00().Call(constraint, null))
    );
  };

  function ResolvableConstraintExpression_OperatorAndImplementation (left, right) {
    return new ($T09())($IM00().Call(left, null), $IM00().Call(right, null));
  };

  function ResolvableConstraintExpression_OperatorOrImplementation (left, right) {
    return new ($T0A())($IM00().Call(left, null), $IM00().Call(right, null));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"), 
      Name: "NUnit.Framework.Constraints.ResolvableConstraintExpression", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ResolvableConstraintExpression__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder")), 
      ResolvableConstraintExpression__ctor$01
    );

    $.Method({Static:false, Public:true }, "get_And", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      ResolvableConstraintExpression_get_And
    );

    $.Method({Static:false, Public:true }, "get_Or", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression")), 
      ResolvableConstraintExpression_get_Or
    );

    $.Method({Static:false, Public:false, Virtual:true }, "NUnit.Framework.Constraints.IResolveConstraint.Resolve", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ResolvableConstraintExpression_NUnit_Framework_Constraints_IResolveConstraint_Resolve
    )
      .Overrides($asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), "Resolve");

    $.Method({Static:true , Public:true }, "op_BitwiseAnd", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$.Type, $.Type]), 
      ResolvableConstraintExpression_op_BitwiseAnd$02
    );

    $.Method({Static:true , Public:true }, "op_BitwiseAnd", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $.Type]), 
      ResolvableConstraintExpression_op_BitwiseAnd$03
    );

    $.Method({Static:true , Public:true }, "op_BitwiseAnd", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$.Type, $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      ResolvableConstraintExpression_op_BitwiseAnd$04
    );

    $.Method({Static:true , Public:true }, "op_BitwiseOr", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$.Type, $.Type]), 
      ResolvableConstraintExpression_op_BitwiseOr$05
    );

    $.Method({Static:true , Public:true }, "op_BitwiseOr", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$.Type, $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      ResolvableConstraintExpression_op_BitwiseOr$06
    );

    $.Method({Static:true , Public:true }, "op_BitwiseOr", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $.Type]), 
      ResolvableConstraintExpression_op_BitwiseOr$07
    );

    $.Method({Static:true , Public:true }, "op_LogicalNot", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$.Type]), 
      ResolvableConstraintExpression_op_LogicalNot
    );

    $.Method({Static:true , Public:false}, "OperatorAndImplementation", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      ResolvableConstraintExpression_OperatorAndImplementation
    );

    $.Method({Static:true , Public:false}, "OperatorOrImplementation", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint"), $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")]), 
      ResolvableConstraintExpression_OperatorOrImplementation
    );

    $.Property({Static:false, Public:true }, "And", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.Property({Static:false, Public:true }, "Or", $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintExpression"));

    $.ImplementInterfaces(
      /* 0 */ $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ReusableConstraint */ 

(function ReusableConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IResolveConstraint.Resolve)) ();
  };

  function ReusableConstraint__ctor (c) {
    this.constraint = $IM00().Call(c, null);
  };

  function ReusableConstraint_op_Implicit (c) {
    return new $thisType(c);
  };

  function ReusableConstraint_Resolve () {
    return this.constraint;
  };

  function ReusableConstraint_toString () {
    return (this.constraint).toString();
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ReusableConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")), 
      ReusableConstraint__ctor
    );

    $.Method({Static:true , Public:true }, "op_Implicit", 
      new JSIL.MethodSignature($.Type, [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      ReusableConstraint_op_Implicit
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Resolve", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ReusableConstraint_Resolve
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      ReusableConstraint_toString
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "constraint", $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")); 
    $.ImplementInterfaces(
      /* 0 */ $asm0B.TypeRef("NUnit.Framework.Constraints.IResolveConstraint")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SameAsConstraint */ 

(function SameAsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function SameAsConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
    this.expected = expected;
  };

  function SameAsConstraint_Matches (actual) {
    this.actual = actual;
    return (this.expected === actual);
  };

  function SameAsConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("same as");
    writer.WriteExpectedValue(this.expected);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.SameAsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      SameAsConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      SameAsConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      SameAsConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "expected", $.Object); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SamePathConstraint */ 

(function SamePathConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PathConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.Boolean")
      ]))) ();
  };

  function SamePathConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
  };

  function SamePathConstraint_IsMatch (expectedPath, actualPath) {
    return (($S00().CallStatic($T00(), "Compare", null, 
        $T01().Canonicalize(expectedPath), 
        $T01().Canonicalize(actualPath), 
        this.caseInsensitive
      ) | 0) === 0);
  };

  function SamePathConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("Path matching");
    writer.WriteExpectedValue(this.expectedPath);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PathConstraint"), 
      Name: "NUnit.Framework.Constraints.SamePathConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      SamePathConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "IsMatch", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String]), 
      SamePathConstraint_IsMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      SamePathConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SamePathOrUnderConstraint */ 

(function SamePathOrUnderConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PathConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int32"), [
        $asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String"), 
        $asm0A.TypeRef("System.Boolean")
      ]))) ();
  };

  function SamePathOrUnderConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
  };

  function SamePathOrUnderConstraint_IsMatch (expectedPath, actualPath) {
    var text = $T01().Canonicalize(expectedPath);
    var text2 = $T01().Canonicalize(actualPath);
    return ((($S00().CallStatic($T00(), "Compare", null, text, text2, this.caseInsensitive) | 0) === 0) || $T01().IsSubPath(text, text2, this.caseInsensitive));
  };

  function SamePathOrUnderConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("Path under or matching");
    writer.WriteExpectedValue(this.expectedPath);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PathConstraint"), 
      Name: "NUnit.Framework.Constraints.SamePathOrUnderConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      SamePathOrUnderConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "IsMatch", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String]), 
      SamePathOrUnderConstraint_IsMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      SamePathOrUnderConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SomeItemsConstraint */ 

(function SomeItemsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function SomeItemsConstraint__ctor (itemConstraint) {
    $T01().prototype._ctor.call(this, itemConstraint);
    this.set_DisplayName("some");
  };

  function SomeItemsConstraint_Matches (actual) {
    this.actual = actual;
    if (!$T03().$Is(actual)) {
      throw $S00().Construct("The actual value must be an IEnumerable", "actual");
    }
    var enumerator = $IM00().Call($T03().$Cast(actual), null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        if ($S01().CallVirtual("Matches", null, this.baseConstraint, current)) {
          var result = true;
          return result;
        }
      }
    } finally {
      var disposable = $T07().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    result = false;
    return result;
  };

  function SomeItemsConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("some item");
    (this.baseConstraint).WriteDescriptionTo(writer);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.SomeItemsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      SomeItemsConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      SomeItemsConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      SomeItemsConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.StartsWithConstraint */ 

(function StartsWithConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StringConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MsgUtils)) ();
  };

  function StartsWithConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
  };

  function StartsWithConstraint_Matches$00 (actual) {
    if (this.caseInsensitive) {
      var result = (System.String.StartsWith(actual.toLowerCase(), this.expected.toLowerCase()));
    } else {
      result = (System.String.StartsWith(actual, this.expected));
    }
    return result;
  };

  function StartsWithConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("String starting with");
    writer.WriteExpectedValue($T04().ClipString(this.expected, (((writer.get_MaxLineLength() | 0) - 40) | 0), 0));
    if (this.caseInsensitive) {
      writer.WriteModifier("ignoring case");
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.StringConstraint"), 
      Name: "NUnit.Framework.Constraints.StartsWithConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      StartsWithConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      StartsWithConstraint_Matches$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      StartsWithConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SubPathConstraint */ 

(function SubPathConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PathConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function SubPathConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
  };

  function SubPathConstraint_IsMatch (expectedPath, actualPath) {
    return $T01().IsSubPath(
      $T01().Canonicalize(expectedPath), 
      $T01().Canonicalize(actualPath), 
      this.caseInsensitive
    );
  };

  function SubPathConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("Path under");
    writer.WriteExpectedValue(this.expectedPath);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PathConstraint"), 
      Name: "NUnit.Framework.Constraints.SubPathConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      SubPathConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "IsMatch", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String]), 
      SubPathConstraint_IsMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      SubPathConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SubstringConstraint */ 

(function SubstringConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.StringConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };

  function SubstringConstraint__ctor (expected) {
    $T01().prototype._ctor.call(this, expected);
  };

  function SubstringConstraint_Matches$00 (actual) {
    if (this.caseInsensitive) {
      var result = (actual.toLowerCase().indexOf(this.expected.toLowerCase())) >= 0;
    } else {
      result = (actual.indexOf(this.expected)) >= 0;
    }
    return result;
  };

  function SubstringConstraint_WriteDescriptionTo (writer) {
    writer.WritePredicate("String containing");
    writer.WriteExpectedValue(this.expected);
    if (this.caseInsensitive) {
      writer.WriteModifier("ignoring case");
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.StringConstraint"), 
      Name: "NUnit.Framework.Constraints.SubstringConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      SubstringConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      SubstringConstraint_Matches$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      SubstringConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ThrowsConstraint */ 

(function ThrowsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixConstraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExceptionInterceptor)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function ThrowsConstraint__ctor (baseConstraint) {
    $T01().prototype._ctor.call(this, baseConstraint);
  };

  function ThrowsConstraint_get_ActualException () {
    return this.caughtException;
  };

  function ThrowsConstraint_GetStringRepresentation () {
    if (this.baseConstraint === null) {
      var result = "<throws>";
    } else {
      result = $T00().prototype.GetStringRepresentation.call(this);
    }
    return result;
  };

  function ThrowsConstraint_Matches (actual) {
    this.caughtException = $T04().Intercept(actual);
    return ((this.caughtException !== null) && ((this.baseConstraint === null) || 
        $S00().CallVirtual("Matches", null, this.baseConstraint, this.caughtException)));
  };

  function ThrowsConstraint_Matches$b1$00 (T, del) {
    return $S00().CallVirtual("Matches", null, this, new ($asm0B.NUnit.Framework.Constraints.GenericInvocationDescriptor$b1.Of(T)) (del));
  };

  function ThrowsConstraint_WriteActualValueTo (writer) {
    if (this.caughtException === null) {
      $S01().CallVirtual("Write", null, writer, "no exception thrown");
    } else if (this.baseConstraint !== null) {
      (this.baseConstraint).WriteActualValueTo(writer);
    } else {
      writer.WriteActualValue(this.caughtException);
    }
  };

  function ThrowsConstraint_WriteDescriptionTo (writer) {
    if (this.baseConstraint === null) {
      writer.WritePredicate("an exception");
    } else {
      (this.baseConstraint).WriteDescriptionTo(writer);
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixConstraint"), 
      Name: "NUnit.Framework.Constraints.ThrowsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")), 
      ThrowsConstraint__ctor
    );

    $.Method({Static:false, Public:true }, "get_ActualException", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Exception")), 
      ThrowsConstraint_get_ActualException
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      ThrowsConstraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      ThrowsConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"])], ["T"]), 
      ThrowsConstraint_Matches$b1$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ThrowsConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ThrowsConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "caughtException", $asm0A.TypeRef("System.Exception")); 
    $.Property({Static:false, Public:true }, "ActualException", $asm0A.TypeRef("System.Exception"));

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ExceptionInterceptor */ 

(function ExceptionInterceptor$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IInvocationDescriptor)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.TestDelegate)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.VoidInvocationDescriptor)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0B.NUnit.Framework.AsyncInvocationRegion)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.AsyncInvocationRegion"), [$asm0A.TypeRef("System.Delegate")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IInvocationDescriptor.get_Delegate)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.IInvocationDescriptor.Invoke)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function ExceptionInterceptor__ctor () {
  };

  function ExceptionInterceptor_GetInvocationDescriptor (actual) {
    var invocationDescriptor = $T01().$As(actual);
    if (invocationDescriptor === null) {
      var testDelegate = $T02().$As(actual);
      if (testDelegate === null) {
        throw $S00().Construct($T04().Format("The actual value must be a TestDelegate or ActualValueDelegate but was {0}", (JSIL.GetType(actual)).get_Name()), "actual");
      }
      invocationDescriptor = new ($T06())(testDelegate);
    }
    return invocationDescriptor;
  };

  function ExceptionInterceptor_Intercept (invocation, $exception) {
    var invocationDescriptor = $thisType.GetInvocationDescriptor(invocation);
    if ($S01().CallStatic($T08(), "IsAsyncOperation", null, $IM00().Call(invocationDescriptor, null))) {
      var asyncInvocationRegion = $S02().CallStatic($T08(), "Create", null, $IM00().Call(invocationDescriptor, null));
      try {
        var invocationResult = $IM01().Call(invocationDescriptor, null);
        try {
          asyncInvocationRegion.WaitForPendingOperationsToComplete(invocationResult);
          var result = null;
          return result;
        } catch ($exception) {
          var ex = $exception;
          result = ex;
          return result;
        }
      } finally {
        if (asyncInvocationRegion !== null) {
          $IM02().Call(asyncInvocationRegion, null);
        }
      }
    }
    try {
      $IM01().Call(invocationDescriptor, null);
      result = null;
    } catch ($exception) {
      var ex = $exception;
      result = ex;
    }
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ExceptionInterceptor", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      ExceptionInterceptor__ctor
    );

    $.Method({Static:true , Public:false}, "GetInvocationDescriptor", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.IInvocationDescriptor"), [$.Object]), 
      ExceptionInterceptor_GetInvocationDescriptor
    );

    $.Method({Static:true , Public:false}, "Intercept", 
      new JSIL.MethodSignature($asm0A.TypeRef("System.Exception"), [$.Object]), 
      ExceptionInterceptor_Intercept
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface NUnit.Framework.Constraints.IInvocationDescriptor */ 

JSIL.MakeInterface(
  "NUnit.Framework.Constraints.IInvocationDescriptor", false, [], function ($) {
    $.Method({}, "Invoke", JSIL.MethodSignature.Return($.Object));
    $.Method({}, "get_Delegate", JSIL.MethodSignature.Return($asm0A.TypeRef("System.Delegate")));
    $.Property({}, "Delegate");
  }, []);

/* class NUnit.Framework.Constraints.VoidInvocationDescriptor */ 

(function VoidInvocationDescriptor$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.TestDelegate)) ();
  };

  function VoidInvocationDescriptor__ctor (del) {
    this._del = del;
  };

  function VoidInvocationDescriptor_get_Delegate () {
    return this._del;
  };

  function VoidInvocationDescriptor_Invoke () {
    this._del();
    return null;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.VoidInvocationDescriptor", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.TestDelegate")), 
      VoidInvocationDescriptor__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Delegate", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Delegate")), 
      VoidInvocationDescriptor_get_Delegate
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Invoke", 
      JSIL.MethodSignature.Return($.Object), 
      VoidInvocationDescriptor_Invoke
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_del", $asm0B.TypeRef("NUnit.Framework.TestDelegate")); 
    $.Property({Static:false, Public:true , Virtual:true }, "Delegate", $asm0A.TypeRef("System.Delegate"));

    $.ImplementInterfaces(
      /* 0 */ $asm0B.TypeRef("NUnit.Framework.Constraints.IInvocationDescriptor")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.GenericInvocationDescriptor`1 */ 

(function GenericInvocationDescriptor$b1$Members () {
  var $, $thisType;
  function GenericInvocationDescriptor$b1__ctor (del) {
    this._del = del;
  };

  function GenericInvocationDescriptor$b1_get_Delegate () {
    return this._del;
  };

  function GenericInvocationDescriptor$b1_Invoke () {
    return this._del();
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.GenericInvocationDescriptor`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", [$.GenericParameter("T")])]), 
      GenericInvocationDescriptor$b1__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_Delegate", 
      JSIL.MethodSignature.Return($asm0A.TypeRef("System.Delegate")), 
      GenericInvocationDescriptor$b1_get_Delegate
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Invoke", 
      JSIL.MethodSignature.Return($.Object), 
      GenericInvocationDescriptor$b1_Invoke
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "_del", $asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", [$.GenericParameter("T")])); 
    $.Property({Static:false, Public:true , Virtual:true }, "Delegate", $asm0A.TypeRef("System.Delegate"));

    $.ImplementInterfaces(
      /* 0 */ $asm0B.TypeRef("NUnit.Framework.Constraints.IInvocationDescriptor")
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ThrowsNothingConstraint */ 

(function ThrowsNothingConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExceptionInterceptor)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Boolean"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function ThrowsNothingConstraint__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function ThrowsNothingConstraint_Matches (actual) {
    this.caughtException = $T02().Intercept(actual);
    return (this.caughtException === null);
  };

  function ThrowsNothingConstraint_Matches$b1$00 (T, del) {
    return $S00().CallVirtual("Matches", null, this, new ($asm0B.NUnit.Framework.Constraints.GenericInvocationDescriptor$b1.Of(T)) (del));
  };

  function ThrowsNothingConstraint_WriteActualValueTo (writer) {
    $S01().CallVirtual("WriteLine", null, writer, " ({0})", (this.caughtException).get_Message());
    $S02().CallVirtual("Write", null, writer, (this.caughtException).get_StackTrace());
  };

  function ThrowsNothingConstraint_WriteDescriptionTo (writer) {
    $S02().CallVirtual("Write", null, writer, $T07().Format("No Exception to be thrown", JSIL.Array.New($T01(), 0)));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.ThrowsNothingConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ThrowsNothingConstraint__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      ThrowsNothingConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$asm0B.TypeRef("NUnit.Framework.Constraints.ActualValueDelegate`1", ["!!0"])], ["T"]), 
      ThrowsNothingConstraint_Matches$b1$00
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ThrowsNothingConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      ThrowsNothingConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "caughtException", $asm0A.TypeRef("System.Exception")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.Tolerance */ 

(function Tolerance$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ToleranceMode)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Numerics)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.TimeSpan)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Convert)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.InvalidOperationException"), [$asm0A.TypeRef("System.String")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Double"), [$asm0A.TypeRef("System.Object")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance"), [$asm0A.TypeRef("System.Object"), $asm0B.TypeRef("NUnit.Framework.Constraints.ToleranceMode")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Int64"), [$asm0A.TypeRef("System.Object")]))) ();
  };

  function Tolerance__ctor$00 (amount) {
    $thisType.prototype._ctor.call(this, amount, $T01().Linear);
  };

  function Tolerance__ctor$01 (amount, mode) {
    this.amount = amount;
    this.mode = mode;
  };

  function Tolerance_CheckLinearAndNumeric () {
    if (this.mode !== $T01().Linear) {
      throw $S00().Construct((
          (((this.mode).valueOf() | 0) === 0)
             ? "Tolerance amount must be specified before setting mode"
             : "Tried to use multiple tolerance modes at the same time")
      );
    }
    if (!$T03().IsNumericType(this.amount)) {
      throw $S00().Construct("A numeric tolerance is required");
    }
  };

  function Tolerance_get_Days () {
    this.CheckLinearAndNumeric();
    return $S01().Construct($T04().FromDays($S02().CallStatic($T05(), "ToDouble", null, this.amount)).MemberwiseClone());
  };

  function Tolerance_get_Empty () {
    return $S03().Construct(0, $T01().None);
  };

  function Tolerance_get_Hours () {
    this.CheckLinearAndNumeric();
    return $S01().Construct($T04().FromHours($S02().CallStatic($T05(), "ToDouble", null, this.amount)).MemberwiseClone());
  };

  function Tolerance_get_IsEmpty () {
    return (this.mode === $T01().None);
  };

  function Tolerance_get_Milliseconds () {
    this.CheckLinearAndNumeric();
    return $S01().Construct($T04().FromMilliseconds($S02().CallStatic($T05(), "ToDouble", null, this.amount)).MemberwiseClone());
  };

  function Tolerance_get_Minutes () {
    this.CheckLinearAndNumeric();
    return $S01().Construct($T04().FromMinutes($S02().CallStatic($T05(), "ToDouble", null, this.amount)).MemberwiseClone());
  };

  function Tolerance_get_Mode () {
    return this.mode;
  };

  function Tolerance_get_Percent () {
    this.CheckLinearAndNumeric();
    return $S03().Construct(this.amount, $T01().Percent);
  };

  function Tolerance_get_Seconds () {
    this.CheckLinearAndNumeric();
    return $S01().Construct($T04().FromSeconds($S02().CallStatic($T05(), "ToDouble", null, this.amount)).MemberwiseClone());
  };

  function Tolerance_get_Ticks () {
    this.CheckLinearAndNumeric();
    return $S01().Construct($T04().FromTicks($S04().CallStatic($T05(), "ToInt64", null, this.amount)).MemberwiseClone());
  };

  function Tolerance_get_Ulps () {
    this.CheckLinearAndNumeric();
    return $S03().Construct(this.amount, $T01().Ulps);
  };

  function Tolerance_get_Value () {
    return this.amount;
  };

  function Tolerance_get_Zero () {
    return $S03().Construct(0, $T01().Linear);
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.Tolerance", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Object), 
      Tolerance__ctor$00
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.Object, $asm0B.TypeRef("NUnit.Framework.Constraints.ToleranceMode")]), 
      Tolerance__ctor$01
    );

    $.Method({Static:false, Public:false}, "CheckLinearAndNumeric", 
      JSIL.MethodSignature.Void, 
      Tolerance_CheckLinearAndNumeric
    );

    $.Method({Static:false, Public:true }, "get_Days", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Days
    );

    $.Method({Static:true , Public:true }, "get_Empty", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Empty
    );

    $.Method({Static:false, Public:true }, "get_Hours", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Hours
    );

    $.Method({Static:false, Public:true }, "get_IsEmpty", 
      JSIL.MethodSignature.Return($.Boolean), 
      Tolerance_get_IsEmpty
    );

    $.Method({Static:false, Public:true }, "get_Milliseconds", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Milliseconds
    );

    $.Method({Static:false, Public:true }, "get_Minutes", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Minutes
    );

    $.Method({Static:false, Public:true }, "get_Mode", 
      JSIL.MethodSignature.Return($asm0B.TypeRef("NUnit.Framework.Constraints.ToleranceMode")), 
      Tolerance_get_Mode
    );

    $.Method({Static:false, Public:true }, "get_Percent", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Percent
    );

    $.Method({Static:false, Public:true }, "get_Seconds", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Seconds
    );

    $.Method({Static:false, Public:true }, "get_Ticks", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Ticks
    );

    $.Method({Static:false, Public:true }, "get_Ulps", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Ulps
    );

    $.Method({Static:false, Public:true }, "get_Value", 
      JSIL.MethodSignature.Return($.Object), 
      Tolerance_get_Value
    );

    $.Method({Static:true , Public:true }, "get_Zero", 
      JSIL.MethodSignature.Return($.Type), 
      Tolerance_get_Zero
    );

    $.Constant({Static:true , Public:false}, "ModeMustFollowTolerance", "Tolerance amount must be specified before setting mode"); 
    $.Constant({Static:true , Public:false}, "MultipleToleranceModes", "Tried to use multiple tolerance modes at the same time"); 
    $.Constant({Static:true , Public:false}, "NumericToleranceRequired", "A numeric tolerance is required"); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "mode", $asm0B.TypeRef("NUnit.Framework.Constraints.ToleranceMode")); 
    $.Field({Static:false, Public:false, ReadOnly:true }, "amount", $.Object); 
    $.Property({Static:true , Public:true }, "Empty", $.Type);

    $.Property({Static:true , Public:true }, "Zero", $.Type);

    $.Property({Static:false, Public:true }, "Mode", $asm0B.TypeRef("NUnit.Framework.Constraints.ToleranceMode"));

    $.Property({Static:false, Public:true }, "Value", $.Object);

    $.Property({Static:false, Public:true }, "Percent", $.Type);

    $.Property({Static:false, Public:true }, "Ulps", $.Type);

    $.Property({Static:false, Public:true }, "Days", $.Type);

    $.Property({Static:false, Public:true }, "Hours", $.Type);

    $.Property({Static:false, Public:true }, "Minutes", $.Type);

    $.Property({Static:false, Public:true }, "Seconds", $.Type);

    $.Property({Static:false, Public:true }, "Milliseconds", $.Type);

    $.Property({Static:false, Public:true }, "Ticks", $.Type);

    $.Property({Static:false, Public:true }, "IsEmpty", $.Boolean);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum NUnit.Framework.Constraints.ToleranceMode */ 

JSIL.MakeEnum(
  {
    FullName: "NUnit.Framework.Constraints.ToleranceMode", 
    BaseType: $asm0A.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    None: 0, 
    Linear: 1, 
    Percent: 2, 
    Ulps: 3, 
  }
);

/* class NUnit.Framework.Constraints.TrueConstraint */ 

(function TrueConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BasicConstraint)) ();
  };

  function TrueConstraint__ctor () {
    $T00().prototype._ctor.call(this, true, "True");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.BasicConstraint"), 
      Name: "NUnit.Framework.Constraints.TrueConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      TrueConstraint__ctor
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.UniqueItemsConstraint */ 

(function UniqueItemsConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionItemsEqualConstraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Collections.IEnumerable)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Collections.ArrayList)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Collections.IEnumerator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IDisposable)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.Collections.ArrayList"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm0A.System.Collections.IEnumerable.GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm0A.System.Collections.IEnumerator.get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm0A.System.IDisposable.Dispose)) ();
  };

  function UniqueItemsConstraint__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function UniqueItemsConstraint_doMatch (actual) {
    var arrayList = $S00().Construct();
    var enumerator = $IM00().Call(actual, null);
    try {

      while ($IM01().Call(enumerator, null)) {
        var current = $IM02().Call(enumerator, null);
        var enumerator2 = arrayList.GetEnumerator();
        try {

          while ($IM01().Call(enumerator2, null)) {
            var current2 = $IM02().Call(enumerator2, null);
            if (this.ItemsEqual(current, current2)) {
              var result = false;
              return result;
            }
          }
        } finally {
          var disposable = $T06().$As(enumerator2);
          if (disposable !== null) {
            $IM03().Call(disposable, null);
          }
        }
        arrayList.Add(current);
      }
    } finally {
      disposable = $T06().$As(enumerator);
      if (disposable !== null) {
        $IM03().Call(disposable, null);
      }
    }
    result = true;
    return result;
  };

  function UniqueItemsConstraint_WriteDescriptionTo (writer) {
    $S01().CallVirtual("Write", null, writer, "all items unique");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionItemsEqualConstraint"), 
      Name: "NUnit.Framework.Constraints.UniqueItemsConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      UniqueItemsConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "doMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm0A.TypeRef("System.Collections.IEnumerable")]), 
      UniqueItemsConstraint_doMatch
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      UniqueItemsConstraint_WriteDescriptionTo
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.XmlSerializableConstraint */ 

(function XmlSerializableConstraint$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.ArgumentException)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.IO.MemoryStream)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0F.System.Xml.Serialization.XmlSerializer)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0A.System.IO.Stream)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0A.System.Int64)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm0A.System.IO.SeekOrigin)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm0A.System.Boolean)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm0A.System.NotSupportedException)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm0A.System.InvalidOperationException)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.MessageWriter)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm0A.System.IO.TextWriter)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize($asm0A.System.Reflection.MemberInfo)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.ArgumentException"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0A.TypeRef("System.IO.MemoryStream"), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm0F.TypeRef("System.Xml.Serialization.XmlSerializer"), [$asm0A.TypeRef("System.Type")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.IO.Stream"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm0A.TypeRef("System.Object"), [$asm0A.TypeRef("System.IO.Stream")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Object")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(JSIL.MethodSignature.Action($asm0A.TypeRef("System.String")))) ();
  };

  function XmlSerializableConstraint__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function XmlSerializableConstraint_GetStringRepresentation () {
    return "<xmlserializable>";
  };

  function XmlSerializableConstraint_Matches (actual, $exception) {
    this.actual = actual;
    if (actual === null) {
      throw $S00().Construct();
    }
    var memoryStream = $S01().Construct();
    try {
      this.serializer = $S02().Construct(JSIL.GetType(actual));
      $S03().CallVirtual("Serialize", null, this.serializer, memoryStream, actual);
      memoryStream.Seek($T07().Create(0, 0, 0), $T08().Begin);
      var obj = $S04().CallVirtual("Deserialize", null, this.serializer, memoryStream);
      var result = obj !== null;
    } catch ($exception) {
      if ($T0A().$Is($exception)) {
        result = false;
      } else if ($T0B().$Is($exception)) {
        result = false;
      } else {
        throw $exception;
      }
    }
    return result;
  };

  function XmlSerializableConstraint_WriteActualValueTo (writer) {
    $S05().CallVirtual("Write", null, writer, "<{0}>", (JSIL.GetType(this.actual)).get_Name());
  };

  function XmlSerializableConstraint_WriteDescriptionTo (writer) {
    $S06().CallVirtual("Write", null, writer, "xml serializable");
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), 
      Name: "NUnit.Framework.Constraints.XmlSerializableConstraint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      XmlSerializableConstraint__ctor
    );

    $.Method({Static:false, Public:false, Virtual:true }, "GetStringRepresentation", 
      JSIL.MethodSignature.Return($.String), 
      XmlSerializableConstraint_GetStringRepresentation
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Matches", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      XmlSerializableConstraint_Matches
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteActualValueTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      XmlSerializableConstraint_WriteActualValueTo
    );

    $.Method({Static:false, Public:true , Virtual:true }, "WriteDescriptionTo", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.MessageWriter")), 
      XmlSerializableConstraint_WriteDescriptionTo
    );

    $.Field({Static:false, Public:false}, "serializer", $asm0F.TypeRef("System.Xml.Serialization.XmlSerializer")); 
    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ConstraintOperator */ 

(function ConstraintOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Object)) ();
  };

  function ConstraintOperator__ctor () {
  };

  function ConstraintOperator_get_LeftContext () {
    return this.leftContext;
  };

  function ConstraintOperator_get_LeftPrecedence () {
    return this.left_precedence;
  };

  function ConstraintOperator_get_RightContext () {
    return this.rightContext;
  };

  function ConstraintOperator_get_RightPrecedence () {
    return this.right_precedence;
  };

  function ConstraintOperator_set_LeftContext (value) {
    this.leftContext = value;
  };

  function ConstraintOperator_set_RightContext (value) {
    this.rightContext = value;
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Object"), 
      Name: "NUnit.Framework.Constraints.ConstraintOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      ConstraintOperator__ctor
    );

    $.Method({Static:false, Public:true }, "get_LeftContext", 
      JSIL.MethodSignature.Return($.Object), 
      ConstraintOperator_get_LeftContext
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LeftPrecedence", 
      JSIL.MethodSignature.Return($.Int32), 
      ConstraintOperator_get_LeftPrecedence
    );

    $.Method({Static:false, Public:true }, "get_RightContext", 
      JSIL.MethodSignature.Return($.Object), 
      ConstraintOperator_get_RightContext
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_RightPrecedence", 
      JSIL.MethodSignature.Return($.Int32), 
      ConstraintOperator_get_RightPrecedence
    );

    $.Method({Static:false, Public:true }, "set_LeftContext", 
      JSIL.MethodSignature.Action($.Object), 
      ConstraintOperator_set_LeftContext
    );

    $.Method({Static:false, Public:true }, "set_RightContext", 
      JSIL.MethodSignature.Action($.Object), 
      ConstraintOperator_set_RightContext
    );

    $.Field({Static:false, Public:false}, "leftContext", $.Object); 
    $.Field({Static:false, Public:false}, "rightContext", $.Object); 
    $.Field({Static:false, Public:false}, "left_precedence", $.Int32); 
    $.Field({Static:false, Public:false}, "right_precedence", $.Int32); 
    $.Property({Static:false, Public:true }, "LeftContext", $.Object);

    $.Property({Static:false, Public:true }, "RightContext", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "LeftPrecedence", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "RightPrecedence", $.Int32);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.PrefixOperator */ 

(function PrefixOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder_ConstraintStack)) ();
  };

  function PrefixOperator__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function PrefixOperator_Reduce (stack) {
    stack.Push(this.ApplyPrefix(stack.Pop()));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator"), 
      Name: "NUnit.Framework.Constraints.PrefixOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      PrefixOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Reduce", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack")), 
      PrefixOperator_Reduce
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.CollectionOperator */ 

(function CollectionOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixOperator)) ();
  };

  function CollectionOperator__ctor () {
    $T00().prototype._ctor.call(this);
    this.left_precedence = 1;
    this.right_precedence = 10;
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixOperator"), 
      Name: "NUnit.Framework.Constraints.CollectionOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      CollectionOperator__ctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AllOperator */ 

(function AllOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AllItemsConstraint)) ();
  };

  function AllOperator__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function AllOperator_ApplyPrefix (constraint) {
    return new ($T02())(constraint);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOperator"), 
      Name: "NUnit.Framework.Constraints.AllOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AllOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyPrefix", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      AllOperator_ApplyPrefix
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.BinaryOperator */ 

(function BinaryOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOperator)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder_ConstraintStack)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };

  function BinaryOperator__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function BinaryOperator_get_LeftPrecedence () {
    return (
      ($T01().$As(this.get_RightContext()) !== null)
         ? ((($T00().prototype.get_LeftPrecedence.call(this) | 0) + 10) | 0)
         : $T00().prototype.get_LeftPrecedence.call(this))
    ;
  };

  function BinaryOperator_get_RightPrecedence () {
    return (
      ($T01().$As(this.get_RightContext()) !== null)
         ? ((($T00().prototype.get_RightPrecedence.call(this) | 0) + 10) | 0)
         : $T00().prototype.get_RightPrecedence.call(this))
    ;
  };

  function BinaryOperator_Reduce (stack) {
    var right = stack.Pop();
    var left = stack.Pop();
    stack.Push(this.ApplyOperator(left, right));
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator"), 
      Name: "NUnit.Framework.Constraints.BinaryOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      BinaryOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_LeftPrecedence", 
      JSIL.MethodSignature.Return($.Int32), 
      BinaryOperator_get_LeftPrecedence
    );

    $.Method({Static:false, Public:true , Virtual:true }, "get_RightPrecedence", 
      JSIL.MethodSignature.Return($.Int32), 
      BinaryOperator_get_RightPrecedence
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Reduce", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack")), 
      BinaryOperator_Reduce
    );

    $.Property({Static:false, Public:true , Virtual:true }, "LeftPrecedence", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "RightPrecedence", $.Int32);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AndOperator */ 

(function AndOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinaryOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AndConstraint)) ();
  };

  function AndOperator__ctor () {
    $T00().prototype._ctor.call(this);
    this.left_precedence = this.right_precedence = 2;
  };

  function AndOperator_ApplyOperator (left, right) {
    return new ($T02())(left, right);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.BinaryOperator"), 
      Name: "NUnit.Framework.Constraints.AndOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AndOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyOperator", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      AndOperator_ApplyOperator
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SelfResolvingOperator */ 

(function SelfResolvingOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };

  function SelfResolvingOperator__ctor () {
    $T00().prototype._ctor.call(this);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintOperator"), 
      Name: "NUnit.Framework.Constraints.SelfResolvingOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      SelfResolvingOperator__ctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.AttributeOperator */ 

(function AttributeOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Type)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SelfResolvingOperator)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder_ConstraintStack)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinaryOperator)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AttributeExistsConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.AttributeConstraint)) ();
  };

  function AttributeOperator__ctor (type) {
    $T01().prototype._ctor.call(this);
    this.type = type;
    this.left_precedence = this.right_precedence = 1;
  };

  function AttributeOperator_Reduce (stack) {
    if (!((this.get_RightContext() !== null) && !$T05().$Is(this.get_RightContext()))) {
      stack.Push(new ($T06())(this.type));
    } else {
      stack.Push(new ($T07())(this.type, stack.Pop()));
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.SelfResolvingOperator"), 
      Name: "NUnit.Framework.Constraints.AttributeOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0A.TypeRef("System.Type")), 
      AttributeOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Reduce", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack")), 
      AttributeOperator_Reduce
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "type", $asm0A.TypeRef("System.Type")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ExactCountOperator */ 

(function ExactCountOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOperator)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ExactCountConstraint)) ();
  };

  function ExactCountOperator__ctor (expectedCount) {
    $T01().prototype._ctor.call(this);
    this.expectedCount = (expectedCount | 0);
  };

  function ExactCountOperator_ApplyPrefix (constraint) {
    return new ($T03())(this.expectedCount, constraint);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOperator"), 
      Name: "NUnit.Framework.Constraints.ExactCountOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32), 
      ExactCountOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyPrefix", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      ExactCountOperator_ApplyPrefix
    );

    $.Field({Static:false, Public:false}, "expectedCount", $.Int32); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NoneOperator */ 

(function NoneOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NoItemConstraint)) ();
  };

  function NoneOperator__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function NoneOperator_ApplyPrefix (constraint) {
    return new ($T02())(constraint);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOperator"), 
      Name: "NUnit.Framework.Constraints.NoneOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NoneOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyPrefix", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      NoneOperator_ApplyPrefix
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.NotOperator */ 

(function NotOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.NotConstraint)) ();
  };

  function NotOperator__ctor () {
    $T00().prototype._ctor.call(this);
    this.left_precedence = this.right_precedence = 1;
  };

  function NotOperator_ApplyPrefix (constraint) {
    return new ($T02())(constraint);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixOperator"), 
      Name: "NUnit.Framework.Constraints.NotOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NotOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyPrefix", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      NotOperator_ApplyPrefix
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.OrOperator */ 

(function OrOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinaryOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.OrConstraint)) ();
  };

  function OrOperator__ctor () {
    $T00().prototype._ctor.call(this);
    this.left_precedence = this.right_precedence = 3;
  };

  function OrOperator_ApplyOperator (left, right) {
    return new ($T02())(left, right);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.BinaryOperator"), 
      Name: "NUnit.Framework.Constraints.OrOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      OrOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyOperator", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), $asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      OrOperator_ApplyOperator
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.PropOperator */ 

(function PropOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SelfResolvingOperator)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder_ConstraintStack)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinaryOperator)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PropertyExistsConstraint)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PropertyConstraint)) ();
  };

  function PropOperator__ctor (name) {
    $T01().prototype._ctor.call(this);
    this.$name = name;
    this.left_precedence = this.right_precedence = 1;
  };

  function PropOperator_get_Name () {
    return this.$name;
  };

  function PropOperator_Reduce (stack) {
    if (!((this.get_RightContext() !== null) && !$T05().$Is(this.get_RightContext()))) {
      stack.Push(new ($T06())(this.$name));
    } else {
      stack.Push(new ($T07())(this.$name, stack.Pop()));
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.SelfResolvingOperator"), 
      Name: "NUnit.Framework.Constraints.PropOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      PropOperator__ctor
    );

    $.Method({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String), 
      PropOperator_get_Name
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Reduce", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack")), 
      PropOperator_Reduce
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "$name", $.String); 
    $.Property({Static:false, Public:true }, "Name", $.String);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.SomeOperator */ 

(function SomeOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.CollectionOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SomeItemsConstraint)) ();
  };

  function SomeOperator__ctor () {
    $T00().prototype._ctor.call(this);
  };

  function SomeOperator_ApplyPrefix (constraint) {
    return new ($T02())(constraint);
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.CollectionOperator"), 
      Name: "NUnit.Framework.Constraints.SomeOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      SomeOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyPrefix", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      SomeOperator_ApplyPrefix
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.ThrowsOperator */ 

(function ThrowsOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.SelfResolvingOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintBuilder_ConstraintStack)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ConstraintOperator)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.BinaryOperator)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.ThrowsConstraint)) ();
  };

  function ThrowsOperator__ctor () {
    $T00().prototype._ctor.call(this);
    this.left_precedence = 1;
    this.right_precedence = 100;
  };

  function ThrowsOperator_Reduce (stack) {
    if (!((this.get_RightContext() !== null) && !$T04().$Is(this.get_RightContext()))) {
      stack.Push(new ($T05())(null));
    } else {
      stack.Push(new ($T05())(stack.Pop()));
    }
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.SelfResolvingOperator"), 
      Name: "NUnit.Framework.Constraints.ThrowsOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ThrowsOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Reduce", 
      JSIL.MethodSignature.Action($asm0B.TypeRef("NUnit.Framework.Constraints.ConstraintBuilder+ConstraintStack")), 
      ThrowsOperator_Reduce
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.Constraints.WithOperator */ 

(function WithOperator$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.PrefixOperator)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0B.NUnit.Framework.Constraints.Constraint)) ();
  };

  function WithOperator__ctor () {
    $T00().prototype._ctor.call(this);
    this.left_precedence = 1;
    this.right_precedence = 4;
  };

  function WithOperator_ApplyPrefix (constraint) {
    return constraint;
  };

  JSIL.MakeType({
      BaseType: $asm0B.TypeRef("NUnit.Framework.Constraints.PrefixOperator"), 
      Name: "NUnit.Framework.Constraints.WithOperator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      WithOperator__ctor
    );

    $.Method({Static:false, Public:true , Virtual:true }, "ApplyPrefix", 
      new JSIL.MethodSignature($asm0B.TypeRef("NUnit.Framework.Constraints.Constraint"), [$asm0B.TypeRef("NUnit.Framework.Constraints.Constraint")]), 
      WithOperator_ApplyPrefix
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.AssertionException */ 

(function AssertionException$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Runtime.Serialization.SerializationInfo)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Runtime.Serialization.StreamingContext)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Exception")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]))) ();
  };

  function AssertionException__ctor$00 (message) {
    $T01().prototype._ctor.call(this, message);
  };

  function AssertionException__ctor$01 (message, inner) {
    $S00().Call($T01().prototype, "_ctor", null, this, message, inner);
  };

  function AssertionException__ctor$02 (info, context) {
    $S01().Call($T01().prototype, "_ctor", null, this, info, context.MemberwiseClone());
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Exception"), 
      Name: "NUnit.Framework.AssertionException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      AssertionException__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm0A.TypeRef("System.Exception")]), 
      AssertionException__ctor$01
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]), 
      AssertionException__ctor$02
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.IgnoreException */ 

(function IgnoreException$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Runtime.Serialization.SerializationInfo)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Runtime.Serialization.StreamingContext)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Exception")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]))) ();
  };

  function IgnoreException__ctor$00 (message) {
    $T01().prototype._ctor.call(this, message);
  };

  function IgnoreException__ctor$01 (message, inner) {
    $S00().Call($T01().prototype, "_ctor", null, this, message, inner);
  };

  function IgnoreException__ctor$02 (info, context) {
    $S01().Call($T01().prototype, "_ctor", null, this, info, context.MemberwiseClone());
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Exception"), 
      Name: "NUnit.Framework.IgnoreException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      IgnoreException__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm0A.TypeRef("System.Exception")]), 
      IgnoreException__ctor$01
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]), 
      IgnoreException__ctor$02
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.InconclusiveException */ 

(function InconclusiveException$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Runtime.Serialization.SerializationInfo)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Runtime.Serialization.StreamingContext)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Exception")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]))) ();
  };

  function InconclusiveException__ctor$00 (message) {
    $T01().prototype._ctor.call(this, message);
  };

  function InconclusiveException__ctor$01 (message, inner) {
    $S00().Call($T01().prototype, "_ctor", null, this, message, inner);
  };

  function InconclusiveException__ctor$02 (info, context) {
    $S01().Call($T01().prototype, "_ctor", null, this, info, context.MemberwiseClone());
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Exception"), 
      Name: "NUnit.Framework.InconclusiveException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      InconclusiveException__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm0A.TypeRef("System.Exception")]), 
      InconclusiveException__ctor$01
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]), 
      InconclusiveException__ctor$02
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class NUnit.Framework.SuccessException */ 

(function SuccessException$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0A.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0A.System.Exception)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm0A.System.Runtime.Serialization.SerializationInfo)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm0A.System.Runtime.Serialization.StreamingContext)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.String"), $asm0A.TypeRef("System.Exception")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]))) ();
  };

  function SuccessException__ctor$00 (message) {
    $T01().prototype._ctor.call(this, message);
  };

  function SuccessException__ctor$01 (message, inner) {
    $S00().Call($T01().prototype, "_ctor", null, this, message, inner);
  };

  function SuccessException__ctor$02 (info, context) {
    $S01().Call($T01().prototype, "_ctor", null, this, info, context.MemberwiseClone());
  };

  JSIL.MakeType({
      BaseType: $asm0A.TypeRef("System.Exception"), 
      Name: "NUnit.Framework.SuccessException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String), 
      SuccessException__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm0A.TypeRef("System.Exception")]), 
      SuccessException__ctor$01
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0A.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0A.TypeRef("System.Runtime.Serialization.StreamingContext")]), 
      SuccessException__ctor$02
    );

    $.ImplementInterfaces(
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface NUnit.Framework.INUnitEqualityComparer`1 */ 

JSIL.MakeInterface(
  "NUnit.Framework.INUnitEqualityComparer`1", true, ["T"], function ($) {
    $.Method({}, "AreEqual", new JSIL.MethodSignature($.Boolean, [
          $.GenericParameter("T"), $.GenericParameter("T"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm0B.TypeRef("NUnit.Framework.Constraints.Tolerance")])
        ]));
  }, []);

